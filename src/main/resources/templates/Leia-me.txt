public Anime findById(Long id ) {
		return   animes.stream()
				.filter(anime -> anime.getId().equals(id))
				.findFirst().orElseThrow(()-> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found"));
}


Este script é um método em Java que recebe um ID como parâmetro e busca por um objeto Anime em uma lista de animes usando programação funcional 
com Stream.

Vamos analisar o código por partes:

   public Anime findById(Long id): Esta é a declaração do método público chamado findById que retorna um objeto do tipo Anime. Ele aceita um 
   parâmetro id do tipo Long.

   return animes.stream(): Aqui, é criado um fluxo (stream) a partir da lista de animes chamada animes. Um fluxo é uma sequência de elementos 
   que pode ser processada de maneira sequencial ou paralela.

   .filter(anime -> anime.getId().equals(id)): O método filter é usado para filtrar elementos do fluxo com base em uma condição. Neste caso, 
   está filtrando os animes cujo ID seja igual ao ID passado como parâmetro.

   .findFirst(): O método findFirst retorna o primeiro elemento do fluxo que satisfaça a condição definida no filtro. Neste caso, retorna o 
   primeiro anime com o ID correspondente.

   .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found")): O método orElseThrow é usado para retornar o valor 
   presente no fluxo, caso exista. Se o fluxo estiver vazio (nenhum anime corresponde ao ID), uma exceção é lançada. No caso, uma 
   ResponseStatusException com um status HTTP BAD_REQUEST (código 400) é lançada, indicando que o anime não foi encontrado.

Portanto, esse método busca por um anime na lista de animes pelo ID usando programação funcional com Stream. Se o anime for encontrado, ele é 
retornado. Caso contrário, uma exceção é lançada indicando que o anime não foi encontrado.

É importante notar que o código pressupõe a existência de uma lista de animes chamada animes que contém os objetos Anime a serem pesquisados. 
Além disso, a classe Anime deve ter um método getId() para acessar o ID do anime. A exceção ResponseStatusException é lançada com base no 
framework Spring Web para lidar com respostas HTTP em APIs.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A propriedade `server.error.include-stacktrace` é uma configuração que pode ser usada em aplicações Spring Boot para controlar se as informações 
de rastreamento de pilha (stack trace) são incluídas nas respostas de erro HTTP retornadas pela aplicação em caso de exceções.

Os valores possíveis para a propriedade `server.error.include-stacktrace` são:

1. `on-param` (valor padrão):
   - Isso significa que o rastreamento de pilha é incluído na resposta somente se um parâmetro de consulta chamado `trace` estiver presente na 
     solicitação HTTP. Isso permite que você escolha se deseja ou não incluir o rastreamento de pilha nas respostas de erro, controlando-o 
     através da presença ou ausência do parâmetro de consulta.

2. `always`:
   - Isso faz com que o rastreamento de pilha seja sempre incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta específico. Isso pode ser útil para depuração e diagnóstico de problemas.

3. `never`:
   - Isso faz com que o rastreamento de pilha nunca seja incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta. Essa opção pode ser usada para ocultar informações sensíveis ou internas da aplicação nos erros retornados aos usuários.

Essa propriedade é útil para controlar o nível de detalhes das mensagens de erro retornadas pelas APIs e pode ser configurada no arquivo 
`application.properties` ou `application.yml` da sua aplicação Spring Boot. Ela pode ajudar a equilibrar a necessidade de informações detalhadas 
para depuração com a segurança e a privacidade das informações do aplicativo.

Exemplo de configuração no `application.properties`:

```properties
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server.error.include-stacktrace=on-param
```

Exemplo de configuração no `application.yml`:

```yaml
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server:
  error:
    include-stacktrace: on-param
```

Lembre-se de que essa configuração afeta a maneira como as respostas de erro são geradas e retornadas pela sua aplicação Spring Boot.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A anotação @RequestBody é uma anotação fornecida pelo Spring Framework em aplicações Spring MVC e Spring WebFlux. Ela é usada para indicar que um 
parâmetro de método em um controlador deve ser vinculado ao corpo (body) da solicitação HTTP recebida. Essa anotação é frequentemente usada ao 
criar endpoints de API que recebem dados em formato JSON ou outros formatos no corpo da solicitação.

Quando você adiciona a anotação @RequestBody a um parâmetro de método, o Spring Framework assume que os dados no corpo da solicitação HTTP devem 
ser convertidos automaticamente para o tipo do parâmetro, geralmente um objeto Java.

A anotação @RequestBody é frequentemente usada em conjunto com outros métodos do Spring Framework, como @PostMapping, @PutMapping e outros, para 
criar endpoints de API que aceitam dados no corpo da solicitação. Isso é especialmente útil em cenários de criação, atualização ou envio de 
informações em APIs RESTful.

Lembre-se de que o Spring Framework usa a biblioteca Jackson para realizar a desserialização automática de JSON para objetos Java. Portanto, é 
importante ter as dependências do Jackson configuradas em seu projeto para que a anotação @RequestBody funcione corretamente.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeService: 

```
anime.setId(ThreadLocalRandom.current().nextLong(3, 100));
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeController: 

```
return new ResponseEntity<>(HttpStatus.NO_CONTENT);
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

O HttpStatus.NO_CONTENT é um valor enumerado (enum) da classe HttpStatus fornecida pelo Spring Framework. Ele representa o status HTTP 204 
No _Content, que é uma resposta padrão usada em APIs RESTful para indicar que uma solicitação foi processada com sucesso, mas não há conteúdo 
para retornar na resposta.

Quando uma solicitação é tratada com sucesso e o servidor não precisa enviar nenhum conteúdo de volta ao cliente, o status HTTP 204 
No_ Content é usado. Isso é comum em casos onde uma solicitação de exclusão, atualização ou outra ação bem-sucedida é processada, mas 
não há necessidade de enviar um corpo de resposta.

Em termos simples, o HttpStatus.NO_CONTENT é usado para indicar que a solicitação foi bem-sucedida e não há conteúdo adicional a ser 
enviado no corpo da resposta. Isso economiza largura de banda e melhora a eficiência da comunicação entre o cliente e o servidor.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vou explicar cada parte do seu arquivo `docker-compose.yml`:

1. `version: '3.1'`: Isso define a versão da especificação do Docker Compose que você está usando. No seu caso, está usando a versão 3.1. Cada 
    versão traz diferentes recursos e sintaxe.

2. `services`: Essa seção define os serviços (ou contêineres) que você deseja executar.

   - `db`: Este é o nome do serviço. Você o nomeou como "db", que é um nome comum para um serviço de banco de dados.
   
      - `image: mysql`: Especifica a imagem do Docker que você deseja usar para esse serviço. Neste caso, está usando a imagem oficial do MySQL 
         disponível no Docker Hub.
      
      - `container_name: mysql`: Isso define o nome do contêiner que será criado. Neste caso, está definindo o nome como "mysql".
      
      - `environment`: Define variáveis ​​de ambiente para o contêiner MySQL. No caso, está definindo a senha do root do MySQL como "root".
      
      - `ports`: Especifica a mapeamento de portas entre o host e o contêiner. Aqui, você está mapeando a porta 3306 do host para a porta 3306 
         do contêiner MySQL. Isso permite que você acesse o MySQL no contêiner por meio da porta 3306 no seu computador local.
      
      - `volumes`: Define os volumes que serão montados no contêiner. Está criando um volume chamado "devdojo_data" e montando-o na pasta 
        `/var/lib/mysql` dentro do contêiner MySQL. Isso é útil para armazenar os dados do banco de dados de forma persistente, mesmo que o 
        contêiner seja destruído.
   
3. `volumes`: Esta seção define os volumes que serão usados ​​pelos serviços.

   - `devdojo_data`: Este é o nome do volume. Está definindo um volume chamado "devdojo_data", que será usado para armazenar os dados do MySQL.

Dessa forma, o Docker Compose irá criar um contêiner MySQL usando a imagem oficial do MySQL, definindo a senha do root como "root", mapeando a 
porta 3306 do host para a porta 3306 do contêiner e criando um volume chamado "devdojo_data" para armazenar os dados do MySQL de forma 
persistente. O nome do contêiner será "mysql". Isso é útil para o desenvolvimento de aplicativos que usam o MySQL, pois permite que você tenha 
um banco de dados isolado e persistente em um contêiner.

--------------- // ---------------
IMPORTANTE!!!

 -> CTRL + C ou docker-compose stop: Para parar a execução do container do docker
 -> docker-compose up: Cria e inicia os containers definidos no arquivo docker-compose.yml.
 -> docker-compose down: Para e remove os containers definidos no arquivo docker-compose.yml.
 -> docker-compose ps: Lista os containers gerenciados pelo Docker Compose.
 -> docker-compose logs: Exibe os logs dos containers gerenciados pelo Docker Compose.
 -> docker-compose build: Constrói os serviços definidos no arquivo docker-compose.yml.
 -> docker-compose start: Inicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose stop: Para os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose restart: Reinicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker ps: Lista os conatiners que estão sendo executados no momento no docker.
 -> docker ps: Lista os containers em execução no momento.
 -> docker ps -a: Lista todos os containers, incluindo os que estão parados.

 --------------- // ---------------

Explicando cada parte desse script de configuração:

```
server:
  error:
    include-stacktrace: on-param

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
```

Este é um arquivo de configuração YAML que define várias configurações para um aplicativo Spring Boot que se conecta a um banco de dados MySQL. 
Vou explicar cada seção:

1. `server:`: Esta seção permite configurar algumas propriedades do servidor embutido do Spring Boot.

   - `error:`: Aqui, está configurando o tratamento de erros. `include-stacktrace: on-param` significa que as mensagens de erro incluirão 
     informações de rastreamento de pilha (stack trace) quando você passar um parâmetro de consulta chamado `on-param`.

2. `spring:`: Esta é a seção principal de configuração relacionada ao Spring Boot.

   - `datasource:`: Aqui, está configurando o DataSource, que é usado para se conectar ao banco de dados.

     - `url`: Esta é a URL de conexão JDBC para o banco de dados MySQL. O `jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true` 
        indica que o banco de dados está localizado em `localhost` na porta `3306`. O `anime` é o nome do banco de dados. Os parâmetros 
        `useSSL=false` e `createDatabaseIfNotExists=true` configuram a conexão para não usar SSL (útil em ambientes de desenvolvimento) e para 
        criar o banco de dados automaticamente se ele não existir.

     - `username`: Define o nome de usuário para autenticação no banco de dados. Aqui, é definido como "root".

     - `password`: Define a senha para autenticação no banco de dados. Aqui, é definido como "root".

   - `jpa:`: Esta é a seção de configuração relacionada à JPA (Java Persistence API), que é usada para trabalhar com persistência de dados em Java.

     - `hibernate:`: Configurações específicas do Hibernate, que é a implementação JPA padrão do Spring Boot.

       - `ddl-auto`: Essa propriedade controla como o Hibernate gerencia o esquema do banco de dados. No valor "update", o Hibernate tentará 
          atualizar automaticamente o esquema do banco de dados com base nas mudanças nas entidades (classes de modelo) do seu aplicativo. Isso 
          é útil durante o desenvolvimento, pois permite que você faça alterações nas suas entidades sem precisar recriar manualmente as tabelas 
          no banco de dados.

Em resumo, esse arquivo de configuração define como o Spring Boot se conectará a um banco de dados MySQL, configurações do Hibernate para 
atualização automática do esquema e algumas configurações de tratamento de erros. Certifique-se de substituir os valores de `username` e 
`password` por valores seguros e adequados para seu ambiente de desenvolvimento ou produção.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos Criar uma Classe DTO AnimePostRequestBody, uma classe DTO (Data Transfer Object) é um padrão de projeto usado no desenvolvimento de 
software para transferir dados entre diferentes partes de um sistema. Ela é uma classe simples que contém campos para armazenar dados e pode
incluir métodos para acessar e manipular esses dados. O principal objetivo de uma classe DTO é encapsular os dados e permitir sua transferência 
eficiente entre diferentes componentes de um sistema, muitas vezes em cenários onde a estrutura dos dados entre esses componentes é diferente.

Os DTOs são frequentemente usados em aplicações que seguem uma arquitetura em camadas, como as aplicações baseadas em microservices, onde 
diferentes partes do sistema podem ter diferentes necessidades de dados e formatos de representação. Eles ajudam a evitar o vazamento de 
abstrações de dados e a reduzir o acoplamento entre as camadas.

Algumas razões pelas quais você pode querer usar DTOs incluem:

1. **Redução de tráfego de rede**: Quando você precisa transferir dados entre um cliente e um servidor, ou entre microservices, pode ser mais 
   eficiente transferir apenas os dados necessários para a operação em vez de todos os campos de uma entidade completa.

2. **Mapeamento entre objetos**: Em um sistema, você pode ter diferentes representações de um objeto para diferentes partes da aplicação 
   (por exemplo, uma representação completa para exibição na interface do usuário e uma representação resumida para APIs). DTOs ajudam a mapear 
   essas diferentes representações.

3. **Segurança**: Em certos casos, você pode querer ocultar certos campos sensíveis ou confidenciais de uma entidade ao transferir dados. DTOs 
   permitem que você selecione apenas os campos necessários para transferência.

4. **Evolução do sistema**: DTOs também permitem que você evolua diferentes partes do sistema independentemente umas das outras. Se a estrutura 
   interna de uma entidade mudar, você pode ajustar apenas o mapeamento entre a entidade e seus DTOs correspondentes, sem afetar a camada que 
   consome esses DTOs.

5. **Aumento de performance**: Em algumas situações, especialmente quando você lida com grandes volumes de dados, o uso de DTOs específicos para 
   as operações pode melhorar a performance, reduzindo a quantidade de dados transferidos e simplificando o processamento.

Lembre-se de que a criação de DTOs adiciona alguma complexidade ao código, pois você terá que gerenciar o mapeamento entre as entidades do 
domínio e os DTOs. Portanto, é importante considerar cuidadosamente se o uso de DTOs é apropriado para o seu caso de uso.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Builder

A anotação `@Builder` é uma anotação do projeto Lombok, uma biblioteca popular para reduzir a verbosidade do código em Java. A anotação `@Builder` 
é usada para gerar automaticamente um padrão de criação de objetos imutáveis usando o padrão Builder. Ela é frequentemente usada em conjunto com 
outras anotações do Lombok, como `@Data` ou `@Value`.

Quando você anota uma classe com `@Builder`, o Lombok cria automaticamente um padrão de construção fluent para a classe, permitindo que você 
crie instâncias dessa classe com mais facilidade e clareza.

Aqui está um exemplo simples de como você usaria a anotação `@Builder`:

```
import lombok.Builder;

@Builder
public class Person {
    private String firstName;
    private String lastName;
    private int age;
}
```

Com essa anotação, o Lombok automaticamente cria um construtor privado na classe `Person` e uma classe interna chamada `PersonBuilder`. Isso 
permite que você crie instâncias de `Person` usando um padrão fluente, como este:

```
Person person = Person.builder()
    .firstName("John")
    .lastName("Doe")
    .age(30)
    .build();
```

Isso ajuda a melhorar a legibilidade do código ao criar objetos com muitos campos, eliminando a necessidade de criar diversos construtores ou 
utilizar construtores telescópicos (com muitos parâmetros) que podem se tornar difíceis de entender.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Framework de Mapeamento MapStruct

O MapStruct é uma biblioteca que simplifica o processo de mapeamento entre objetos Java. Ele gera automaticamente o código de mapeamento 
eficiente em tempo de compilação com base nas definições de mapeamento que você especifica em interfaces anotadas com @Mapper. O objetivo 
principal do MapStruct é evitar a necessidade de escrever manualmente o código de mapeamento repetitivo e suscetível a erros, reduzindo a 
complexidade e o esforço envolvidos nesse processo.

Aqui estão os conceitos-chave e como você pode usar o MapStruct para realizar mapeamentos entre objetos:

Definindo Interfaces @Mapper:
Você cria interfaces Java anotadas com @Mapper para definir as regras de mapeamento entre os tipos de objetos. Essas interfaces podem conter 
métodos de mapeamento. O MapStruct gera automaticamente a implementação desses métodos com base nas configurações de mapeamento que você fornece.

Mapeamento Automático:
O MapStruct tenta mapear automaticamente os campos com nomes correspondentes e tipos compatíveis. Por exemplo, se você tiver um campo chamado 
nome em ambas as classes de origem e destino, o MapStruct mapeará automaticamente esses campos.

Configuração de Mapeamento Personalizado:
Em alguns casos, você pode precisar de mapeamento personalizado entre campos com nomes diferentes ou tipos incompatíveis. Você pode usar a 
anotação @Mapping para configurar o mapeamento personalizado. Isso permite que você especifique como os campos devem ser mapeados.

Injeção de Dependência (Spring Integration):
Com a configuração apropriada, o MapStruct pode gerar implementações que podem ser facilmente injetadas como beans gerenciados pelo Spring 
Framework. Isso é útil para obter benefícios do Spring, como gerenciamento de ciclo de vida e transações.

Processadores de Anotações:
O MapStruct utiliza processadores de anotações para gerar o código de mapeamento em tempo de compilação. Para usar o MapStruct, você precisa 
adicionar a dependência do MapStruct ao seu projeto e configurar a anotação @Mapper em suas interfaces de mapeamento.

 --------------- // ---------------

Instalação no Maven 
https://mapstruct.org/documentation/installation/

Vamos abordar a tag <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> que fica dentro da propriedade. Essa tag define o mapstruct e a 
versão (1.5.5.Final) a ser utilizada. 

A tag <org.mapstruct.version> é uma propriedade definida no arquivo pom.xml do projeto Maven. Ela é usada para armazenar a versão da biblioteca 
MapStruct que deseja usar em seu projeto. Ao definir essa propriedade, você pode facilmente atualizar a versão do MapStruct em um único lugar, o 
que torna mais conveniente e consistente o controle da versão da biblioteca em todo o projeto.

Detalhes sobre a tag <org.mapstruct.version>:

<org.mapstruct.version>: Isso indica o início da definição da propriedade. O nome da propriedade segue a convenção usual de utilizar a estrutura 
<groupId>.<artifactId>, substituindo os pontos por traços (-).

1.5.5.Final: Este é o valor atribuído à propriedade, que representa a versão específica do MapStruct que você deseja usar em seu projeto.

A tag <path> dentro da configuração do plugin Maven maven-compiler-plugin é usada para especificar os caminhos para os processadores de anotações 
que serão usados durante a compilação. No contexto do MapStruct, o processador de anotações é responsável por gerar automaticamente o código de 
mapeamento com base nas interfaces de mapeamento que você define.

Detalhes sobre os valores especificados dentro da tag <path>:

<groupId>org.mapstruct</groupId>: Este é o identificador de grupo (Group ID) da biblioteca MapStruct no repositório Maven. Ele identifica 
exclusivamente a organização ou projeto responsável pela biblioteca.

<artifactId>mapstruct-processor</artifactId>: Este é o identificador de artefato (Artifact ID) da biblioteca MapStruct no repositório Maven. Ele 
identifica o nome específico da biblioteca.

<version>${org.mapstruct.version}</version>: Esta é a versão do MapStruct que será usada como processador de anotações durante a compilação. O 
${org.mapstruct.version} é uma referência a uma propriedade definida no seu arquivo pom.xml para especificar a versão do MapStruct que  deseja 
usar.

A configuração da tag <path> informa ao Maven onde encontrar o processador de anotações do MapStruct. Quando o Maven executa o processo de 
compilação, ele identifica os processadores de anotações no caminho especificado e os aplica para gerar o código necessário.

No geral, essa configuração é crucial para garantir que o MapStruct funcione corretamente durante a compilação, gerando o código de mapeamento 
automaticamente com base nas interfaces definidas. 

--------------- // ---------------

Anotação `@Mapper` -> @Mapper(componentModel = "spring")

A anotação `@Mapper` com o parâmetro `componentModel = "spring"`. A anotação `@Mapper` faz parte da biblioteca MapStruct, que é uma ferramenta 
de geração automática de código usada para simplificar a implementação de mapeamentos entre objetos Java. A configuração 
`componentModel = "spring"` é uma das formas de integrar o MapStruct com o framework Spring.

Aqui estão os pontos principais sobre o uso dessa anotação:

1. **MapStruct Overview:**
   O MapStruct permite que você defina interfaces anotadas com `@Mapper` para definir os mapeamentos entre diferentes tipos de objetos. Em vez 
   de escrever manualmente o código de mapeamento, o MapStruct gera automaticamente o código de mapeamento eficiente em tempo de compilação.

2. **`@Mapper` Anotação:**
   A anotação `@Mapper` é colocada em uma interface que você cria para definir os métodos de mapeamento. Esses métodos de mapeamento devem ter a 
   assinatura apropriada, mapeando atributos de um objeto para outro. O MapStruct gera a implementação desses métodos.

3. **`componentModel = "spring"`:**
   O parâmetro `componentModel` na anotação `@Mapper` permite a integração direta com o Spring Framework. Quando definido como `spring`, 
   o MapStruct automaticamente cria uma implementação gerenciada pelo Spring para a interface anotada com `@Mapper`. Isso significa que você 
   pode injetar essa interface mapeadora onde for necessário no seu código Spring.

4. **Vantagens do Uso do Spring com o MapStruct:**
   - Injeção de dependência fácil: Como o MapStruct gera uma implementação gerenciada pelo Spring, você pode injetar essa implementação em outras 
     partes do seu código.
   - Uso natural de recursos do Spring, como transações e gerenciamento de ciclo de vida.

5. **Exemplo de Uso:**

Aqui está um exemplo qualquer que poderia usar a anotação `@Mapper` com `componentModel = "spring"`:

```
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface ProdutoMapper {
    @Mapping(target = "preco", source = "preço") // Exemplo de mapeamento personalizado
    ProdutoDTO produtoToProdutoDTO(Produto produto);
}
```

Neste exemplo, a interface `ProdutoMapper` usa a anotação `@Mapper` com `componentModel = "spring"`. O método `produtoToProdutoDTO` é responsável 
por mapear um objeto `Produto` para um objeto `ProdutoDTO`. A anotação `@Mapping` é usada para definir mapeamentos personalizados entre os 
atributos.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Em uma estrutura de projeto, o pacote "handler" geralmente é usado para agrupar classes que lidam com a manipulação de solicitações HTTP, 
especialmente aquelas que não se encaixam bem em um controlador tradicional. O uso de um pacote "handler" pode ajudar a organizar o código 
relacionado ao tratamento de solicitações específicas, além de manter os controladores mais focados nas operações principais da sua aplicação.

Aqui estão alguns cenários comuns em que um pacote "handler" pode ser usado:

1. **Tratamento de Erros Globais**: Você pode ter classes dentro do pacote "handler" que lidam com o tratamento de erros globais da aplicação. 
   Isso pode incluir a captura de exceções não tratadas e o envio de respostas de erro padronizadas.

2. **Integração com APIs Externas**: Se a sua aplicação se comunica com APIs externas, você pode criar classes no pacote "handler" para 
   encapsular a lógica de integração, como fazer chamadas HTTP, manipular respostas e lidar com erros.

3. **Autenticação e Autorização Personalizadas**: Se você precisa de lógica personalizada para autenticação e autorização, pode criar classes no 
   pacote "handler" para lidar com essas responsabilidades.

4. **Validação de Dados**: Se você tem validações de dados específicas que não se encaixam nas anotações de validação padrão do Spring, pode 
   criar classes no pacote "handler" para lidar com essa validação.

5. **Conversão de Formatos**: Se você precisa converter dados de um formato para outro, como manipular dados XML ou JSON, pode criar classes no 
   pacote "handler" para essa conversão.

6. **Tarefas Agendadas**: Se você tem tarefas agendadas que precisam ser executadas em intervalos específicos, pode criar classes no pacote 
   "handler" para lidar com essas tarefas.

Lembre-se de que não existe uma regra estrita para o que deve ser colocado em um pacote "handler". A nomenclatura e a organização do seu projeto 
podem variar com base nas melhores práticas adotadas pela sua equipe e nas necessidades específicas da aplicação. O objetivo é manter o código 
organizado e fácil de entender, agrupando funcionalidades relacionadas em pacotes lógicos.

--------------- // ---------------

Anotação `@ControllerAdvice`

A anotação `@ControllerAdvice` é uma anotação do Spring Framework que permite definir classes que fornecem tratamento global para exceções em 
toda a aplicação. Essas classes são conhecidas como "global exception handlers" (manipuladores globais de exceção) e têm a capacidade de 
centralizar a lógica de tratamento de exceções, evitando a duplicação de código em diversos pontos do código.

Aqui estão as principais funcionalidades e usos da anotação `@ControllerAdvice`:

1. **Tratamento Global de Exceções**: Ao anotar uma classe com `@ControllerAdvice`, você pode definir métodos que capturam exceções específicas 
   ou genéricas e fornecem um tratamento unificado para elas.

2. **Centralização de Lógica**: Com um "controller advice", você pode centralizar a lógica de tratamento de exceções em um único local. Isso 
   evita que você precise repetir o mesmo código de tratamento de exceções em vários controladores.

3. **Respostas Personalizadas de Erro**: Com `@ControllerAdvice`, você pode personalizar as respostas de erro, como definir códigos de status, 
   mensagens de erro e outros detalhes da resposta.

4. **Tratamento de Exceções de Validação**: Você pode usar `@ControllerAdvice` para lidar com exceções de validação, como as lançadas quando 
   dados inválidos são enviados para os controladores.

5. **Tratamento de Exceções de Formato**: Se a aplicação recebe dados em formatos diversos (JSON, XML, etc.), você pode usar `@ControllerAdvice` 
   para lidar com exceções de conversão e formatação.

6. **Integração com Exceções Personalizadas**: Você pode criar exceções personalizadas para cenários específicos da sua aplicação e definir 
   tratamento específico para essas exceções usando `@ControllerAdvice`.

--------------- // ---------------

A anotação @ExceptionHandler é uma anotação do Spring Framework que indica um método que deve ser invocado para lidar com uma exceção específica 
lançada durante a execução de um controlador. Essa anotação é comumente usada em conjunto com a anotação @ControllerAdvice para definir 
tratamentos globais de exceção ou tratamentos específicos para determinados controladores.

No contexto da anotação @ExceptionHandler(BadRequestException.class), o que acontece é:

 1. @ExceptionHandler: Indica que o método anotado é responsável por tratar uma exceção específica.

 2. (BadRequestException.class): Isso especifica qual exceção o método deve tratar. No exemplo, BadRequestException.class é uma classe de 
    exceção que representa uma situação em que ocorreu uma requisição inválida (código de status HTTP 400 Bad Request).

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação `@Transactional`

A anotação `@Transactional` é uma anotação usada no Spring Framework para controlar a transação de operações em um banco de dados. Ela define um 
escopo transacional para um método ou um conjunto de métodos, garantindo que essas operações sejam executadas de forma atômica, consistente, 
isolada e durável (princípios ACID de transações).

A anotação `@Transactional` pode ser aplicada a nível de classe ou método. Quando aplicada a nível de classe, ela se aplica a todos os métodos 
públicos da classe. Quando aplicada a nível de método, ela se aplica apenas ao método específico. Ela pode ser usada em controladores, serviços 
ou qualquer componente gerenciado pelo Spring.

Aqui estão algumas funcionalidades da anotação `@Transactional`:

1. **Atomicidade**: Todas as operações dentro do escopo transacional são tratadas como uma unidade atômica. Isso significa que todas as operações 
   são bem-sucedidas ou todas falham, evitando estados intermediários inconsistentes no banco de dados.

2. **Consistência**: A transação garante que o banco de dados esteja em um estado consistente antes e depois das operações.

3. **Isolamento**: A anotação permite controlar o nível de isolamento das transações, garantindo que as operações de uma transação não 
   interfiram nas operações de outras transações concorrentes.

4. **Durabilidade**: As alterações feitas dentro do escopo transacional são permanentes e persistem mesmo após um reinício do sistema.

Exemplo qualquer de uso:

```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
    }

    @Transactional(readOnly = true)
    public User getUserById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
```

No exemplo acima, a anotação `@Transactional` é usada nos métodos `createUser` e `getUserById` do serviço `UserService`. No método `createUser`, 
a anotação garante que a operação de salvamento no banco de dados seja tratada como uma única transação. No método `getUserById`, a anotação 
com o parâmetro `readOnly = true` define que a transação será somente para leitura, o que pode otimizar o desempenho quando não há necessidade 
de operações de gravação no banco de dados.

a anotação @Transactional pode ser usada em vários métodos da camada de serviço, incluindo os métodos de busca, atualização e exclusão. Ela 
ajuda a garantir a consistência das operações e a controlar o escopo da transação em torno dessas operações.

Além da propriedade readOnly, existem outras propriedades que podem ser usadas com a anotação @Transactional para controlar o comportamento da 
transação:

1. isolation: Define o nível de isolamento da transação. Você pode usar valores como:
   -> Isolation.DEFAULT - O nível de isolamento padrão definido pelo banco de dados ou pelo ambiente de execução. Isso geralmente equivale a 
                          Isolation.READ_COMMITTED.
   
   -> Isolation.READ_UNCOMMITTED - O nível mais baixo de isolamento. As transações podem ver alterações não confirmadas por outras transações. 
                                   Isso pode resultar em leituras sujas (dirty reads), onde as informações podem ser imprecisas.
    
   -> Isolation.READ_COMMITTED - As transações só podem ver dados confirmados por outras transações. Isso evita leituras sujas, mas ainda 
                                 permite o fenômeno de leituras não repetíveis.
                                 
   -> Isolation.REPEATABLE_READ - Garante que, uma vez que uma linha seja lida por uma transação, qualquer leitura subsequente da mesma linha 
                                  durante a mesma transação retornará o mesmo valor. Isso evita leituras não repetíveis, mas ainda permite o 
                                  fenômeno da leitura fantasma.
   
   -> Isolation.SERIALIZABLE - É o nível de isolamento mais alto. Garante que as transações ocorram como se fossem executadas uma após a outra, 
                               evitando leituras sujas, leituras não repetíveis e leituras fantasmas. No entanto, isso pode levar a um desempenho 
                               mais baixo devido ao bloqueio rigoroso.

 A escolha do nível de isolamento depende dos requisitos de consistência, desempenho e concorrência da sua aplicação. Níveis de isolamento mais 
 altos fornecem maior consistência, mas podem resultar em bloqueios e possivelmente em degradação de desempenho. Por outro lado, níveis de 
 isolamento mais baixos podem resultar em melhores desempenhos, mas podem introduzir inconsistências nos dados lidos.

2. propagation: Define a propagação da transação quando chamado a partir de outro método transacional. Valores possíveis incluem: 
   -> Propagation.REQUIRED - Esse é o valor padrão. Se um método transacional é chamado dentro de outro método que já está em uma transação, o 
                             método chamado participará da transação existente. Caso contrário, uma nova transação será criada. Isso significa 
                             que vários métodos dentro de uma mesma transação compartilham a mesma transação, e se a transação pai for revertida, 
                             todas as operações serão revertidas.
   
   -> Propagation.REQUIRES_NEW -  Esse valor garante que um novo contexto de transação seja criado para o método chamado, independentemente de 
                                  haver uma transação em andamento no método chamador. Isso cria uma transação separada para o método chamado, 
                                  isolando completamente suas operações da transação pai.
   
   -> Propagation.MANDATORY - Esse valor indica que o método deve ser chamado dentro de uma transação existente. Se não houver uma transação, 
                              uma exceção será lançada. Isso garante que um método só será executado dentro de uma transação existente.
   
   -> entre outros.

Exemplo qualquer de uso:

```
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
        updateUserStats();
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateUserStats() {
        // Atualizar estatísticas do usuário em uma nova transação independente
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public User getUserById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
```
 No exemplo acima, o método createUser chama o método updateUserStats com Propagation.REQUIRED, o que significa que ambos compartilham a mesma 
 transação. O método updateUserStats utiliza Propagation.REQUIRES_NEW, criando uma nova transação. O método getUserById usa Propagation.MANDATORY, 
 garantindo que ele seja chamado apenas dentro de uma transação existente.

3. timeout: Define o tempo limite da transação em segundos. A transação será revertida se o tempo limite for excedido.

4. rollbackFor e noRollbackFor: Define as exceções que devem ou não causar o rollback da transação.

5. rollbackForClassName e noRollbackForClassName: Versões por nome das propriedades acima.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

As anotações como `@NotEmpty`, `@NotNull`, `@Min`, `@Max`, `@Size`, entre outras, fazem parte da biblioteca de validação do Bean Validation, que 
é integrada ao Spring Boot através da dependência `spring-boot-starter-validation`. Essas anotações são usadas para validar os dados de entrada 
e garantir que atendam aos critérios definidos antes de serem processados pela aplicação. Aqui estão algumas das anotações mais comuns:

1. **`@NotNull`**: Essa anotação é usada para garantir que o valor do campo não seja nulo.

2. **`@NotEmpty`**: Essa anotação é usada para garantir que uma coleção, uma string ou um array não esteja vazio ou nulo.

3. **`@NotBlank`**: Semelhante ao `@NotEmpty`, mas também verifica se a string não consiste apenas em espaços em branco.

4. **`@Min`**: Essa anotação define o valor mínimo que um campo numérico pode ter.

5. **`@Max`**: Essa anotação define o valor máximo que um campo numérico pode ter.

6. **`@Size`**: Essa anotação define o tamanho mínimo e máximo de uma coleção, string ou array.

7. **`@Pattern`**: Essa anotação permite validar uma string usando uma expressão regular.

8. **`@Email`**: Essa anotação valida se uma string é um endereço de e-mail válido.

9. **`@Valid`**: Essa anotação é usada para indicar que uma propriedade deve ser validada recursivamente. Pode ser usada, por exemplo, para validar objetos aninhados.

Exemplo de uso das anotações:

```java
public class User {

    @NotNull
    @Size(min = 2, max = 50)
    private String name;

    @NotEmpty
    @Email
    private String email;

    @Min(18)
    private int age;

    // Getters e setters
}
```

Neste exemplo, a classe `User` possui campos anotados com `@NotNull`, `@Size`, `@NotEmpty`, `@Email` e `@Min`. Quando um objeto `User` é validado 
usando o Bean Validation, as restrições definidas por essas anotações serão aplicadas para garantir que os dados atendam aos critérios 
estabelecidos. Caso contrário, exceções de validação serão lançadas, informando que os dados não estão em conformidade com as regras definidas.

--------------- // ---------------

Anotação @Valid

A anotação @Valid é uma anotação do Bean Validation que é usada para indicar que um objeto aninhado deve ser validado. Essa anotação é frequentemente usada em campos que são objetos complexos ou coleções dentro de uma classe.

Quando você coloca a anotação @Valid em um campo, o mecanismo de validação do Bean Validation verifica se o objeto contido nesse campo está em 
conformidade com as regras de validação definidas para ele. Se o objeto não for válido, as restrições definidas pelas anotações no próprio objeto 
aninhado serão aplicadas, e as exceções de validação apropriadas serão lançadas.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @SuperBuilder

A anotação @SuperBuilder faz parte do projeto Lombok, que é uma biblioteca do Java que ajuda a reduzir a quantidade de código boilerplate, como 
getters, setters, construtores e outros métodos repetitivos, tornando o código mais conciso e legível.

A anotação @SuperBuilder é usada para criar construtores fluentes em classes que herdam de outras classes. Ela é particularmente útil quando 
você está trabalhando com herança e deseja que as subclasses tenham construtores com a mesma funcionalidade da classe pai.

O uso de @SuperBuilder economiza muito código e torna mais fácil criar objetos complexos com herança. É importante notar que você precisará 
configurar o Lombok corretamente em seu projeto para usar essa anotação.

--------------- // ---------------

Anotação @Getter

A anotação @Getter faz parte do projeto Lombok, que é uma biblioteca Java que ajuda a reduzir a verbosidade do código, eliminando a necessidade 
de escrever métodos getters manualmente. Ela é usada para gerar automaticamente métodos getter para os campos (atributos) de uma classe.

A anotação @Getter é uma maneira eficiente de criar métodos getter em suas classes, economizando tempo e reduzindo a quantidade de código que 
você precisa escrever manualmente. Isso também ajuda a manter seu código mais limpo e legível.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A classe ResponseEntityExceptionHandler faz parte do framework Spring e é projetada para lidar com exceções globais em um aplicativo Spring 
Boot que produz respostas HTTP. Ela é uma classe abstrata que estende ResponseEntityExceptionHandler e fornece métodos para tratar várias 
exceções comuns, como erros de validação, exceções de servidor interno, exceções de método não suportado e muito mais.

A principal finalidade da ResponseEntityExceptionHandler é capturar exceções lançadas em seu aplicativo e transformá-las em respostas HTTP 
adequadas, que geralmente têm um formato JSON ou XML para serem consumidos por clientes da API.

Você pode personalizar o tratamento de exceções de acordo com as necessidades do seu aplicativo, adicionando métodos adicionais anotados com 
@ExceptionHandler para lidar com tipos de exceções específicos.

Em resumo, ResponseEntityExceptionHandler é uma classe útil para lidar com exceções globalmente em seu aplicativo Spring Boot e personalizar as 
respostas HTTP retornadas em caso de erros. Ela é amplamente usada para padronizar o tratamento de exceções em APIs RESTful.

Alguns dos métodos mais comuns fornecidos pela classe `ResponseEntityExceptionHandler` que são frequentemente utilizados para lidar com exceções 
em um aplicativo Spring Boot:

1. `handleExceptionInternal`: Este método é usado para lidar com exceções gerais e pode ser personalizado para gerar uma resposta HTTP 
    personalizada. É frequentemente usado para lidar com exceções não tratadas.

2. `handleMethodArgumentNotValid`: Este método lida com exceções relacionadas à validação de argumentos de métodos, geralmente lançadas quando 
    os dados de entrada não estão em conformidade com as regras de validação definidas. Ele pode ser usado em conjunto com anotações de 
    validação, como `@Valid`.

3. `handleHttpRequestMethodNotSupported`: Este método lida com exceções lançadas quando um método HTTP não é suportado em um endpoint específico. 
    Por exemplo, ao tentar acessar um endpoint com um método HTTP que não é permitido, como POST em um endpoint que só permite GET.

4. `handleHttpMediaTypeNotSupported`: Este método lida com exceções relacionadas à falta de suporte ao tipo de mídia (por exemplo, JSON, XML) 
    solicitado pelo cliente.

5. `handleHttpMediaTypeNotAcceptable`: Este método lida com exceções lançadas quando o servidor não pode produzir uma resposta no formato de 
    mídia aceitável pelo cliente.

6. `handleMissingPathVariable`: Lidar com exceções lançadas quando um caminho da URL esperado não é encontrado.

7. `handleNoHandlerFoundException`: Este método lida com exceções quando nenhum manipulador (controlador) é encontrado para a solicitação do 
    cliente.

8. `handleTypeMismatch`: Este método lida com exceções lançadas quando um valor do parâmetro não pode ser convertido para o tipo esperado.

9. `handleDataIntegrityViolation`: Usado para tratar exceções relacionadas à integridade dos dados, geralmente lançadas quando há violações de 
    restrições de chave primária ou chave única.

Estes são apenas alguns dos métodos disponíveis na classe `ResponseEntityExceptionHandler`. Você pode criar métodos personalizados adicionais 
para lidar com exceções específicas de seu aplicativo. Além disso, você pode personalizar as respostas HTTP retornadas para cada tipo de exceção, 
definindo um objeto `ResponseEntity` personalizado com o status HTTP e o corpo desejados.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Classes `Page` e `Pageable` no contexto de aplicativos Spring Data e Spring Boot:

1. **`Page`**:
   - A classe `Page` é uma parte do framework Spring Data e é usada para representar uma página de resultados de consulta em uma lista paginada 
     de elementos.
   - Ela encapsula uma lista de elementos de dados junto com informações sobre a página, como número total de páginas, número total de elementos, 
     tamanho da página e outros detalhes relacionados à paginação.
   - É frequentemente usada quando você deseja dividir grandes conjuntos de dados em partes menores para melhorar a eficiência e a usabilidade 
     de seu aplicativo.
   - O Spring Data geralmente retorna objetos `Page` como resultado de consultas que envolvem a paginação, permitindo fácil navegação pelos 
     resultados.

2. **`Pageable`**:
   - A interface `Pageable` é usada para representar informações sobre a paginação, como número da página, tamanho da página, ordenação e outros 
     detalhes relacionados à recuperação de resultados paginados.
   - Ela define métodos para acessar e configurar essas informações, permitindo que você especifique qual página de resultados deseja recuperar, 
     qual é o tamanho da página e como os resultados devem ser ordenados.
   - No Spring Data, você geralmente cria objetos `Pageable` e os passa como argumentos para métodos de consulta que suportam a paginação. Dessa 
     forma, você pode personalizar a consulta para retornar a página desejada.

Em resumo, `Page` é usada para encapsular uma página de resultados paginados, enquanto `Pageable` é usada para configurar os detalhes da 
paginação, como número da página, tamanho da página e ordenação. Essas classes são muito úteis ao lidar com grandes volumes de dados e ao criar 
consultas paginadas em aplicativos Spring Data.

O Page<Anime> é usado para representar um conjunto paginado de objetos do tipo Anime. Isso pode ser útil ao consultar grandes conjuntos de dados 
em um banco de dados e dividir os resultados em páginas para melhorar o desempenho e a usabilidade de um aplicativo.

A classe Page geralmente oferece métodos para navegar pelas páginas, acessar informações sobre a página atual, como número total de páginas, 
tamanho da página, número total de elementos, etc. Isso permite a criação de recursos de paginação em APIs ou interfaces de usuário, onde os 
resultados são exibidos em partes gerenciáveis.

--------------- // ---------------

Acessando no Postman:

Usando paginação (define qtd de páginas) - listar todos os animes
http://localhost:8080/animes?size=5

Usando paginação (define a página acessada) - listar todos os animes
http://localhost:8080/animes?size=5&page=3

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Configuration

A anotação `@Configuration` é uma das anotações fundamentais do Spring Framework e é usada para indicar que uma classe é uma classe de 
configuração. Ela desempenha um papel crucial na configuração de aplicativos Spring e na definição de beans gerenciados pelo Spring Container.

Aqui estão os principais pontos sobre a anotação `@Configuration`:

1. **O Que Faz**: A anotação `@Configuration` é usada para identificar classes que definem configurações para o aplicativo. Essas configurações 
   podem incluir definições de beans, configurações de componentes e outras configurações relacionadas ao Spring.

2. **Classes de Configuração**: As classes anotadas com `@Configuration` geralmente contêm métodos anotados com `@Bean`. Esses métodos definem 
   os beans gerenciados pelo Spring e suas configurações.

3. **Beans Gerenciados**: Os métodos anotados com `@Bean` dentro de uma classe `@Configuration` são interpretados pelo Spring como instruções 
   para criar beans gerenciados. Esses beans são inicializados e configurados pelo Spring Container e podem ser injetados em outras partes do 
   aplicativo.

4. **Substituição para XML**: A anotação `@Configuration` é frequentemente usada como uma alternativa ao uso de configurações XML para definir 
   beans. Ela oferece uma abordagem mais programática e baseada em código para a configuração do aplicativo.

5. **Escopo Singleton por Padrão**: Os beans definidos em classes anotadas com `@Configuration` têm escopo singleton por padrão. Isso significa 
   que o Spring Container cria apenas uma instância do bean e a reutiliza sempre que o bean é injetado em outras partes do aplicativo.

6. **Component Scanning**: Classes anotadas com `@Configuration` também podem ser detectadas automaticamente pelo mecanismo de varredura de 
   componentes do Spring, tornando-as elegíveis para uso como configurações.

Em resumo, a anotação `@Configuration` é uma parte fundamental da configuração baseada em Java no Spring Framework e desempenha um papel 
importante na definição e configuração de beans gerenciados pelo Spring. Ela permite que você configure seu aplicativo de forma programática, 
facilitando a organização e a manutenção do código de configuração.

--------------- // ---------------

Interface `WebMvcConfigurer`

A interface `WebMvcConfigurer` é uma parte importante do Spring Framework e é usada para configurar vários aspectos do mecanismo Spring MVC 
(Model-View-Controller) em um aplicativo web. Ela permite personalizar e ajustar o comportamento padrão do Spring MVC de acordo com as 
necessidades do seu aplicativo.

Principais funcionalidades que você pode realizar ao implementar a interface `WebMvcConfigurer`:

1. **Configuração de Controladores**: Você pode adicionar seus próprios controladores personalizados, bem como configurar controladores padrão 
   do Spring MVC.

2. **Configuração de Visualizações**: É possível definir como as visualizações são resolvidas e configurar visualizações personalizadas.

3. **Interceptadores**: Você pode adicionar interceptadores para executar código antes e depois do processamento da solicitação pelo controlador.

4. **Recursos Estáticos**: É possível configurar o tratamento de recursos estáticos, como arquivos CSS, JavaScript e imagens.

5. **Conversores e Formatadores**: Você pode registrar conversores e formatadores personalizados para mapear dados de solicitação para objetos 
   Java e vice-versa.

6. **Validação**: Você pode configurar validação personalizada para objetos de formulário.

7. **Gerenciamento de Recursos**: É possível configurar o local de armazenamento de recursos, como arquivos de upload.

8. **Configuração de Content Negotiation**: Definir regras para a negociação de conteúdo com base no cabeçalho `Accept` da solicitação.

9. **Configuração de Mapeamento de URLs**: Personalizar o mapeamento de URLs para controladores e recursos.

10. **Tratamento de Exceções**: Configurar como as exceções são tratadas e personalizar páginas de erro.

11. **Configuração do Local**: Definir o local e a codificação padrão para seu aplicativo.

Para implementar a interface `WebMvcConfigurer`, você geralmente cria uma classe de configuração que estende `WebMvcConfigurerAdapter` 
(desde o Spring 5, você pode implementar diretamente `WebMvcConfigurer`). Em seguida, você sobrescreve os métodos apropriados para personalizar 
o comportamento do Spring MVC.

Aqui está um exemplo simples de uma classe que implementa `WebMvcConfigurer` para configurar um interceptor:

```java
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor());
    }
}
```

Neste exemplo, a classe `MyWebMvcConfig` é anotada com `@Configuration` e implementa `WebMvcConfigurer`. Ela sobrescreve o método 
`addInterceptors` para adicionar um interceptor personalizado.

Em resumo, a interface `WebMvcConfigurer` fornece uma maneira flexível de personalizar o comportamento do Spring MVC em um aplicativo web. Ela 
permite que você adapte o Spring MVC para atender às necessidades específicas do seu projeto, tornando-o uma ferramenta poderosa para configurar 
a camada de controle de um aplicativo web Spring.

--------------- // ---------------

O método `addArgumentResolvers` faz parte da interface `WebMvcConfigurer` e é usado para configurar os resolutores de argumentos personalizados 
que serão usados pelo Spring MVC ao lidar com solicitações HTTP.

Em um controlador Spring MVC, os métodos podem receber argumentos que representam partes da solicitação HTTP, como parâmetros da URL, cabeçalhos 
HTTP, corpo da solicitação e muito mais. O Spring MVC usa resolutores de argumentos para converter esses componentes da solicitação em objetos 
que podem ser passados como argumentos para os métodos do controlador.

O método `addArgumentResolvers` permite que você registre resolutores de argumentos personalizados para que o Spring MVC possa usá-los ao 
processar solicitações HTTP. Isso é útil quando você deseja estender o comportamento padrão do Spring MVC para lidar com tipos de argumento 
personalizados ou quando precisa realizar alguma lógica especial durante a resolução de argumentos.

Você pode criar resolutores de argumentos personalizados para atender às necessidades específicas do seu aplicativo. Por exemplo, você pode 
criar um resolutor de argumentos que converte um cabeçalho HTTP personalizado em um objeto Java específico ou realiza alguma validação 
personalizada durante a resolução de argumentos.

Em resumo, o método `addArgumentResolvers` é usado para configurar resolutores de argumentos personalizados no Spring MVC, permitindo que você 
estenda e personalize o processamento de solicitações HTTP nos controladores.