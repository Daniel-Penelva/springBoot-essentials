public Anime findById(Long id ) {
		return   animes.stream()
				.filter(anime -> anime.getId().equals(id))
				.findFirst().orElseThrow(()-> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found"));
}


Este script é um método em Java que recebe um ID como parâmetro e busca por um objeto Anime em uma lista de animes usando programação funcional 
com Stream.

Vamos analisar o código por partes:

   public Anime findById(Long id): Esta é a declaração do método público chamado findById que retorna um objeto do tipo Anime. Ele aceita um 
   parâmetro id do tipo Long.

   return animes.stream(): Aqui, é criado um fluxo (stream) a partir da lista de animes chamada animes. Um fluxo é uma sequência de elementos 
   que pode ser processada de maneira sequencial ou paralela.

   .filter(anime -> anime.getId().equals(id)): O método filter é usado para filtrar elementos do fluxo com base em uma condição. Neste caso, 
   está filtrando os animes cujo ID seja igual ao ID passado como parâmetro.

   .findFirst(): O método findFirst retorna o primeiro elemento do fluxo que satisfaça a condição definida no filtro. Neste caso, retorna o 
   primeiro anime com o ID correspondente.

   .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found")): O método orElseThrow é usado para retornar o valor 
   presente no fluxo, caso exista. Se o fluxo estiver vazio (nenhum anime corresponde ao ID), uma exceção é lançada. No caso, uma 
   ResponseStatusException com um status HTTP BAD_REQUEST (código 400) é lançada, indicando que o anime não foi encontrado.

Portanto, esse método busca por um anime na lista de animes pelo ID usando programação funcional com Stream. Se o anime for encontrado, ele é 
retornado. Caso contrário, uma exceção é lançada indicando que o anime não foi encontrado.

É importante notar que o código pressupõe a existência de uma lista de animes chamada animes que contém os objetos Anime a serem pesquisados. 
Além disso, a classe Anime deve ter um método getId() para acessar o ID do anime. A exceção ResponseStatusException é lançada com base no 
framework Spring Web para lidar com respostas HTTP em APIs.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A propriedade `server.error.include-stacktrace` é uma configuração que pode ser usada em aplicações Spring Boot para controlar se as informações 
de rastreamento de pilha (stack trace) são incluídas nas respostas de erro HTTP retornadas pela aplicação em caso de exceções.

Os valores possíveis para a propriedade `server.error.include-stacktrace` são:

1. `on-param` (valor padrão):
   - Isso significa que o rastreamento de pilha é incluído na resposta somente se um parâmetro de consulta chamado `trace` estiver presente na 
     solicitação HTTP. Isso permite que você escolha se deseja ou não incluir o rastreamento de pilha nas respostas de erro, controlando-o 
     através da presença ou ausência do parâmetro de consulta.

2. `always`:
   - Isso faz com que o rastreamento de pilha seja sempre incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta específico. Isso pode ser útil para depuração e diagnóstico de problemas.

3. `never`:
   - Isso faz com que o rastreamento de pilha nunca seja incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta. Essa opção pode ser usada para ocultar informações sensíveis ou internas da aplicação nos erros retornados aos usuários.

Essa propriedade é útil para controlar o nível de detalhes das mensagens de erro retornadas pelas APIs e pode ser configurada no arquivo 
`application.properties` ou `application.yml` da sua aplicação Spring Boot. Ela pode ajudar a equilibrar a necessidade de informações detalhadas 
para depuração com a segurança e a privacidade das informações do aplicativo.

Exemplo de configuração no `application.properties`:

```properties
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server.error.include-stacktrace=on-param
```

Exemplo de configuração no `application.yml`:

```yaml
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server:
  error:
    include-stacktrace: on-param
```

Lembre-se de que essa configuração afeta a maneira como as respostas de erro são geradas e retornadas pela sua aplicação Spring Boot.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A anotação @RequestBody é uma anotação fornecida pelo Spring Framework em aplicações Spring MVC e Spring WebFlux. Ela é usada para indicar que um 
parâmetro de método em um controlador deve ser vinculado ao corpo (body) da solicitação HTTP recebida. Essa anotação é frequentemente usada ao 
criar endpoints de API que recebem dados em formato JSON ou outros formatos no corpo da solicitação.

Quando você adiciona a anotação @RequestBody a um parâmetro de método, o Spring Framework assume que os dados no corpo da solicitação HTTP devem 
ser convertidos automaticamente para o tipo do parâmetro, geralmente um objeto Java.

A anotação @RequestBody é frequentemente usada em conjunto com outros métodos do Spring Framework, como @PostMapping, @PutMapping e outros, para 
criar endpoints de API que aceitam dados no corpo da solicitação. Isso é especialmente útil em cenários de criação, atualização ou envio de 
informações em APIs RESTful.

Lembre-se de que o Spring Framework usa a biblioteca Jackson para realizar a desserialização automática de JSON para objetos Java. Portanto, é 
importante ter as dependências do Jackson configuradas em seu projeto para que a anotação @RequestBody funcione corretamente.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeService: 

```
anime.setId(ThreadLocalRandom.current().nextLong(3, 100));
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeController: 

```
return new ResponseEntity<>(HttpStatus.NO_CONTENT);
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

O HttpStatus.NO_CONTENT é um valor enumerado (enum) da classe HttpStatus fornecida pelo Spring Framework. Ele representa o status HTTP 204 
No _Content, que é uma resposta padrão usada em APIs RESTful para indicar que uma solicitação foi processada com sucesso, mas não há conteúdo 
para retornar na resposta.

Quando uma solicitação é tratada com sucesso e o servidor não precisa enviar nenhum conteúdo de volta ao cliente, o status HTTP 204 
No_ Content é usado. Isso é comum em casos onde uma solicitação de exclusão, atualização ou outra ação bem-sucedida é processada, mas 
não há necessidade de enviar um corpo de resposta.

Em termos simples, o HttpStatus.NO_CONTENT é usado para indicar que a solicitação foi bem-sucedida e não há conteúdo adicional a ser 
enviado no corpo da resposta. Isso economiza largura de banda e melhora a eficiência da comunicação entre o cliente e o servidor.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vou explicar cada parte do seu arquivo `docker-compose.yml`:

1. `version: '3.1'`: Isso define a versão da especificação do Docker Compose que você está usando. No seu caso, está usando a versão 3.1. Cada 
    versão traz diferentes recursos e sintaxe.

2. `services`: Essa seção define os serviços (ou contêineres) que você deseja executar.

   - `db`: Este é o nome do serviço. Você o nomeou como "db", que é um nome comum para um serviço de banco de dados.
   
      - `image: mysql`: Especifica a imagem do Docker que você deseja usar para esse serviço. Neste caso, está usando a imagem oficial do MySQL 
         disponível no Docker Hub.
      
      - `container_name: mysql`: Isso define o nome do contêiner que será criado. Neste caso, está definindo o nome como "mysql".
      
      - `environment`: Define variáveis ​​de ambiente para o contêiner MySQL. No caso, está definindo a senha do root do MySQL como "root".
      
      - `ports`: Especifica a mapeamento de portas entre o host e o contêiner. Aqui, você está mapeando a porta 3306 do host para a porta 3306 
         do contêiner MySQL. Isso permite que você acesse o MySQL no contêiner por meio da porta 3306 no seu computador local.
      
      - `volumes`: Define os volumes que serão montados no contêiner. Está criando um volume chamado "devdojo_data" e montando-o na pasta 
        `/var/lib/mysql` dentro do contêiner MySQL. Isso é útil para armazenar os dados do banco de dados de forma persistente, mesmo que o 
        contêiner seja destruído.
   
3. `volumes`: Esta seção define os volumes que serão usados ​​pelos serviços.

   - `devdojo_data`: Este é o nome do volume. Está definindo um volume chamado "devdojo_data", que será usado para armazenar os dados do MySQL.

Dessa forma, o Docker Compose irá criar um contêiner MySQL usando a imagem oficial do MySQL, definindo a senha do root como "root", mapeando a 
porta 3306 do host para a porta 3306 do contêiner e criando um volume chamado "devdojo_data" para armazenar os dados do MySQL de forma 
persistente. O nome do contêiner será "mysql". Isso é útil para o desenvolvimento de aplicativos que usam o MySQL, pois permite que você tenha 
um banco de dados isolado e persistente em um contêiner.

--------------- // ---------------
IMPORTANTE!!!

 -> CTRL + C ou docker-compose stop: Para parar a execução do container do docker
 -> docker-compose up: Cria e inicia os containers definidos no arquivo docker-compose.yml.
 -> docker-compose down: Para e remove os containers definidos no arquivo docker-compose.yml.
 -> docker-compose ps: Lista os containers gerenciados pelo Docker Compose.
 -> docker-compose logs: Exibe os logs dos containers gerenciados pelo Docker Compose.
 -> docker-compose build: Constrói os serviços definidos no arquivo docker-compose.yml.
 -> docker-compose start: Inicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose stop: Para os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose restart: Reinicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker ps: Lista os conatiners que estão sendo executados no momento no docker.
 -> docker ps: Lista os containers em execução no momento.
 -> docker ps -a: Lista todos os containers, incluindo os que estão parados.

 --------------- // ---------------

Explicando cada parte desse script de configuração:

```
server:
  error:
    include-stacktrace: on-param

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
```

Este é um arquivo de configuração YAML que define várias configurações para um aplicativo Spring Boot que se conecta a um banco de dados MySQL. 
Vou explicar cada seção:

1. `server:`: Esta seção permite configurar algumas propriedades do servidor embutido do Spring Boot.

   - `error:`: Aqui, está configurando o tratamento de erros. `include-stacktrace: on-param` significa que as mensagens de erro incluirão 
     informações de rastreamento de pilha (stack trace) quando você passar um parâmetro de consulta chamado `on-param`.

2. `spring:`: Esta é a seção principal de configuração relacionada ao Spring Boot.

   - `datasource:`: Aqui, está configurando o DataSource, que é usado para se conectar ao banco de dados.

     - `url`: Esta é a URL de conexão JDBC para o banco de dados MySQL. O `jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true` 
        indica que o banco de dados está localizado em `localhost` na porta `3306`. O `anime` é o nome do banco de dados. Os parâmetros 
        `useSSL=false` e `createDatabaseIfNotExists=true` configuram a conexão para não usar SSL (útil em ambientes de desenvolvimento) e para 
        criar o banco de dados automaticamente se ele não existir.

     - `username`: Define o nome de usuário para autenticação no banco de dados. Aqui, é definido como "root".

     - `password`: Define a senha para autenticação no banco de dados. Aqui, é definido como "root".

   - `jpa:`: Esta é a seção de configuração relacionada à JPA (Java Persistence API), que é usada para trabalhar com persistência de dados em Java.

     - `hibernate:`: Configurações específicas do Hibernate, que é a implementação JPA padrão do Spring Boot.

       - `ddl-auto`: Essa propriedade controla como o Hibernate gerencia o esquema do banco de dados. No valor "update", o Hibernate tentará 
          atualizar automaticamente o esquema do banco de dados com base nas mudanças nas entidades (classes de modelo) do seu aplicativo. Isso 
          é útil durante o desenvolvimento, pois permite que você faça alterações nas suas entidades sem precisar recriar manualmente as tabelas 
          no banco de dados.

Em resumo, esse arquivo de configuração define como o Spring Boot se conectará a um banco de dados MySQL, configurações do Hibernate para 
atualização automática do esquema e algumas configurações de tratamento de erros. Certifique-se de substituir os valores de `username` e 
`password` por valores seguros e adequados para seu ambiente de desenvolvimento ou produção.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos Criar uma Classe DTO AnimePostRequestBody, uma classe DTO (Data Transfer Object) é um padrão de projeto usado no desenvolvimento de 
software para transferir dados entre diferentes partes de um sistema. Ela é uma classe simples que contém campos para armazenar dados e pode
incluir métodos para acessar e manipular esses dados. O principal objetivo de uma classe DTO é encapsular os dados e permitir sua transferência 
eficiente entre diferentes componentes de um sistema, muitas vezes em cenários onde a estrutura dos dados entre esses componentes é diferente.

Os DTOs são frequentemente usados em aplicações que seguem uma arquitetura em camadas, como as aplicações baseadas em microservices, onde 
diferentes partes do sistema podem ter diferentes necessidades de dados e formatos de representação. Eles ajudam a evitar o vazamento de 
abstrações de dados e a reduzir o acoplamento entre as camadas.

Algumas razões pelas quais você pode querer usar DTOs incluem:

1. **Redução de tráfego de rede**: Quando você precisa transferir dados entre um cliente e um servidor, ou entre microservices, pode ser mais 
   eficiente transferir apenas os dados necessários para a operação em vez de todos os campos de uma entidade completa.

2. **Mapeamento entre objetos**: Em um sistema, você pode ter diferentes representações de um objeto para diferentes partes da aplicação 
   (por exemplo, uma representação completa para exibição na interface do usuário e uma representação resumida para APIs). DTOs ajudam a mapear 
   essas diferentes representações.

3. **Segurança**: Em certos casos, você pode querer ocultar certos campos sensíveis ou confidenciais de uma entidade ao transferir dados. DTOs 
   permitem que você selecione apenas os campos necessários para transferência.

4. **Evolução do sistema**: DTOs também permitem que você evolua diferentes partes do sistema independentemente umas das outras. Se a estrutura 
   interna de uma entidade mudar, você pode ajustar apenas o mapeamento entre a entidade e seus DTOs correspondentes, sem afetar a camada que 
   consome esses DTOs.

5. **Aumento de performance**: Em algumas situações, especialmente quando você lida com grandes volumes de dados, o uso de DTOs específicos para 
   as operações pode melhorar a performance, reduzindo a quantidade de dados transferidos e simplificando o processamento.

Lembre-se de que a criação de DTOs adiciona alguma complexidade ao código, pois você terá que gerenciar o mapeamento entre as entidades do 
domínio e os DTOs. Portanto, é importante considerar cuidadosamente se o uso de DTOs é apropriado para o seu caso de uso.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Builder

A anotação `@Builder` é uma anotação do projeto Lombok, uma biblioteca popular para reduzir a verbosidade do código em Java. A anotação `@Builder` 
é usada para gerar automaticamente um padrão de criação de objetos imutáveis usando o padrão Builder. Ela é frequentemente usada em conjunto com 
outras anotações do Lombok, como `@Data` ou `@Value`.

Quando você anota uma classe com `@Builder`, o Lombok cria automaticamente um padrão de construção fluent para a classe, permitindo que você 
crie instâncias dessa classe com mais facilidade e clareza.

Aqui está um exemplo simples de como você usaria a anotação `@Builder`:

```
import lombok.Builder;

@Builder
public class Person {
    private String firstName;
    private String lastName;
    private int age;
}
```

Com essa anotação, o Lombok automaticamente cria um construtor privado na classe `Person` e uma classe interna chamada `PersonBuilder`. Isso 
permite que você crie instâncias de `Person` usando um padrão fluente, como este:

```
Person person = Person.builder()
    .firstName("John")
    .lastName("Doe")
    .age(30)
    .build();
```

Isso ajuda a melhorar a legibilidade do código ao criar objetos com muitos campos, eliminando a necessidade de criar diversos construtores ou 
utilizar construtores telescópicos (com muitos parâmetros) que podem se tornar difíceis de entender.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Framework de Mapeamento MapStruct

O MapStruct é uma biblioteca que simplifica o processo de mapeamento entre objetos Java. Ele gera automaticamente o código de mapeamento 
eficiente em tempo de compilação com base nas definições de mapeamento que você especifica em interfaces anotadas com @Mapper. O objetivo 
principal do MapStruct é evitar a necessidade de escrever manualmente o código de mapeamento repetitivo e suscetível a erros, reduzindo a 
complexidade e o esforço envolvidos nesse processo.

Aqui estão os conceitos-chave e como você pode usar o MapStruct para realizar mapeamentos entre objetos:

Definindo Interfaces @Mapper:
Você cria interfaces Java anotadas com @Mapper para definir as regras de mapeamento entre os tipos de objetos. Essas interfaces podem conter 
métodos de mapeamento. O MapStruct gera automaticamente a implementação desses métodos com base nas configurações de mapeamento que você fornece.

Mapeamento Automático:
O MapStruct tenta mapear automaticamente os campos com nomes correspondentes e tipos compatíveis. Por exemplo, se você tiver um campo chamado 
nome em ambas as classes de origem e destino, o MapStruct mapeará automaticamente esses campos.

Configuração de Mapeamento Personalizado:
Em alguns casos, você pode precisar de mapeamento personalizado entre campos com nomes diferentes ou tipos incompatíveis. Você pode usar a 
anotação @Mapping para configurar o mapeamento personalizado. Isso permite que você especifique como os campos devem ser mapeados.

Injeção de Dependência (Spring Integration):
Com a configuração apropriada, o MapStruct pode gerar implementações que podem ser facilmente injetadas como beans gerenciados pelo Spring 
Framework. Isso é útil para obter benefícios do Spring, como gerenciamento de ciclo de vida e transações.

Processadores de Anotações:
O MapStruct utiliza processadores de anotações para gerar o código de mapeamento em tempo de compilação. Para usar o MapStruct, você precisa 
adicionar a dependência do MapStruct ao seu projeto e configurar a anotação @Mapper em suas interfaces de mapeamento.

 --------------- // ---------------

Instalação no Maven 
https://mapstruct.org/documentation/installation/

Vamos abordar a tag <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> que fica dentro da propriedade. Essa tag define o mapstruct e a 
versão (1.5.5.Final) a ser utilizada. 

A tag <org.mapstruct.version> é uma propriedade definida no arquivo pom.xml do projeto Maven. Ela é usada para armazenar a versão da biblioteca 
MapStruct que deseja usar em seu projeto. Ao definir essa propriedade, você pode facilmente atualizar a versão do MapStruct em um único lugar, o 
que torna mais conveniente e consistente o controle da versão da biblioteca em todo o projeto.

Detalhes sobre a tag <org.mapstruct.version>:

<org.mapstruct.version>: Isso indica o início da definição da propriedade. O nome da propriedade segue a convenção usual de utilizar a estrutura 
<groupId>.<artifactId>, substituindo os pontos por traços (-).

1.5.5.Final: Este é o valor atribuído à propriedade, que representa a versão específica do MapStruct que você deseja usar em seu projeto.

A tag <path> dentro da configuração do plugin Maven maven-compiler-plugin é usada para especificar os caminhos para os processadores de anotações 
que serão usados durante a compilação. No contexto do MapStruct, o processador de anotações é responsável por gerar automaticamente o código de 
mapeamento com base nas interfaces de mapeamento que você define.

Detalhes sobre os valores especificados dentro da tag <path>:

<groupId>org.mapstruct</groupId>: Este é o identificador de grupo (Group ID) da biblioteca MapStruct no repositório Maven. Ele identifica 
exclusivamente a organização ou projeto responsável pela biblioteca.

<artifactId>mapstruct-processor</artifactId>: Este é o identificador de artefato (Artifact ID) da biblioteca MapStruct no repositório Maven. Ele 
identifica o nome específico da biblioteca.

<version>${org.mapstruct.version}</version>: Esta é a versão do MapStruct que será usada como processador de anotações durante a compilação. O 
${org.mapstruct.version} é uma referência a uma propriedade definida no seu arquivo pom.xml para especificar a versão do MapStruct que  deseja 
usar.

A configuração da tag <path> informa ao Maven onde encontrar o processador de anotações do MapStruct. Quando o Maven executa o processo de 
compilação, ele identifica os processadores de anotações no caminho especificado e os aplica para gerar o código necessário.

No geral, essa configuração é crucial para garantir que o MapStruct funcione corretamente durante a compilação, gerando o código de mapeamento 
automaticamente com base nas interfaces definidas. 

--------------- // ---------------

Anotação `@Mapper` -> @Mapper(componentModel = "spring")

A anotação `@Mapper` com o parâmetro `componentModel = "spring"`. A anotação `@Mapper` faz parte da biblioteca MapStruct, que é uma ferramenta 
de geração automática de código usada para simplificar a implementação de mapeamentos entre objetos Java. A configuração 
`componentModel = "spring"` é uma das formas de integrar o MapStruct com o framework Spring.

Aqui estão os pontos principais sobre o uso dessa anotação:

1. **MapStruct Overview:**
   O MapStruct permite que você defina interfaces anotadas com `@Mapper` para definir os mapeamentos entre diferentes tipos de objetos. Em vez 
   de escrever manualmente o código de mapeamento, o MapStruct gera automaticamente o código de mapeamento eficiente em tempo de compilação.

2. **`@Mapper` Anotação:**
   A anotação `@Mapper` é colocada em uma interface que você cria para definir os métodos de mapeamento. Esses métodos de mapeamento devem ter a 
   assinatura apropriada, mapeando atributos de um objeto para outro. O MapStruct gera a implementação desses métodos.

3. **`componentModel = "spring"`:**
   O parâmetro `componentModel` na anotação `@Mapper` permite a integração direta com o Spring Framework. Quando definido como `spring`, 
   o MapStruct automaticamente cria uma implementação gerenciada pelo Spring para a interface anotada com `@Mapper`. Isso significa que você 
   pode injetar essa interface mapeadora onde for necessário no seu código Spring.

4. **Vantagens do Uso do Spring com o MapStruct:**
   - Injeção de dependência fácil: Como o MapStruct gera uma implementação gerenciada pelo Spring, você pode injetar essa implementação em outras 
     partes do seu código.
   - Uso natural de recursos do Spring, como transações e gerenciamento de ciclo de vida.

5. **Exemplo de Uso:**

Aqui está um exemplo qualquer que poderia usar a anotação `@Mapper` com `componentModel = "spring"`:

```
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface ProdutoMapper {
    @Mapping(target = "preco", source = "preço") // Exemplo de mapeamento personalizado
    ProdutoDTO produtoToProdutoDTO(Produto produto);
}
```

Neste exemplo, a interface `ProdutoMapper` usa a anotação `@Mapper` com `componentModel = "spring"`. O método `produtoToProdutoDTO` é responsável 
por mapear um objeto `Produto` para um objeto `ProdutoDTO`. A anotação `@Mapping` é usada para definir mapeamentos personalizados entre os 
atributos.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Em uma estrutura de projeto, o pacote "handler" geralmente é usado para agrupar classes que lidam com a manipulação de solicitações HTTP, 
especialmente aquelas que não se encaixam bem em um controlador tradicional. O uso de um pacote "handler" pode ajudar a organizar o código 
relacionado ao tratamento de solicitações específicas, além de manter os controladores mais focados nas operações principais da sua aplicação.

Aqui estão alguns cenários comuns em que um pacote "handler" pode ser usado:

1. **Tratamento de Erros Globais**: Você pode ter classes dentro do pacote "handler" que lidam com o tratamento de erros globais da aplicação. 
   Isso pode incluir a captura de exceções não tratadas e o envio de respostas de erro padronizadas.

2. **Integração com APIs Externas**: Se a sua aplicação se comunica com APIs externas, você pode criar classes no pacote "handler" para 
   encapsular a lógica de integração, como fazer chamadas HTTP, manipular respostas e lidar com erros.

3. **Autenticação e Autorização Personalizadas**: Se você precisa de lógica personalizada para autenticação e autorização, pode criar classes no 
   pacote "handler" para lidar com essas responsabilidades.

4. **Validação de Dados**: Se você tem validações de dados específicas que não se encaixam nas anotações de validação padrão do Spring, pode 
   criar classes no pacote "handler" para lidar com essa validação.

5. **Conversão de Formatos**: Se você precisa converter dados de um formato para outro, como manipular dados XML ou JSON, pode criar classes no 
   pacote "handler" para essa conversão.

6. **Tarefas Agendadas**: Se você tem tarefas agendadas que precisam ser executadas em intervalos específicos, pode criar classes no pacote 
   "handler" para lidar com essas tarefas.

Lembre-se de que não existe uma regra estrita para o que deve ser colocado em um pacote "handler". A nomenclatura e a organização do seu projeto 
podem variar com base nas melhores práticas adotadas pela sua equipe e nas necessidades específicas da aplicação. O objetivo é manter o código 
organizado e fácil de entender, agrupando funcionalidades relacionadas em pacotes lógicos.

--------------- // ---------------

Anotação `@ControllerAdvice`

A anotação `@ControllerAdvice` é uma anotação do Spring Framework que permite definir classes que fornecem tratamento global para exceções em 
toda a aplicação. Essas classes são conhecidas como "global exception handlers" (manipuladores globais de exceção) e têm a capacidade de 
centralizar a lógica de tratamento de exceções, evitando a duplicação de código em diversos pontos do código.

Aqui estão as principais funcionalidades e usos da anotação `@ControllerAdvice`:

1. **Tratamento Global de Exceções**: Ao anotar uma classe com `@ControllerAdvice`, você pode definir métodos que capturam exceções específicas 
   ou genéricas e fornecem um tratamento unificado para elas.

2. **Centralização de Lógica**: Com um "controller advice", você pode centralizar a lógica de tratamento de exceções em um único local. Isso 
   evita que você precise repetir o mesmo código de tratamento de exceções em vários controladores.

3. **Respostas Personalizadas de Erro**: Com `@ControllerAdvice`, você pode personalizar as respostas de erro, como definir códigos de status, 
   mensagens de erro e outros detalhes da resposta.

4. **Tratamento de Exceções de Validação**: Você pode usar `@ControllerAdvice` para lidar com exceções de validação, como as lançadas quando 
   dados inválidos são enviados para os controladores.

5. **Tratamento de Exceções de Formato**: Se a aplicação recebe dados em formatos diversos (JSON, XML, etc.), você pode usar `@ControllerAdvice` 
   para lidar com exceções de conversão e formatação.

6. **Integração com Exceções Personalizadas**: Você pode criar exceções personalizadas para cenários específicos da sua aplicação e definir 
   tratamento específico para essas exceções usando `@ControllerAdvice`.

--------------- // ---------------

A anotação @ExceptionHandler é uma anotação do Spring Framework que indica um método que deve ser invocado para lidar com uma exceção específica 
lançada durante a execução de um controlador. Essa anotação é comumente usada em conjunto com a anotação @ControllerAdvice para definir 
tratamentos globais de exceção ou tratamentos específicos para determinados controladores.

No contexto da anotação @ExceptionHandler(BadRequestException.class), o que acontece é:

 1. @ExceptionHandler: Indica que o método anotado é responsável por tratar uma exceção específica.

 2. (BadRequestException.class): Isso especifica qual exceção o método deve tratar. No exemplo, BadRequestException.class é uma classe de 
    exceção que representa uma situação em que ocorreu uma requisição inválida (código de status HTTP 400 Bad Request).

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação `@Transactional`

A anotação `@Transactional` é uma anotação usada no Spring Framework para controlar a transação de operações em um banco de dados. Ela define um 
escopo transacional para um método ou um conjunto de métodos, garantindo que essas operações sejam executadas de forma atômica, consistente, 
isolada e durável (princípios ACID de transações).

A anotação `@Transactional` pode ser aplicada a nível de classe ou método. Quando aplicada a nível de classe, ela se aplica a todos os métodos 
públicos da classe. Quando aplicada a nível de método, ela se aplica apenas ao método específico. Ela pode ser usada em controladores, serviços 
ou qualquer componente gerenciado pelo Spring.

Aqui estão algumas funcionalidades da anotação `@Transactional`:

1. **Atomicidade**: Todas as operações dentro do escopo transacional são tratadas como uma unidade atômica. Isso significa que todas as operações 
   são bem-sucedidas ou todas falham, evitando estados intermediários inconsistentes no banco de dados.

2. **Consistência**: A transação garante que o banco de dados esteja em um estado consistente antes e depois das operações.

3. **Isolamento**: A anotação permite controlar o nível de isolamento das transações, garantindo que as operações de uma transação não 
   interfiram nas operações de outras transações concorrentes.

4. **Durabilidade**: As alterações feitas dentro do escopo transacional são permanentes e persistem mesmo após um reinício do sistema.

Exemplo qualquer de uso:

```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
    }

    @Transactional(readOnly = true)
    public User getUserById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
```

No exemplo acima, a anotação `@Transactional` é usada nos métodos `createUser` e `getUserById` do serviço `UserService`. No método `createUser`, 
a anotação garante que a operação de salvamento no banco de dados seja tratada como uma única transação. No método `getUserById`, a anotação 
com o parâmetro `readOnly = true` define que a transação será somente para leitura, o que pode otimizar o desempenho quando não há necessidade 
de operações de gravação no banco de dados.

a anotação @Transactional pode ser usada em vários métodos da camada de serviço, incluindo os métodos de busca, atualização e exclusão. Ela 
ajuda a garantir a consistência das operações e a controlar o escopo da transação em torno dessas operações.

Além da propriedade readOnly, existem outras propriedades que podem ser usadas com a anotação @Transactional para controlar o comportamento da 
transação:

1. isolation: Define o nível de isolamento da transação. Você pode usar valores como:
   -> Isolation.DEFAULT - O nível de isolamento padrão definido pelo banco de dados ou pelo ambiente de execução. Isso geralmente equivale a 
                          Isolation.READ_COMMITTED.
   
   -> Isolation.READ_UNCOMMITTED - O nível mais baixo de isolamento. As transações podem ver alterações não confirmadas por outras transações. 
                                   Isso pode resultar em leituras sujas (dirty reads), onde as informações podem ser imprecisas.
    
   -> Isolation.READ_COMMITTED - As transações só podem ver dados confirmados por outras transações. Isso evita leituras sujas, mas ainda 
                                 permite o fenômeno de leituras não repetíveis.
                                 
   -> Isolation.REPEATABLE_READ - Garante que, uma vez que uma linha seja lida por uma transação, qualquer leitura subsequente da mesma linha 
                                  durante a mesma transação retornará o mesmo valor. Isso evita leituras não repetíveis, mas ainda permite o 
                                  fenômeno da leitura fantasma.
   
   -> Isolation.SERIALIZABLE - É o nível de isolamento mais alto. Garante que as transações ocorram como se fossem executadas uma após a outra, 
                               evitando leituras sujas, leituras não repetíveis e leituras fantasmas. No entanto, isso pode levar a um desempenho 
                               mais baixo devido ao bloqueio rigoroso.

 A escolha do nível de isolamento depende dos requisitos de consistência, desempenho e concorrência da sua aplicação. Níveis de isolamento mais 
 altos fornecem maior consistência, mas podem resultar em bloqueios e possivelmente em degradação de desempenho. Por outro lado, níveis de 
 isolamento mais baixos podem resultar em melhores desempenhos, mas podem introduzir inconsistências nos dados lidos.

2. propagation: Define a propagação da transação quando chamado a partir de outro método transacional. Valores possíveis incluem: 
   -> Propagation.REQUIRED - Esse é o valor padrão. Se um método transacional é chamado dentro de outro método que já está em uma transação, o 
                             método chamado participará da transação existente. Caso contrário, uma nova transação será criada. Isso significa 
                             que vários métodos dentro de uma mesma transação compartilham a mesma transação, e se a transação pai for revertida, 
                             todas as operações serão revertidas.
   
   -> Propagation.REQUIRES_NEW -  Esse valor garante que um novo contexto de transação seja criado para o método chamado, independentemente de 
                                  haver uma transação em andamento no método chamador. Isso cria uma transação separada para o método chamado, 
                                  isolando completamente suas operações da transação pai.
   
   -> Propagation.MANDATORY - Esse valor indica que o método deve ser chamado dentro de uma transação existente. Se não houver uma transação, 
                              uma exceção será lançada. Isso garante que um método só será executado dentro de uma transação existente.
   
   -> entre outros.

Exemplo qualquer de uso:

```
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
        updateUserStats();
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateUserStats() {
        // Atualizar estatísticas do usuário em uma nova transação independente
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public User getUserById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
```
 No exemplo acima, o método createUser chama o método updateUserStats com Propagation.REQUIRED, o que significa que ambos compartilham a mesma 
 transação. O método updateUserStats utiliza Propagation.REQUIRES_NEW, criando uma nova transação. O método getUserById usa Propagation.MANDATORY, 
 garantindo que ele seja chamado apenas dentro de uma transação existente.

3. timeout: Define o tempo limite da transação em segundos. A transação será revertida se o tempo limite for excedido.

4. rollbackFor e noRollbackFor: Define as exceções que devem ou não causar o rollback da transação.

5. rollbackForClassName e noRollbackForClassName: Versões por nome das propriedades acima.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

As anotações como `@NotEmpty`, `@NotNull`, `@Min`, `@Max`, `@Size`, entre outras, fazem parte da biblioteca de validação do Bean Validation, que 
é integrada ao Spring Boot através da dependência `spring-boot-starter-validation`. Essas anotações são usadas para validar os dados de entrada 
e garantir que atendam aos critérios definidos antes de serem processados pela aplicação. Aqui estão algumas das anotações mais comuns:

1. **`@NotNull`**: Essa anotação é usada para garantir que o valor do campo não seja nulo.

2. **`@NotEmpty`**: Essa anotação é usada para garantir que uma coleção, uma string ou um array não esteja vazio ou nulo.

3. **`@NotBlank`**: Semelhante ao `@NotEmpty`, mas também verifica se a string não consiste apenas em espaços em branco.

4. **`@Min`**: Essa anotação define o valor mínimo que um campo numérico pode ter.

5. **`@Max`**: Essa anotação define o valor máximo que um campo numérico pode ter.

6. **`@Size`**: Essa anotação define o tamanho mínimo e máximo de uma coleção, string ou array.

7. **`@Pattern`**: Essa anotação permite validar uma string usando uma expressão regular.

8. **`@Email`**: Essa anotação valida se uma string é um endereço de e-mail válido.

9. **`@Valid`**: Essa anotação é usada para indicar que uma propriedade deve ser validada recursivamente. Pode ser usada, por exemplo, para validar objetos aninhados.

Exemplo de uso das anotações:

```java
public class User {

    @NotNull
    @Size(min = 2, max = 50)
    private String name;

    @NotEmpty
    @Email
    private String email;

    @Min(18)
    private int age;

    // Getters e setters
}
```

Neste exemplo, a classe `User` possui campos anotados com `@NotNull`, `@Size`, `@NotEmpty`, `@Email` e `@Min`. Quando um objeto `User` é validado 
usando o Bean Validation, as restrições definidas por essas anotações serão aplicadas para garantir que os dados atendam aos critérios 
estabelecidos. Caso contrário, exceções de validação serão lançadas, informando que os dados não estão em conformidade com as regras definidas.

--------------- // ---------------

Anotação @Valid

A anotação @Valid é uma anotação do Bean Validation que é usada para indicar que um objeto aninhado deve ser validado. Essa anotação é frequentemente usada em campos que são objetos complexos ou coleções dentro de uma classe.

Quando você coloca a anotação @Valid em um campo, o mecanismo de validação do Bean Validation verifica se o objeto contido nesse campo está em 
conformidade com as regras de validação definidas para ele. Se o objeto não for válido, as restrições definidas pelas anotações no próprio objeto 
aninhado serão aplicadas, e as exceções de validação apropriadas serão lançadas.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @SuperBuilder

A anotação @SuperBuilder faz parte do projeto Lombok, que é uma biblioteca do Java que ajuda a reduzir a quantidade de código boilerplate, como 
getters, setters, construtores e outros métodos repetitivos, tornando o código mais conciso e legível.

A anotação @SuperBuilder é usada para criar construtores fluentes em classes que herdam de outras classes. Ela é particularmente útil quando 
você está trabalhando com herança e deseja que as subclasses tenham construtores com a mesma funcionalidade da classe pai.

O uso de @SuperBuilder economiza muito código e torna mais fácil criar objetos complexos com herança. É importante notar que você precisará 
configurar o Lombok corretamente em seu projeto para usar essa anotação.

--------------- // ---------------

Anotação @Getter

A anotação @Getter faz parte do projeto Lombok, que é uma biblioteca Java que ajuda a reduzir a verbosidade do código, eliminando a necessidade 
de escrever métodos getters manualmente. Ela é usada para gerar automaticamente métodos getter para os campos (atributos) de uma classe.

A anotação @Getter é uma maneira eficiente de criar métodos getter em suas classes, economizando tempo e reduzindo a quantidade de código que 
você precisa escrever manualmente. Isso também ajuda a manter seu código mais limpo e legível.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A classe ResponseEntityExceptionHandler faz parte do framework Spring e é projetada para lidar com exceções globais em um aplicativo Spring 
Boot que produz respostas HTTP. Ela é uma classe abstrata que estende ResponseEntityExceptionHandler e fornece métodos para tratar várias 
exceções comuns, como erros de validação, exceções de servidor interno, exceções de método não suportado e muito mais.

A principal finalidade da ResponseEntityExceptionHandler é capturar exceções lançadas em seu aplicativo e transformá-las em respostas HTTP 
adequadas, que geralmente têm um formato JSON ou XML para serem consumidos por clientes da API.

Você pode personalizar o tratamento de exceções de acordo com as necessidades do seu aplicativo, adicionando métodos adicionais anotados com 
@ExceptionHandler para lidar com tipos de exceções específicos.

Em resumo, ResponseEntityExceptionHandler é uma classe útil para lidar com exceções globalmente em seu aplicativo Spring Boot e personalizar as 
respostas HTTP retornadas em caso de erros. Ela é amplamente usada para padronizar o tratamento de exceções em APIs RESTful.

Alguns dos métodos mais comuns fornecidos pela classe `ResponseEntityExceptionHandler` que são frequentemente utilizados para lidar com exceções 
em um aplicativo Spring Boot:

1. `handleExceptionInternal`: Este método é usado para lidar com exceções gerais e pode ser personalizado para gerar uma resposta HTTP 
    personalizada. É frequentemente usado para lidar com exceções não tratadas.

2. `handleMethodArgumentNotValid`: Este método lida com exceções relacionadas à validação de argumentos de métodos, geralmente lançadas quando 
    os dados de entrada não estão em conformidade com as regras de validação definidas. Ele pode ser usado em conjunto com anotações de 
    validação, como `@Valid`.

3. `handleHttpRequestMethodNotSupported`: Este método lida com exceções lançadas quando um método HTTP não é suportado em um endpoint específico. 
    Por exemplo, ao tentar acessar um endpoint com um método HTTP que não é permitido, como POST em um endpoint que só permite GET.

4. `handleHttpMediaTypeNotSupported`: Este método lida com exceções relacionadas à falta de suporte ao tipo de mídia (por exemplo, JSON, XML) 
    solicitado pelo cliente.

5. `handleHttpMediaTypeNotAcceptable`: Este método lida com exceções lançadas quando o servidor não pode produzir uma resposta no formato de 
    mídia aceitável pelo cliente.

6. `handleMissingPathVariable`: Lidar com exceções lançadas quando um caminho da URL esperado não é encontrado.

7. `handleNoHandlerFoundException`: Este método lida com exceções quando nenhum manipulador (controlador) é encontrado para a solicitação do 
    cliente.

8. `handleTypeMismatch`: Este método lida com exceções lançadas quando um valor do parâmetro não pode ser convertido para o tipo esperado.

9. `handleDataIntegrityViolation`: Usado para tratar exceções relacionadas à integridade dos dados, geralmente lançadas quando há violações de 
    restrições de chave primária ou chave única.

Estes são apenas alguns dos métodos disponíveis na classe `ResponseEntityExceptionHandler`. Você pode criar métodos personalizados adicionais 
para lidar com exceções específicas de seu aplicativo. Além disso, você pode personalizar as respostas HTTP retornadas para cada tipo de exceção, 
definindo um objeto `ResponseEntity` personalizado com o status HTTP e o corpo desejados.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Classes `Page` e `Pageable` no contexto de aplicativos Spring Data e Spring Boot:

1. **`Page`**:
   - A classe `Page` é uma parte do framework Spring Data e é usada para representar uma página de resultados de consulta em uma lista paginada 
     de elementos.
   - Ela encapsula uma lista de elementos de dados junto com informações sobre a página, como número total de páginas, número total de elementos, 
     tamanho da página e outros detalhes relacionados à paginação.
   - É frequentemente usada quando você deseja dividir grandes conjuntos de dados em partes menores para melhorar a eficiência e a usabilidade 
     de seu aplicativo.
   - O Spring Data geralmente retorna objetos `Page` como resultado de consultas que envolvem a paginação, permitindo fácil navegação pelos 
     resultados.

2. **`Pageable`**:
   - A interface `Pageable` é usada para representar informações sobre a paginação, como número da página, tamanho da página, ordenação e outros 
     detalhes relacionados à recuperação de resultados paginados.
   - Ela define métodos para acessar e configurar essas informações, permitindo que você especifique qual página de resultados deseja recuperar, 
     qual é o tamanho da página e como os resultados devem ser ordenados.
   - No Spring Data, você geralmente cria objetos `Pageable` e os passa como argumentos para métodos de consulta que suportam a paginação. Dessa 
     forma, você pode personalizar a consulta para retornar a página desejada.

Em resumo, `Page` é usada para encapsular uma página de resultados paginados, enquanto `Pageable` é usada para configurar os detalhes da 
paginação, como número da página, tamanho da página e ordenação. Essas classes são muito úteis ao lidar com grandes volumes de dados e ao criar 
consultas paginadas em aplicativos Spring Data.

O Page<Anime> é usado para representar um conjunto paginado de objetos do tipo Anime. Isso pode ser útil ao consultar grandes conjuntos de dados 
em um banco de dados e dividir os resultados em páginas para melhorar o desempenho e a usabilidade de um aplicativo.

A classe Page geralmente oferece métodos para navegar pelas páginas, acessar informações sobre a página atual, como número total de páginas, 
tamanho da página, número total de elementos, etc. Isso permite a criação de recursos de paginação em APIs ou interfaces de usuário, onde os 
resultados são exibidos em partes gerenciáveis.

--------------- // ---------------

Acessando no Postman:

Usando paginação (define qtd de páginas) - listar todos os animes
http://localhost:8080/animes?size=5

Usando paginação (define a página acessada) - listar todos os animes
http://localhost:8080/animes?size=5&page=3

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Configuration

A anotação `@Configuration` é uma das anotações fundamentais do Spring Framework e é usada para indicar que uma classe é uma classe de 
configuração. Ela desempenha um papel crucial na configuração de aplicativos Spring e na definição de beans gerenciados pelo Spring Container.

Aqui estão os principais pontos sobre a anotação `@Configuration`:

1. **O Que Faz**: A anotação `@Configuration` é usada para identificar classes que definem configurações para o aplicativo. Essas configurações 
   podem incluir definições de beans, configurações de componentes e outras configurações relacionadas ao Spring.

2. **Classes de Configuração**: As classes anotadas com `@Configuration` geralmente contêm métodos anotados com `@Bean`. Esses métodos definem 
   os beans gerenciados pelo Spring e suas configurações.

3. **Beans Gerenciados**: Os métodos anotados com `@Bean` dentro de uma classe `@Configuration` são interpretados pelo Spring como instruções 
   para criar beans gerenciados. Esses beans são inicializados e configurados pelo Spring Container e podem ser injetados em outras partes do 
   aplicativo.

4. **Substituição para XML**: A anotação `@Configuration` é frequentemente usada como uma alternativa ao uso de configurações XML para definir 
   beans. Ela oferece uma abordagem mais programática e baseada em código para a configuração do aplicativo.

5. **Escopo Singleton por Padrão**: Os beans definidos em classes anotadas com `@Configuration` têm escopo singleton por padrão. Isso significa 
   que o Spring Container cria apenas uma instância do bean e a reutiliza sempre que o bean é injetado em outras partes do aplicativo.

6. **Component Scanning**: Classes anotadas com `@Configuration` também podem ser detectadas automaticamente pelo mecanismo de varredura de 
   componentes do Spring, tornando-as elegíveis para uso como configurações.

Em resumo, a anotação `@Configuration` é uma parte fundamental da configuração baseada em Java no Spring Framework e desempenha um papel 
importante na definição e configuração de beans gerenciados pelo Spring. Ela permite que você configure seu aplicativo de forma programática, 
facilitando a organização e a manutenção do código de configuração.

--------------- // ---------------

Interface `WebMvcConfigurer`

A interface `WebMvcConfigurer` é uma parte importante do Spring Framework e é usada para configurar vários aspectos do mecanismo Spring MVC 
(Model-View-Controller) em um aplicativo web. Ela permite personalizar e ajustar o comportamento padrão do Spring MVC de acordo com as 
necessidades do seu aplicativo.

Principais funcionalidades que você pode realizar ao implementar a interface `WebMvcConfigurer`:

1. **Configuração de Controladores**: Você pode adicionar seus próprios controladores personalizados, bem como configurar controladores padrão 
   do Spring MVC.

2. **Configuração de Visualizações**: É possível definir como as visualizações são resolvidas e configurar visualizações personalizadas.

3. **Interceptadores**: Você pode adicionar interceptadores para executar código antes e depois do processamento da solicitação pelo controlador.

4. **Recursos Estáticos**: É possível configurar o tratamento de recursos estáticos, como arquivos CSS, JavaScript e imagens.

5. **Conversores e Formatadores**: Você pode registrar conversores e formatadores personalizados para mapear dados de solicitação para objetos 
   Java e vice-versa.

6. **Validação**: Você pode configurar validação personalizada para objetos de formulário.

7. **Gerenciamento de Recursos**: É possível configurar o local de armazenamento de recursos, como arquivos de upload.

8. **Configuração de Content Negotiation**: Definir regras para a negociação de conteúdo com base no cabeçalho `Accept` da solicitação.

9. **Configuração de Mapeamento de URLs**: Personalizar o mapeamento de URLs para controladores e recursos.

10. **Tratamento de Exceções**: Configurar como as exceções são tratadas e personalizar páginas de erro.

11. **Configuração do Local**: Definir o local e a codificação padrão para seu aplicativo.

Para implementar a interface `WebMvcConfigurer`, você geralmente cria uma classe de configuração que estende `WebMvcConfigurerAdapter` 
(desde o Spring 5, você pode implementar diretamente `WebMvcConfigurer`). Em seguida, você sobrescreve os métodos apropriados para personalizar 
o comportamento do Spring MVC.

Aqui está um exemplo simples de uma classe que implementa `WebMvcConfigurer` para configurar um interceptor:

```java
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor());
    }
}
```

Neste exemplo, a classe `MyWebMvcConfig` é anotada com `@Configuration` e implementa `WebMvcConfigurer`. Ela sobrescreve o método 
`addInterceptors` para adicionar um interceptor personalizado.

Em resumo, a interface `WebMvcConfigurer` fornece uma maneira flexível de personalizar o comportamento do Spring MVC em um aplicativo web. Ela 
permite que você adapte o Spring MVC para atender às necessidades específicas do seu projeto, tornando-o uma ferramenta poderosa para configurar 
a camada de controle de um aplicativo web Spring.

--------------- // ---------------

O método `addArgumentResolvers` faz parte da interface `WebMvcConfigurer` e é usado para configurar os resolutores de argumentos personalizados 
que serão usados pelo Spring MVC ao lidar com solicitações HTTP.

Em um controlador Spring MVC, os métodos podem receber argumentos que representam partes da solicitação HTTP, como parâmetros da URL, cabeçalhos 
HTTP, corpo da solicitação e muito mais. O Spring MVC usa resolutores de argumentos para converter esses componentes da solicitação em objetos 
que podem ser passados como argumentos para os métodos do controlador.

O método `addArgumentResolvers` permite que você registre resolutores de argumentos personalizados para que o Spring MVC possa usá-los ao 
processar solicitações HTTP. Isso é útil quando você deseja estender o comportamento padrão do Spring MVC para lidar com tipos de argumento 
personalizados ou quando precisa realizar alguma lógica especial durante a resolução de argumentos.

Você pode criar resolutores de argumentos personalizados para atender às necessidades específicas do seu aplicativo. Por exemplo, você pode 
criar um resolutor de argumentos que converte um cabeçalho HTTP personalizado em um objeto Java específico ou realiza alguma validação 
personalizada durante a resolução de argumentos.

Em resumo, o método `addArgumentResolvers` é usado para configurar resolutores de argumentos personalizados no Spring MVC, permitindo que você 
estenda e personalize o processamento de solicitações HTTP nos controladores.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Utilizando o Sorting para ordenar a lista por name - usando o Postman ou o Thunder Client (VSCode)
http://localhost:8080/animes?size=20&sort=name


--------------- // ---------------

Esse script faz parte da configuração de log em um aplicativo Spring que utiliza o framework Hibernate para interagir com um banco de dados. 
Essa configuração está usando o mecanismo de log SLF4J (Simple Logging Facade for Java) com uma configuração específica para o Hibernate.

Aqui está uma explicação do script:

```yaml
logging:  # Início da configuração de log
  level:  # Nível de log
    org:  # Pacote raiz para a configuração de níveis de log
      hibernate:  # Pacote Hibernate para a configuração de níveis de log
        SQL: DEBUG  # Define o nível de log DEBUG para as mensagens SQL do Hibernate
```

- `logging`: Isso marca o início da configuração de log para o aplicativo.

- `level`: Aqui você pode definir os níveis de log para diferentes pacotes ou classes do seu aplicativo.

- `org`: Este é o pacote raiz para a configuração de níveis de log. Qualquer pacote ou classe que esteja abaixo deste pacote no sistema de pacotes 
   Java será afetado por essa configuração.

- `hibernate`: Este é um subpacote do Hibernate dentro do pacote `org`. Esta configuração específica se aplica apenas ao Hibernate.

- `SQL: DEBUG`: Aqui, o nível de log DEBUG é configurado para as mensagens SQL geradas pelo Hibernate. Isso significa que o Hibernate registrará 
   mensagens de log com o nível DEBUG sempre que executar consultas SQL. Isso pode ser útil para depurar e entender o que está acontecendo no 
   banco de dados quando o Hibernate interage com ele.

Em resumo, esse script configura o nível de log DEBUG para as mensagens SQL do Hibernate. Isso permite que você veja detalhes das consultas SQL 
executadas pelo Hibernate, o que pode ser útil durante o desenvolvimento e a depuração de aplicativos que utilizam o Hibernate para persistência 
de dados.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

O que é o `RestTemplate` e como funcionam os métodos `getForEntity` e `getForObject`.

RestTemplate

O `RestTemplate` é uma classe da biblioteca Spring Framework que fornece uma maneira conveniente de interagir com serviços RESTful por meio de 
chamadas HTTP. Ele simplifica a comunicação cliente-servidor em aplicativos Java que precisam consumir serviços web RESTful.

O `RestTemplate` oferece métodos para executar operações HTTP como GET, POST, PUT e DELETE, permitindo que você faça chamadas a serviços web 
externos e manipule as respostas recebidas de maneira programática.

`getForEntity` e `getForObject`

Ambos `getForEntity` e `getForObject` são métodos do `RestTemplate` usados para fazer solicitações HTTP GET e receber uma resposta de um serviço 
REST.

1. `getForEntity`: Este método é usado quando você deseja obter informações adicionais além do corpo da resposta HTTP, como cabeçalhos e status. 
   Ele retorna uma instância de `ResponseEntity` que contém todos os detalhes da resposta, incluindo o corpo da resposta, status HTTP e cabeçalhos.

```java
ResponseEntity<T> responseEntity = restTemplate.getForEntity(url, responseType);
```

Exemplo:

```java
ResponseEntity<String> response = restTemplate.getForEntity("https://api.example.com/resource", String.class);
HttpStatus httpStatus = response.getStatusCode();
String responseBody = response.getBody();
```

2. `getForObject`: Este método é usado quando você está apenas interessado no corpo da resposta HTTP e não precisa dos cabeçalhos ou do status. 
Ele retorna diretamente o corpo da resposta como um objeto do tipo especificado.

```java
T response = restTemplate.getForObject(url, responseType);
```

Exemplo:

```java
String responseBody = restTemplate.getForObject("https://api.example.com/resource", String.class);
```

Ambos os métodos são úteis em diferentes situações, dependendo de quais informações específicas da resposta você precisa. Se você precisa de 
informações como cabeçalhos e status, use `getForEntity`. Se você só precisa do corpo da resposta, use `getForObject`.

Lembre-se de que, ao usar esses métodos, você deve tratar exceções de rede, como `RestClientException`, que podem ocorrer se houver problemas de 
conectividade com o serviço REST ou se a solicitação não for bem-sucedida. Além disso, é importante tratar possíveis exceções ao fazer o parsing 
do corpo da resposta, dependendo do tipo esperado.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

O script abaixo usa o `RestTemplate` para fazer uma chamada HTTP GET a uma URL específica e receber uma resposta que é do tipo `List<Anime>`. Vamos analisar o código linha por linha:

ResponseEntity<List<Anime>> exchange = new RestTemplate().exchange("http://localhost:8080/animes/all",
                HttpMethod.GET, null,
                new ParameterizedTypeReference<List<Anime>>() {
                });

1. `ResponseEntity<List<Anime>> exchange = new RestTemplate().exchange("http://localhost:8080/animes/all", HttpMethod.GET, null, new 
    ParameterizedTypeReference<List<Anime>>() {});`

   - `ResponseEntity<List<Anime>>`: Isso declara uma variável chamada `exchange` do tipo `ResponseEntity` que irá armazenar a resposta da 
      chamada HTTP. Neste caso, a resposta é esperada como uma lista de objetos do tipo `Anime`.

   - `new RestTemplate()`: Aqui, estamos criando uma nova instância de `RestTemplate`, que é uma classe do Spring Framework usada para fazer 
      chamadas HTTP a serviços web.

   - `.exchange("http://localhost:8080/animes/all", HttpMethod.GET, null, new ParameterizedTypeReference<List<Anime>>() {})`: Este é o método 
      `exchange` do `RestTemplate`, usado para fazer uma chamada HTTP. Vamos analisar os argumentos:

     - `"http://localhost:8080/animes/all"`: É a URL para a qual a chamada HTTP será feita. Neste caso, a URL é 
        `"http://localhost:8080/animes/all"`.

     - `HttpMethod.GET`: Indica que estamos fazendo uma chamada HTTP GET. Ou seja, estamos solicitando informações do servidor.

     - `null`: Este é o corpo da solicitação HTTP. Como estamos fazendo uma chamada GET sem enviar dados no corpo, usamos `null`.

     - `new ParameterizedTypeReference<List<Anime>>() {}`: Aqui, estamos especificando que tipo de resposta esperamos da chamada HTTP. Neste 
        caso, estamos esperando uma lista de objetos do tipo `Anime`. A classe `ParameterizedTypeReference` é usada para representar tipos 
      genéricos, como listas ou mapas com tipos específicos de elementos.

Após a execução deste script, a variável `exchange` conterá a resposta da chamada HTTP. Se a chamada for bem-sucedida, `exchange` conterá a 
lista de objetos `Anime` retornados pelo servidor. Você pode acessar os elementos da lista e outras informações, como cabeçalhos HTTP e status, 
usando métodos disponíveis em `ResponseEntity`. Por exemplo, `exchange.getBody()` lhe dará a lista de animes.

Este código é útil quando você precisa fazer chamadas HTTP a serviços web RESTful e deseja receber respostas tipadas, especialmente quando a 
resposta é uma lista ou outro tipo genérico.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

O script abaixo está usando o padrão de design **Builder** para criar uma instância da classe `Anime`. Vamos analisar cada parte:

```
Anime kingdom = Anime.builder().name("kingdom").build();
Anime kingdomSave = new RestTemplate().postForObject("http://localhost:8080/animes/", kingdom, Anime.class);
```

1. `Anime.builder()`: Aqui, você está chamando um método estático chamado `builder()` na classe `Anime`. Esse método retorna um construtor 
especial chamado de **builder** que é usado para criar objetos da classe `Anime` de maneira mais conveniente e legível.

2. `.name("kingdom")`: Uma vez que você tenha o **builder**, pode chamar métodos no builder para definir os valores dos atributos do objeto 
que deseja criar. Neste caso, você está chamando o método `name()` no builder e passando a string `"kingdom"` como argumento. Isso define o 
nome do anime como "kingdom".

3. `.build()`: Finalmente, você chama o método `build()` no **builder**. Isso cria e retorna uma instância da classe `Anime` com os atributos 
que você definiu anteriormente. O objeto resultante, neste caso, é atribuído à variável `kingdom`.

Em resumo, este script cria um objeto `Anime` com o nome definido como "kingdom" usando o padrão de design **Builder**, que é uma abordagem 
comum para construir objetos com muitos atributos opcionais ou configuráveis de maneira mais clara e concisa. O objeto resultante, `kingdom`, 
agora possui o nome "kingdom" definido como seu atributo.

Já o outro script está usando a classe `RestTemplate` para fazer uma solicitação HTTP POST e criar um novo recurso do tipo `Anime` no servidor. 
Vamos dividi-lo em partes:

1. `new RestTemplate()`: Isso cria uma instância da classe `RestTemplate`, que é uma classe fornecida pelo Spring Framework para fazer chamadas 
HTTP em aplicativos Java. O `RestTemplate` é usado para realizar operações HTTP, como POST, GET, PUT e DELETE.

2. `.postForObject("http://localhost:8080/animes/", kingdom, Anime.class)`: Aqui, você está chamando o método `postForObject()` do 
`RestTemplate`. Este método é usado para enviar uma solicitação HTTP POST para a URL especificada e esperar uma resposta que pode ser 
desserializada em um objeto Java da classe especificada (`Anime.class` neste caso).

   - `"http://localhost:8080/animes/"`: Esta é a URL de destino para a solicitação POST. Presumivelmente, esta é a URL onde seu servidor está 
       ouvindo para criar um novo recurso do tipo `Anime`.

   - `kingdom`: Este é o objeto `Anime` que você deseja enviar como parte do corpo da solicitação POST. Em outras palavras, você está enviando 
      os detalhes do anime que deseja criar no servidor.

   - `Anime.class`: Isso indica que você espera que a resposta da solicitação seja desserializada em um objeto `Anime`. Isso significa que o 
      servidor deve responder com os detalhes do anime recém-criado, e o `RestTemplate` irá transformar essa resposta em um objeto `Anime` que é armazenado na variável `kingdomSave`.

Portanto, após a execução desta linha de código, `kingdomSave` conterá os detalhes do anime recém-criado no servidor, como ID, nome, ou qualquer 
outro atributo que tenha sido configurado pelo servidor durante a criação. Isso é útil quando você deseja criar recursos no servidor por meio 
de uma solicitação HTTP POST e, em seguida, manipular ou exibir as informações retornadas pelo servidor.

--------------- // ---------------

O script abaixo cria um objeto `HttpHeaders` e o configura para indicar que o conteúdo da solicitação ou resposta HTTP é do tipo JSON 
(JavaScript Object Notation). 

```
private static HttpHeaders createJSonHeader(){
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.setContentType(MediaType.APPLICATION_JSON);
        return httpHeaders;
    }
```

Vamos analisá-lo linha por linha:

1. `HttpHeaders httpHeaders = new HttpHeaders();`: Aqui, você está criando uma instância de `HttpHeaders`, que é uma classe fornecida pelo 
Spring Framework para representar os cabeçalhos HTTP de uma solicitação ou resposta HTTP. Cada cabeçalho HTTP pode conter informações 
específicas, como o tipo de conteúdo, cookies, autenticação, etc.

2. `httpHeaders.setContentType(MediaType.APPLICATION_JSON);`: Esta linha configura o cabeçalho `Content-Type` para indicar que o conteúdo da 
solicitação ou resposta será no formato JSON. O método `setContentType` é usado para definir o tipo de conteúdo do cabeçalho.

   - `MediaType.APPLICATION_JSON`: `MediaType` é uma classe que faz parte do Spring Framework e contém várias constantes estáticas que 
      representam tipos de mídia comuns. `APPLICATION_JSON` é uma dessas constantes e representa o tipo de mídia JSON.

3. `return httpHeaders;`: Finalmente, a função retorna o objeto `HttpHeaders` configurado. Isso permite que você use esse objeto para definir 
os cabeçalhos de uma solicitação HTTP, especificando que o conteúdo é JSON. Por exemplo, você pode definir esses cabeçalhos em uma solicitação 
POST ou PUT para indicar que está enviando dados JSON para o servidor.

Em resumo, o objetivo dessa função é fornecer um cabeçalho HTTP configurado corretamente para lidar com dados JSON em suas solicitações ou 
respostas HTTP. Isso é útil quando você está trabalhando com APIs RESTful ou qualquer outra situação em que precise especificar o tipo de 
conteúdo como JSON.

O Método "createJSonHeader()" acima vai ser chamado por esse script:

```
Anime boruto = Anime.builder().name("Boruto").build();
        ResponseEntity<Anime> borutoSave = new RestTemplate().exchange("http://localhost:8080/animes/",
                HttpMethod.POST, new HttpEntity<>(boruto, createJSonHeader()), Anime.class);      
        System.out.println("Anime salvo: " + borutoSave);
```

Este script é usado para fazer uma solicitação HTTP POST a um servidor que se espera estar rodando localmente na URL 
`http://localhost:8080/animes/`. Ele cria um novo objeto `Anime` chamado "Boruto" e, em seguida, o envia para o servidor usando uma solicitação 
POST. Vamos analisar as partes do script:

1. `Anime boruto = Anime.builder().name("Boruto").build();`: Aqui, você está criando um novo objeto `Anime` usando um padrão de construção 
(Builder Pattern). O `builder()` é um método que cria um construtor de objeto `Anime` e, em seguida, você chama `name("Boruto")` para definir o 
nome do anime como "Boruto". Finalmente, `build()` é chamado para criar o objeto `Anime`.

2. `new RestTemplate()`: Aqui, você está criando uma instância de `RestTemplate`. O `RestTemplate` é uma classe da biblioteca Spring Framework 
que facilita o envio de solicitações HTTP para um servidor. Ele é usado para interagir com APIs RESTful.

3. `new HttpEntity<>(boruto, createJSonHeader())`: Este é o corpo da solicitação HTTP POST. Ele cria uma instância de `HttpEntity`, que é usada 
para representar o corpo da solicitação HTTP. O corpo é o objeto `boruto` que você deseja enviar para o servidor, e `createJSonHeader()` é 
chamado para criar os cabeçalhos HTTP necessários, indicando que o conteúdo é do tipo JSON.

4. `HttpMethod.POST`: Aqui, você está especificando que deseja fazer uma solicitação HTTP POST. Isso é apropriado quando você deseja criar um 
novo recurso no servidor.

5. `Anime.class`: Este é o tipo de retorno esperado da solicitação. Você está informando ao `RestTemplate` que deseja que o resultado da 
solicitação seja desserializado em um objeto `Anime`. Isso é útil para processar a resposta do servidor.

6. `ResponseEntity<Anime> borutoSave = new RestTemplate().exchange(...)`: Aqui, você está usando o método `exchange()` do `RestTemplate` para 
enviar a solicitação HTTP. Ele retorna um `ResponseEntity<Anime>`, que contém a resposta do servidor, incluindo o status HTTP, cabeçalhos e 
corpo da resposta.

7. `System.out.println("Anime salvo: " + borutoSave);`: Finalmente, você está imprimindo a resposta do servidor no console. Isso mostrará 
informações sobre a solicitação, como o status HTTP (por exemplo, 200 OK se a solicitação for bem-sucedida) e outros detalhes relevantes.

No geral, este script cria um objeto `Anime` chamado "Boruto" e o envia para o servidor usando uma solicitação POST. Em seguida, ele imprime a 
resposta do servidor no console para que você possa ver os detalhes da solicitação e confirmar se o anime foi salvo com sucesso no servidor.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos fazer teste unitário escrito usando o framework JUnit 5 e a biblioteca AssertJ para testar a persistência de um objeto `Anime` em um 
repositório. Vamos quebrá-lo em partes:

```java
@Test
@DisplayName("Save creates anime when Successful")
void savePersistenceAnimeWhenSuccessful(){
    Anime animeToBeSaved = createAnime();

    Anime animeSaved = this.animeRepository.save(animeToBeSaved);

    Assertions.assertThat(animeSaved).isNotNull();
    Assertions.assertThat(animeSaved.getId()).isNotNull();
    Assertions.assertThat(animeSaved.getName()).isEqualTo(animeToBeSaved.getName());
}
```

- `@Test`: Esta anotação do JUnit 5 indica que o método é um caso de teste. Esse método será executado quando você executar seus testes.

- `@DisplayName("Save creates anime when Successful")`: Esta anotação fornece um nome personalizado para o teste que será exibido nos resultados 
   do teste. Isso ajuda a identificar o que exatamente está sendo testado.

- `void savePersistenceAnimeWhenSuccessful()`: Este é o método de teste em si. Ele não aceita argumentos e não retorna nada, pois é um teste de 
   verificação de estado.

- `Anime animeToBeSaved = createAnime();`: Aqui, está criando um objeto `Anime` chamado `animeToBeSaved` usando o método `createAnime()` 
   para inicializá-lo. Este é o objeto que você planeja salvar no repositório.

- `Anime animeSaved = this.animeRepository.save(animeToBeSaved);`: Aqui, está usando o método `save()` do `animeRepository` para salvar o objeto
  `animeToBeSaved` no repositório. O método `save()` retorna o objeto `animeSaved` após a persistência no banco de dados.

- `Assertions.assertThat(animeSaved).isNotNull();`: Esta linha usa a biblioteca AssertJ para verificar se o objeto `animeSaved` não é nulo. Se 
   a persistência for bem-sucedida, o objeto salvo não deve ser nulo.

- `Assertions.assertThat(animeSaved.getId()).isNotNull();`: Aqui, está verificando se o `id` do objeto `animeSaved` não é nulo. Isso é 
   importante porque geralmente o `id` é gerado pelo banco de dados durante a persistência.

- `Assertions.assertThat(animeSaved.getName()).isEqualTo(animeToBeSaved.getName());`: Esta linha verifica se o nome do objeto `animeSaved` é 
   igual ao nome do objeto `animeToBeSaved`. Isso garante que os dados salvos correspondam aos dados originais que você planejou salvar.

```java
private Anime createAnime(){
    return Anime.builder().name("Hajime in Ippo").build();
}
```

- `private Anime createAnime()`: Este é um método auxiliar usado para criar um objeto `Anime` com um nome específico, neste caso, "Hajime in 
   Ippo". Este método é chamado no início do teste para criar o objeto que será salvo no repositório.

Em resumo, esse teste verifica se a persistência de um objeto `Anime` no repositório é bem-sucedida. Ele cria um objeto, o salva no repositório 
e, em seguida, verifica se o objeto salvo não é nulo, se possui um `id` não nulo e se o nome é igual ao nome original. Se todas essas 
verificações passarem, o teste é considerado bem-sucedido. Caso contrário, qualquer falha indicaria um problema na persistência.

--------------- // ---------------

Outro exemplo de um teste unitário escrito usando o JUnit 5 e a biblioteca AssertJ. Este teste verifica se a atualização de um objeto `Anime` 
no repositório é bem-sucedida. Vamos analisá-lo em detalhes:

```java
@Test
@DisplayName("Save update anime when Successful")
void saveUpdateAnimeWhenSuccessful(){
    Anime animeToBeSaved = createAnime();

    Anime animeSaved = this.animeRepository.save(animeToBeSaved);
    animeSaved.setName("Overlod");

    Anime animeUpdate = this.animeRepository.save(animeSaved);

    Assertions.assertThat(animeUpdate).isNotNull();
    Assertions.assertThat(animeUpdate.getId()).isNotNull();
    Assertions.assertThat(animeUpdate.getName()).isEqualTo(animeSaved.getName());
}
```

- `@Test`: Esta anotação indica que o método é um caso de teste a ser executado.

- `@DisplayName("Save update anime when Successful")`: Esta anotação fornece um nome personalizado para o teste, que será exibido nos resultados 
   do teste.

- `void saveUpdateAnimeWhenSuccessful()`: Este é o método de teste em si, que não aceita argumentos e não retorna nada, pois é um teste de 
   verificação de estado.

- `Anime animeToBeSaved = createAnime();`: Aqui, está criando um objeto `Anime` chamado `animeToBeSaved` usando o método `createAnime()` 
   para inicializá-lo. Este é o objeto que você planeja salvar no repositório.

- `Anime animeSaved = this.animeRepository.save(animeToBeSaved);`: Aqui, está usando o método `save()` do `animeRepository` para salvar o objeto 
  `animeToBeSaved` no repositório. O objeto salvo é atribuído à variável `animeSaved`.

- `animeSaved.setName("Overlod");`: Aqui, está atualizando o nome do objeto `animeSaved` para "Overlod". Esta linha simula uma atualização de 
   dados em um objeto já persistido no repositório.

- `Anime animeUpdate = this.animeRepository.save(animeSaved);`: Aqui, está usando novamente o método `save()` do `animeRepository` para atualizar 
   o objeto `animeSaved` no repositório. O objeto atualizado é atribuído à variável `animeUpdate`.

- `Assertions.assertThat(animeUpdate).isNotNull();`: Esta linha usa a biblioteca AssertJ para verificar se o objeto `animeUpdate` não é nulo. 
   Se a atualização for bem-sucedida, o objeto atualizado não deve ser nulo.

- `Assertions.assertThat(animeUpdate.getId()).isNotNull();`: Aqui, está verificando se o `id` do objeto `animeUpdate` não é nulo. Isso é 
   importante porque geralmente o `id` é gerado pelo banco de dados durante a persistência.

- `Assertions.assertThat(animeUpdate.getName()).isEqualTo(animeSaved.getName());`: Esta linha verifica se o nome do objeto `animeUpdate` é 
   igual ao nome atualizado ("Overlod") que foi definido em `animeSaved`. Isso garante que os dados do objeto atualizado correspondam às alterações planejadas.

Em resumo, este teste verifica se a atualização de um objeto `Anime` no repositório é bem-sucedida. Ele cria um objeto, salva-o no repositório, 
atualiza o nome e, em seguida, verifica se o objeto atualizado não é nulo, se possui um `id` não nulo e se o nome corresponde à atualização 
planejada. Se todas essas verificações passarem, o teste é considerado bem-sucedido, indicando que a atualização ocorreu como esperado. Caso 
contrário, qualquer falha indicaria um problema na atualização.

--------------- // ---------------

Outro exemplo de teste unitário escrito com JUnit 5 e AssertJ. Neste caso, o teste verifica se a exclusão (ou remoção) de um objeto `Anime` do 
repositório é bem-sucedida. Vamos analisar o código linha a linha:

```java
@Test
@DisplayName("Delete removes anime when Successful")
void DeleteAnimeWhenSuccessful(){
    Anime animeToBeSaved = createAnime();

    Anime animeSaved = this.animeRepository.save(animeToBeSaved);

    this.animeRepository.delete(animeSaved);
    
    Optional<Anime> animeOptional = this.animeRepository.findById(animeSaved.getId());

    Assertions.assertThat(animeOptional.isEmpty());
}
```

- `@Test`: Esta anotação indica que o método é um caso de teste a ser executado.

- `@DisplayName("Delete removes anime when Successful")`: Esta anotação fornece um nome personalizado para o teste, que será exibido nos 
   resultados do teste.

- `void DeleteAnimeWhenSuccessful()`: Este é o método de teste em si, que não aceita argumentos e não retorna nada, pois é um teste de 
   verificação de estado.

- `Anime animeToBeSaved = createAnime();`: Aqui, está criando um objeto `Anime` chamado `animeToBeSaved` usando o método `createAnime()` 
   para inicializá-lo. Este é o objeto que você planeja salvar no repositório.

- `Anime animeSaved = this.animeRepository.save(animeToBeSaved);`: Aqui, está usando o método `save()` do `animeRepository` para salvar o objeto 
  `animeToBeSaved` no repositório. O objeto salvo é atribuído à variável `animeSaved`.

- `this.animeRepository.delete(animeSaved);`: Aqui, está excluindo o objeto `animeSaved` do repositório usando o método `delete()` do 
  `animeRepository`. Isso simula a ação de exclusão de um objeto persistido.

- `Optional<Anime> animeOptional = this.animeRepository.findById(animeSaved.getId());`: Aqui, está tentando encontrar o objeto `animeSaved` 
  no repositório usando o método `findById()`. O resultado é armazenado em um `Optional` chamado `animeOptional`. Se o objeto foi excluído com sucesso, isso deverá retornar um `Optional` vazio.

- `Assertions.assertThat(animeOptional.isEmpty());`: Aqui, está usando AssertJ para verificar se o `animeOptional` está vazio. Se 
   estiver vazio, isso significa que o objeto não foi encontrado no repositório, o que indica que a exclusão foi bem-sucedida.

Em resumo, este teste verifica se a exclusão de um objeto `Anime` do repositório é bem-sucedida. Ele cria um objeto, salva-o no repositório, 
exclui-o do repositório e depois verifica se o objeto não pode mais ser encontrado no repositório, o que seria indicativo de uma exclusão 
bem-sucedida. Se a asserção passar, o teste é considerado bem-sucedido.

--------------- // ---------------

No teste find by name:

```java
@Test
@DisplayName("Find by name returns list anime when Successful")
void findByNameAnimeWhenSuccessful(){
    // Cria um objeto Anime que será salvo no banco de dados
    Anime animeToBeSaved = createAnime();

    // Salva o anime no banco de dados usando o repositório
    Anime animeSaved = this.animeRepository.save(animeToBeSaved);

    // Obtém o nome do anime salvo
    String anime = animeSaved.getName();

    // Realiza uma consulta no banco de dados para encontrar animes pelo nome
    List<Anime> animes = this.animeRepository.findByName(anime);

    // Afirmações (Assertions) para verificar se o teste é bem-sucedido

    // 1. Verifica se a lista de animes encontrada não está vazia
    Assertions.assertThat(animes).isNotEmpty();

    // 2. Verifica se a lista de animes encontrada contém o anime salvo anteriormente
    Assertions.assertThat(animes).contains(animeSaved);
}
```

1. Começa criando um objeto `Anime` chamado `animeToBeSaved` que representa um anime a ser salvo no banco de dados.

2. Em seguida, salva esse anime no banco de dados usando o método `save` do repositório `animeRepository`. Isso insere o anime no banco de dados 
   para que você possa consultá-lo posteriormente.

3. Obtém o nome do anime salvo na variável `anime`.

4. Em seguida, executa uma consulta no banco de dados usando o método `findByName` do repositório `animeRepository`. Isso deve encontrar todos 
   os animes com o mesmo nome que o anime salvo anteriormente.

5. Aqui, realiza as asserções para verificar se o teste é bem-sucedido:
   - A primeira asserção verifica se a lista de animes encontrada não está vazia, o que significa que pelo menos um anime com o mesmo nome foi 
     encontrado no banco de dados.
   - A segunda asserção verifica se a lista de animes encontrada contém o anime salvo anteriormente, garantindo que o anime foi corretamente 
     armazenado e recuperado do banco de dados.

Basicamente, este teste verifica se o método `findByName` do repositório `animeRepository` é capaz de encontrar um anime pelo seu nome no banco 
de dados e se o anime encontrado é o mesmo que foi salvo anteriormente.

--------------- // ---------------

Teste que retorna uma lista vazia se não tiver o nome do anime no BD

```java
@Test
@DisplayName("Find by name returns empty list when no anime is found")
void findByName_returnsEmptyList_whenAnimeIsNotFound(){

    // Realiza uma consulta no banco de dados para encontrar animes pelo nome "outro anime"
    List<Anime> animes = this.animeRepository.findByName("outro anime");

    // Afirmações (Assertions) para verificar se o teste é bem-sucedido

    // Verifica se a lista de animes encontrada está vazia (isEmpty)
    Assertions.assertThat(animes).isEmpty();
}
```

1. Executa uma consulta no banco de dados usando o método `findByName` do repositório `animeRepository`, especificando o nome "outro anime" 
   como o critério de pesquisa.

2. A consulta será realizada no banco de dados para encontrar todos os animes com o nome "outro anime". No entanto, se não houver animes com 
   esse nome no banco de dados, a lista de resultados será vazia.

3. Em seguida, realiza uma asserção para verificar se o teste é bem-sucedido:
   - A asserção `Assertions.assertThat(animes).isEmpty()` verifica se a lista de animes encontrada está vazia. Se estiver vazia, isso significa 
     que nenhum anime foi encontrado com o nome "outro anime", o que é o resultado esperado neste caso de teste.

Basicamente, este teste verifica se o método `findByName` do repositório `animeRepository` retorna uma lista vazia quando nenhum anime com o 
nome especificado é encontrado no banco de dados. Isso é útil para garantir que o método se comporte corretamente em casos em que nenhum 
resultado é encontrado.

-------------------------------------------------------------------- // -----------------------------------------------------------------------
BDDMockito

O BDDMockito é uma extensão do Mockito, uma biblioteca amplamente usada para criar mocks em testes unitários em Java. O BDDMockito, por sua vez, 
segue o estilo BDD (Behavior-Driven Development) para escrever testes de maneira mais descritiva e legível. Ele fornece um conjunto de métodos 
e recursos que facilitam a escrita de testes com esse estilo. Alguns dos métodos mais comuns do BDDMockito:

1. `given(...).willReturn(...)`:
   - O método `given` é usado para definir um cenário de teste. Você usa `given` para configurar o comportamento esperado do mock.
   - O método `willReturn` indica o que o mock deve retornar quando o método sendo testado for chamado.

```java
given(animeRepository.findById(1L)).willReturn(Optional.of(anime));
```

Neste exemplo, estamos configurando o mock `animeRepository` para retornar um objeto `Optional` contendo um anime quando o método `findById` 
for chamado com o argumento `1L`.

2. `doNothing()`:
   - O método `doNothing` é usado para especificar que nenhuma ação deve ser executada quando um método de um mock for chamado.
   
```java
doNothing().when(animeRepository).deleteById(1L);
```

Aqui, estamos dizendo que quando o método `deleteById` for chamado com o argumento `1L`, nada deve acontecer.

3. `verify(...)`:
   - O método `verify` é usado para verificar se um método de um mock foi chamado com os argumentos corretos e o número correto de vezes.

```java
verify(animeRepository, times(1)).findById(1L);
```

Neste exemplo, estamos verificando se o método `findById` do mock `animeRepository` foi chamado exatamente uma vez com o argumento `1L`.

4. `willThrow(...)`:
   - O método `willThrow` é usado para indicar que um mock deve lançar uma exceção quando um método específico é chamado.

```java
willThrow(new RuntimeException("Erro")).given(animeRepository).save(any(Anime.class));
```

Aqui, estamos configurando o mock `animeRepository` para lançar uma exceção quando o método `save` for chamado com qualquer instância de `Anime`.

5. `any(...)`:
   - O método `any` é usado para corresponder a qualquer argumento de um tipo específico ao configurar ou verificar o comportamento de um mock.

```java
given(animeRepository.save(any(Anime.class))).willReturn(anime);
```

Neste exemplo, estamos configurando o mock `animeRepository` para retornar o objeto `anime` quando o método `save` for chamado com qualquer 
instância de `Anime`.

6. `thenReturn(...)`:
   - Usado para retornar um valor específico quando um método do mock é chamado.

```java
given(animeRepository.findById(1L)).willReturn(Optional.of(anime));
```

7. `will(...)`:
   - Permite configurar comportamentos de mocks de maneira mais flexível.

```java
will(invocation -> {
    Long id = invocation.getArgument(0);
    return id == 1L ? Optional.of(anime) : Optional.empty();
}).given(animeRepository).findById(anyLong());
```

8. `doReturn(...).when(...)`:
   - Usado para especificar o retorno de um método de mock em uma linha separada.

```java
doReturn(Optional.of(anime)).when(animeRepository).findById(1L);
```

9. `timeout(...)`:
   - Permite verificar se um método de mock foi chamado dentro de um determinado período de tempo.

```java
verify(animeRepository, timeout(100)).findById(1L);
```

10. `atLeast(...)`, `atMost(...)`, `never()`:
    - São usados para verificar se um método de mock foi chamado um número mínimo, máximo ou zero de vezes, respectivamente.

```java
verify(animeRepository, atLeast(1)).save(any(Anime.class));
verify(animeRepository, atMost(3)).findById(anyLong());
verify(animeRepository, never()).delete(any(Anime.class));
```

11. `thenThrow(...)`:
    - Usado para indicar que um mock deve lançar uma ou mais exceções quando um método é chamado.

```java
thenThrow(new RuntimeException("Erro")).given(animeRepository).deleteById(1L);
```

12. `callsRealMethods()`:
    - Usado para instruir o mock a chamar os métodos reais de uma classe parcialmente mockada.

```java
given(animeRepository.findById(1L)).willCallRealMethod();
```

Esses são apenas alguns dos métodos mais comuns disponíveis no BDDMockito. Eles ajudam a criar cenários de teste, configurar comportamentos de 
mocks e verificar interações entre o código sendo testado e os mocks de maneira mais descritiva e legível, seguindo o estilo BDD.

--------------- // ---------------

Class PageImpl

O `PageImpl` é uma classe da biblioteca Spring Data que representa uma página de resultados de consulta em uma lista paginada. Ela é 
frequentemente usada ao lidar com consultas que retornam um grande número de resultados, que precisam ser divididos em páginas menores para 
facilitar a exibição e a navegação.

A classe `PageImpl` é uma implementação de `Page`, que por sua vez estende `Slice`. Ela contém a lista de elementos da página atual, informações 
sobre a página atual, o número total de elementos e outras informações de paginação. Isso torna muito conveniente para trabalhar com resultados 
paginados ao usar o Spring Data.

Principais atributos e métodos da classe `PageImpl`:

- `content`: Essa é a lista de elementos da página atual.

- `number`: O número da página atual (começando em 0 para a primeira página).

- `size`: O tamanho da página (ou seja, o número máximo de elementos na página).

- `totalElements`: O número total de elementos em todas as páginas.

- `totalPages`: O número total de páginas.

- `hasContent()`: Verifica se a página atual contém elementos.

- `hasPrevious()`: Verifica se há uma página anterior.

- `hasNext()`: Verifica se há uma próxima página.

- `isFirst()`: Verifica se a página atual é a primeira.

- `isLast()`: Verifica se a página atual é a última.

- `nextPageable()`: Obtém o `Pageable` para a próxima página.

- `previousPageable()`: Obtém o `Pageable` para a página anterior.

Essa classe é especialmente útil quando você está construindo APIs RESTful que suportam a paginação de dados. Ela permite que você retorne 
facilmente apenas uma parte dos resultados para o cliente, tornando a aplicação mais eficiente em termos de recursos.

Exemplo de como você pode criar uma instância de `PageImpl`:

```java
List<Anime> content = /* Obtenha os elementos da página */;
Pageable pageable = PageRequest.of(pageNumber, pageSize); // pageNumber e pageSize são parâmetros da página atual
long totalElements = /* Obtenha o número total de elementos */;
Page<Anime> page = new PageImpl<>(content, pageable, totalElements);
```

Isso cria uma página de resultados `Page<Anime>` com a lista de elementos, informações de página e o número total de elementos. Você pode então 
usar essa página para retornar resultados paginados em sua API ou para realizar operações de paginação em seu serviço.

Lembre-se de que o uso efetivo de `PageImpl` depende do contexto em que você está trabalhando e das necessidades específicas de sua aplicação, 
especialmente quando se trata de consultas de banco de dados paginadas usando o Spring Data.

--------------- // ---------------

@BeforeEach
void SetUp(){
   PageImpl<Anime> animePage = new PageImpl<>(List.of(AnimeCreator.createAnimeToBeSaved()));
   BDDMockito.when(animeService.listAll(ArgumentMatchers.any())).thenReturn(animePage);
}

O script acima faz parte de um teste de unidade usando o framework Mockito no contexto do Spring Boot. Ele está configurando o comportamento de 
um serviço (no caso, `animeService`) usando a anotação `@BeforeEach`, que é executada antes de cada teste na classe de teste.

Explicação passo a passo do que esse script faz:

1. `@BeforeEach`: Esta anotação indica que o método `SetUp` deve ser executado antes de cada teste na classe de teste. Isso é útil para garantir 
    que o ambiente esteja configurado corretamente antes de cada teste, mantendo o isolamento entre os testes.

2. `PageImpl<Anime> animePage = new PageImpl<>(List.of(AnimeCreator.createAnimeToBeSaved()))`: Aqui, está sendo criada uma instância de 
   `PageImpl` que representa uma página de resultados paginados de objetos `Anime`. Ela contém uma única entrada que é criada pelo método 
   `AnimeCreator.createAnimeToBeSaved()`. Isso é feito para simular uma página de resultados com um único anime.

3. `BDDMockito.when(animeService.listAll(ArgumentMatchers.any())).thenReturn(animePage)`: Esta linha está configurando o comportamento do 
    serviço `animeService` usando o Mockito. Ela instrui o Mockito a responder à chamada do método `listAll` do `animeService` com qualquer 
    argumento (usando `ArgumentMatchers.any()`) retornando a `animePage` criada anteriormente. Em outras palavras, quando o método `listAll` 
    for chamado no serviço, ele retornará a página simulada de resultados.

A finalidade dessa configuração é simular o comportamento do serviço `animeService` durante o teste. Quando um teste que usa `animeService` for 
executado, em vez de fazer uma chamada real ao serviço, ele receberá a página de resultados simulada, permitindo assim que o teste seja isolado 
e previsível.

Em resumo, esse script está configurando o comportamento do serviço `animeService` para retornar uma página de resultados simulada durante os 
testes, garantindo que os testes sejam executados de forma controlada e independente do funcionamento real do serviço.

--------------- // ---------------

@Test
@DisplayName("List returns list of anime inside page object when successful")
void list_ReturnsListOfanimesInsidePageObject_whenSuccessful() {

  String expectedName = AnimeCreator.createValidAnime().getName();

   Page<Anime> animePage = animeController.list(null).getBody();

   Assertions.assertThat(animePage).isNotNull();
   Assertions.assertThat(animePage).isNotEmpty().hasSize(1);
   Assertions.assertThat(animePage.toList().get(0).getName()).isEqualTo(expectedName);
}

O script acima é um exemplo de um teste unitário em uma classe que testa um controlador Spring (nesse caso, `animeController`) que retorna uma 
lista de animes paginados.

Explicação passo a passo do que esse script faz:

1. `@Test`: Essa anotação marca o método como um método de teste unitário que deve ser executado pelo framework de teste (geralmente JUnit ou 
    TestNG).

2. `String expectedName = AnimeCreator.createValidAnime().getName();`: Aqui, está definindo uma variável `expectedName` para armazenar o nome 
    esperado de um anime válido. Isso é usado posteriormente para verificar se o anime retornado pelo controlador tem o nome esperado.

3. `Page<Anime> animePage = animeController.list(null).getBody();`: Nesta linha, está chamando o método `list` do `animeController`. Esse método 
    retorna uma resposta HTTP contendo uma lista de animes. Com `.getBody()`, está obtendo o corpo da resposta, que deve é um objeto 
    `Page<Anime>`.

4. `Assertions.assertThat(animePage).isNotNull();`: Aqui, está usando a biblioteca de assertivas (geralmente o AssertJ) para fazer afirmações 
    sobre o objeto `animePage`. É verifica se `animePage` não é nulo.

5. `Assertions.assertThat(animePage).isNotEmpty().hasSize(1);`: Essa linha faz duas verificações. Primeiro, ela verifica se `animePage` não 
    está vazio (ou seja, contém pelo menos um anime). Em segundo lugar, ela verifica se o tamanho da página é igual a 1, o que significa que há 
    exatamente um anime na página.

6. `Assertions.assertThat(animePage.toList().get(0).getName()).isEqualTo(expectedName);`: Aqui, está obtendo o primeiro anime da página usando 
   `animePage.toList().get(0)` e verificando se o nome desse anime é igual ao `expectedName` que definiu anteriormente. Isso verifica se o 
   anime retornado pelo controlador tem o nome esperado.

Resumindo, esse teste verifica se o método `list` do `animeController` retorna uma página de animes não nula, com pelo menos um anime, e se o 
nome desse anime é igual ao nome esperado. Isso ajuda a garantir que o endpoint do controlador esteja funcionando corretamente ao listar animes.

--------------- // ---------------

@Test
@DisplayName("List returns list of anime when successful")
void listAll_ReturnsListOfanimes_whenSuccessful() {

 String expectedName = AnimeCreator.createValidAnime().getName();

  List<Anime> listAnimes = animeController.listAll().getBody();

   Assertions.assertThat(listAnimes).isNotNull();
   Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);
   Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);
}

O script acima, marcado com `@Test` e com a anotação `@DisplayName`, testa o comportamento de um método chamado `listAll` do controlador 
`animeController`. Aqui está uma explicação passo a passo do que ele faz:

1. `@Test`: Essa anotação marca o método como um método de teste que deve ser executado pelo framework de teste (geralmente JUnit ou TestNG).

2. `@DisplayName("List returns list of anime when successful")`: Essa anotação `@DisplayName` permite que forneça um nome mais legível para o 
    teste. Neste caso, o nome do teste é "List returns list of anime when successful".

3. `String expectedName = AnimeCreator.createValidAnime().getName();`: Aqui, está definindo uma variável `expectedName` para armazenar o nome 
   esperado de um anime válido. Isso será usado posteriormente para verificar se o anime retornado pelo controlador tem o nome esperado.

4. `List<Anime> listAnimes = animeController.listAll().getBody();`: Nesta linha, você está chamando o método `listAll` do `animeController`. Esse método provavelmente retorna uma resposta HTTP contendo uma lista de animes. Com `.getBody()`, você está obtendo o corpo da resposta, que deve ser uma lista de objetos `Anime`.

5. `Assertions.assertThat(listAnimes).isNotNull();`: Aqui, está usando a biblioteca de assertivas (geralmente o AssertJ) para fazer uma 
    afirmação sobre a lista de animes (`listAnimes`). Aqui, verifica se a lista não é nula.

6. `Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);`: Esta linha faz duas verificações. Primeiro, verifica se a lista de animes não 
   está vazia (ou seja, contém pelo menos um anime). Em segundo lugar, verifica se o tamanho da lista é igual a 1, o que significa que há 
   exatamente um anime na lista.

7. `Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);`: Aqui, está obtendo o primeiro anime da lista usando 
`listAnimes.get(0)` e verificando se o nome desse anime é igual ao `expectedName` que você definiu anteriormente. Isso verifica se o anime 
retornado pelo controlador tem o nome esperado.

Em resumo, esse método de teste verifica se o método `listAll` do `animeController` retorna uma lista de animes não nula, com pelo menos um 
anime, e se o nome desse anime é igual ao nome esperado. Isso ajuda a garantir que o endpoint do controlador esteja funcionando corretamente 
ao listar todos os animes.

--------------- // ---------------

@Test
    @DisplayName("findById returns anime when successful")
    void findById_ReturnsAnime_whenSuccessful() {

       Long expectedId = AnimeCreator.createValidAnime().getId();

       Anime anime = animeController.findById(1L).getBody();

        Assertions.assertThat(anime).isNotNull();
        Assertions.assertThat(anime.getId()).isNotNull().isEqualTo(expectedId);
    }

O script acima marcado com `@Test` e com a anotação `@DisplayName`, testa o comportamento de um método chamado `findById` do controlador 
`animeController`. Aqui está uma explicação passo a passo do que ele faz:

1. `@Test`: Essa anotação marca o método como um método de teste que deve ser executado pelo framework de teste (geralmente JUnit ou TestNG).

2. `@DisplayName("findById returns anime when successful")`: Essa anotação `@DisplayName` permite que você forneça um nome mais legível para o 
    teste. Neste caso, o nome do teste é "findById returns anime when successful".

3. `Long expectedId = AnimeCreator.createValidAnime().getId();`: Aqui, está definindo uma variável `expectedId` para armazenar o ID esperado de 
    um anime válido. Isso será usado posteriormente para verificar se o anime retornado pelo controlador tem o ID esperado.

4. `Anime anime = animeController.findById(1L).getBody();`: Nesta linha está chamando o método `findById` do `animeController` com um ID 
específico (neste caso, 1L). Esse método retorna uma resposta HTTP contendo um objeto `Anime`. Com `.getBody()`, aqui, está obtendo o corpo da 
resposta, que deve ser o objeto `Anime` com o ID especificado.

5. `Assertions.assertThat(anime).isNotNull();`: Aqui, está usando a biblioteca de assertivas (geralmente o AssertJ) para fazer uma afirmação 
    sobre o objeto `anime`. Aqui, verifica se o objeto não é nulo, o que significa que um anime foi encontrado com o ID especificado.

6. `Assertions.assertThat(anime.getId()).isNotNull().isEqualTo(expectedId);`: Esta linha faz duas verificações. Primeiro, verifica se o ID do 
    anime retornado não é nulo. Em segundo lugar, verifica se o ID do anime é igual ao `expectedId` que você definiu anteriormente. Isso 
    verifica se o anime retornado pelo controlador tem o ID esperado.

Em resumo, esse método de teste verifica se o método `findById` do `animeController` retorna um objeto `Anime` não nulo, com o ID correto. Isso 
ajuda a garantir que o endpoint do controlador esteja funcionando corretamente ao buscar um anime pelo ID.

--------------- // ---------------

@Test
@DisplayName("findByNome returns a list of anime when successful")
void findByNome_ReturnsListOfAnime_whenSuccessful() {

  String expectedName = AnimeCreator.createValidAnime().getName();

   List<Anime> listAnimes = animeController.findByName("anime").getBody();

   Assertions.assertThat(listAnimes).isNotNull();
   Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);
   Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);
}

O script acima também testa o comportamento de um método no controlador `animeController`. Vamos explicar passo a passo o que esse teste faz:

1. `@Test`: Essa anotação marca o método como um método de teste que deve ser executado durante os testes automatizados.

2. `@DisplayName("findByNome returns a list of anime when successful")`: A anotação `@DisplayName` permite fornecer um nome mais descritivo para 
   o teste. Neste caso, o nome é "findByNome returns a list of anime when successful".

3. `String expectedName = AnimeCreator.createValidAnime().getName();`: Aqui, está definindo uma variável `expectedName` para armazenar o nome 
    esperado de um anime válido. Isso será usado posteriormente para verificar se o anime retornado pelo controlador tem o nome esperado.

4. `List<Anime> listAnimes = animeController.findByName("anime").getBody();`: Esta linha está chamando o método `findByName` do `animeController` 
    com o argumento "anime". O método retornará uma resposta HTTP que contém uma lista de objetos `Anime`. O `.getBody()` é usado para obter o 
    corpo da resposta, que deve ser a lista de animes.

5. `Assertions.assertThat(listAnimes).isNotNull();`: Aqui, está usando as asserções da biblioteca (provavelmente AssertJ) para verificar se a 
    lista de animes (`listAnimes`) não é nula. Isso garante que a chamada ao método `findByName` do controlador tenha retornado uma lista 
    válida.

6. `Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);`: Esta linha faz duas verificações. Primeiro, ela verifica se a lista de animes
    não está vazia, ou seja, contém pelo menos um anime. Em segundo lugar, ela verifica se a lista tem tamanho igual a 1. Isso indica que apenas 
    um anime foi encontrado com o nome "anime".

7. `Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);`: Aqui, está verificando se o nome do primeiro anime na lista 
    (`listAnimes.get(0).getName()`) é igual ao `expectedName` que definiu anteriormente. Isso garante que o anime retornado pelo controlador 
    tenha o nome esperado.

Resumindo, esse teste verifica se o método `findByName` do `animeController` retorna uma lista não nula de animes, contendo pelo menos um anime 
com o nome esperado. Isso ajuda a garantir que o endpoint do controlador esteja funcionando corretamente ao buscar animes pelo nome.

--------------- // ---------------

@Test
@DisplayName("findByNome returns an empty list of anime is not found")
void findByNome_ReturnsEmptyListOfAnime_whenIsNotFound() {

   BDDMockito.when(animeService.findByName(ArgumentMatchers.anyString()))
       .thenReturn(Collections.emptyList()); 

   List<Anime> listAnimes = animeController.findByName("anime").getBody();

   Assertions.assertThat(listAnimes).isNotNull();
   Assertions.assertThat(listAnimes).isEmpty();
}

O método de teste acima verifica o comportamento de um endpoint em que o serviço `animeService` retorna uma lista vazia quando não encontra 
nenhum anime com o nome especificado. Vamos analisar cada parte do script:

1. `void findByNome_ReturnsEmptyListOfAnime_whenIsNotFound()`: Este é um método de teste semelhante aos outros, mas com um foco específico. Ele 
    testa o cenário em que nenhum anime é encontrado com o nome especificado.

2. `BDDMockito.when(animeService.findByName(ArgumentMatchers.anyString()))`: Aqui, está usando o framework Mockito (com a extensão BDDMockito) 
    para criar um comportamento simulado. Aqui, está dizendo que quando o método `findByName` do `animeService` for chamado com qualquer 
    argumento de string (`ArgumentMatchers.anyString()`), ele deve retornar uma lista vazia (`Collections.emptyList()`).

3. `List<Anime> listAnimes = animeController.findByName("anime").getBody();`: Nesta linha, está chamando o método `findByName` do 
    `animeController` com o argumento "anime". O método provavelmente retornará uma resposta HTTP que contém uma lista de objetos `Anime`. 
    Aqui, está pegando o corpo da resposta usando `.getBody()` e armazenando-o na variável `listAnimes`.

4. `Assertions.assertThat(listAnimes).isNotNull();`: Aqui, está usando as asserções para verificar se a lista de animes (`listAnimes`) não é 
    nula. Isso garante que a chamada ao método `findByName` do controlador tenha retornado uma resposta válida.

5. `Assertions.assertThat(listAnimes).isEmpty();`: Esta linha verifica se a lista de animes está vazia. Isso é esperado neste cenário, pois 
    configurou o `animeService` para retornar uma lista vazia quando não encontra nenhum anime com o nome especificado.

Em resumo, esse teste garante que o endpoint do controlador `animeController` lida adequadamente com a situação em que nenhum anime é encontrado 
com o nome especificado e retorna uma lista vazia como resposta.

--------------- // ---------------

@Test
@DisplayName("save returns anime when successful")
void save_ReturnsAnime_whenSuccessful() {

  Anime anime = animeController.save(AnimePostRequestBodyCreator.createAnimePostRequestBody()).getBody();
  Assertions.assertThat(anime).isNotNull().isEqualTo(AnimeCreator.createValidAnime());  
}

O método acima de teste verifica o comportamento de um endpoint em que o serviço `animeController` cria e salva um novo anime com sucesso. 
Vamos analisar cada parte do script:

1. `@Test`: Essa anotação marca o método como um método de teste para o JUnit. Isso significa que o método será executado como parte do processo 
    de teste.

2. `@DisplayName("save returns anime when successful")`: Essa anotação fornece um nome personalizado para o teste que será exibido nos relatórios 
    de teste. Neste caso, o nome personalizado é "save returns anime when successful", que descreve o comportamento esperado do teste.

3. `void save_ReturnsAnime_whenSuccessful()`: Este é o método de teste em si. Ele testa se o endpoint de salvar um anime no `animeController` 
   retorna um anime quando a operação é bem-sucedida.

4. `Anime anime = animeController.save(AnimePostRequestBodyCreator.createAnimePostRequestBody()).getBody();`: Nesta linha, está chamando o 
    método `save` do `animeController` e passando um objeto `AnimePostRequestBody` criado pelo método `createAnimePostRequestBody` como 
    argumento. A chamada ao método `getBody()` obtém o corpo da resposta HTTP, que deve conter o anime criado.

5. `Assertions.assertThat(anime)`: Esta linha inicia uma série de verificações usando asserções do AssertJ. 

6. `isNotNull()`: Verifica se o anime retornado não é nulo, ou seja, se foi criado e retornado com sucesso.

7. `isEqualTo(AnimeCreator.createValidAnime())`: Verifica se o anime retornado é igual ao anime válido criado previamente com 
   `AnimeCreator.createValidAnime()`. Isso garante que os dados do anime retornado coincidam com os dados esperados.

Em resumo, esse teste verifica se o endpoint do `animeController` é capaz de criar e retornar um anime com sucesso quando os dados são 
fornecidos corretamente. Ele verifica se o objeto anime retornado não é nulo e se seus atributos correspondem aos valores esperados.

--------------- // ---------------

void replace_UpdatesAnime_whenSuccessful() {

   Assertions.assertThatCode(() -> animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody())).doesNotThrowAnyException();

   ResponseEntity<Void> entity = animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody());

   Assertions.assertThat(entity).isNotNull();  
   Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);
}

O script acima é um exemplo de um teste de unidade em que você está testando o método `replace` de um controlador chamado `animeController`. 
Vou explicar cada parte do script:

1. `Assertions.assertThatCode(() -> animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody())).doesNotThrowAnyException();`:
   - Este trecho de código usa o AssertJ para verificar se a chamada do método `replace` não lança nenhuma exceção (`doesNotThrowAnyException`). 
     Isso é uma forma de testar se o método é executado com sucesso e não gera exceções inesperadas.

2. `ResponseEntity<Void> entity = animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody());`:
   - Aqui, o método `replace` do `animeController` é chamado novamente para obter a resposta (uma instância de `ResponseEntity<Void>`) após o 
     primeiro teste para verificar o status da resposta.

3. `Assertions.assertThat(entity).isNotNull();`:
   - Verifica se a variável `entity` (a resposta da chamada do método `replace`) não é nula. Isso garante que a chamada do método tenha 
     retornado uma resposta.

4. `Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);`:
   - Verifica se o código de status da resposta (`entity.getStatusCode()`) é igual a `HttpStatus.NO_CONTENT`. Isso verifica se a resposta 
     indica que a operação foi bem-sucedida e não retornou conteúdo (um código de status 204).

Basicamente, esse teste está verificando se o método `replace` do `animeController` pode ser chamado com sucesso sem lançar exceções, se ele 
retorna uma resposta não nula e se essa resposta tem um código de status `HttpStatus.NO_CONTENT`. Isso é útil para garantir que o método esteja 
funcionando conforme o esperado e que as atualizações de anime sejam tratadas corretamente.

--------------- // ---------------

void delete_RemovesAnime_whenSuccessful() {

   Assertions.assertThatCode(() -> animeController.delete(1L)).doesNotThrowAnyException();

   ResponseEntity<Void> entity = animeController.delete(1L);

   Assertions.assertThat(entity).isNotNull();  
   Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);
}

O script acima é um exemplo de um teste de unidade que verifica o comportamento do método `delete` de um controlador chamado `animeController`. 
Vou explicar cada parte do script:

1. `Assertions.assertThatCode(() -> animeController.delete(1L)).doesNotThrowAnyException();`:
   - Neste trecho, o AssertJ é usado para verificar se a chamada do método `delete` não lança nenhuma exceção (`doesNotThrowAnyException`). Isso 
     é uma forma de testar se o método é executado com sucesso e não gera exceções inesperadas.

2. `ResponseEntity<Void> entity = animeController.delete(1L);`:
   - Aqui, o método `delete` do `animeController` é chamado novamente para obter a resposta (uma instância de `ResponseEntity<Void>`) após o 
     primeiro teste para verificar o status da resposta.

3. `Assertions.assertThat(entity).isNotNull();`:
   - Verifica se a variável `entity` (a resposta da chamada do método `delete`) não é nula. Isso garante que a chamada do método tenha retornado 
     uma resposta.

4. `Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);`:
   - Verifica se o código de status da resposta (`entity.getStatusCode()`) é igual a `HttpStatus.NO_CONTENT`. Isso verifica se a resposta 
     indica que a operação foi bem-sucedida e que o recurso foi removido com sucesso (um código de status 204).

Em resumo, este teste verifica se o método `delete` do `animeController` pode ser chamado com sucesso sem lançar exceções, se ele retorna uma 
resposta não nula e se essa resposta tem um código de status `HttpStatus.NO_CONTENT`. Isso é útil para garantir que o método esteja funcionando 
conforme o esperado e que a remoção de um anime seja tratada corretamente.

--------------- // ---------------

@DisplayName("Save throw ConstraintViolationException_WhenNameIsEmpty")
@Test
void save_ThrowsConstraintViolationException_WhenNameIsEmpty(){

        Anime anime = new Anime();

        Assertions.assertThatExceptionOfType(ConstraintViolationException.class)
        .isThrownBy(() -> this.animeRepository.save(anime))
        .withMessageContaining("The anime name cannot be empty");

    }

O script acima é teste de unidade escrito em Java usando a biblioteca de teste JUnit e a biblioteca de assertiva AssertJ. Vou explicar o que 
está acontecendo linha por linha:

1. `void save_ThrowsConstraintViolationException_WhenNameIsEmpty() {`

   - Isso é uma declaração de um método de teste chamado `save_ThrowsConstraintViolationException_WhenNameIsEmpty`. O método de teste é 
     declarado com a palavra-chave `void` porque não retorna nenhum valor.

2. `Anime anime = new Anime();`

   - Aqui, uma nova instância da classe `Anime` é criada e armazenada na variável `anime`. Presumivelmente, a classe `Anime` representa algum 
     tipo de entidade ou objeto relacionado a animes.

3. `Assertions.assertThatExceptionOfType(ConstraintViolationException.class)`

   - Esta linha usa a biblioteca AssertJ para definir uma asserção. A função `assertThatExceptionOfType` é usada para verificar se uma exceção 
     de um tipo específico é lançada durante a execução do código dentro do bloco `isThrownBy`.

4. `.isThrownBy(() -> this.animeRepository.save(anime))`

   - Aqui, está sendo configurada uma expectativa de que a operação dentro do lambda `() -> this.animeRepository.save(anime)` lançará uma 
     exceção do tipo `ConstraintViolationException`. Essa operação estar relacionada a salvar o objeto `anime` no repositório, como um banco 
     de dados.

5. `.withMessageContaining("The anime name cannot be empty");`

   - Esta linha verifica se a mensagem de exceção lançada contém a frase "The anime name cannot be empty". Isso é útil para verificar se a 
     exceção possui uma mensagem específica associada a ela.

Resumindo, este teste de unidade verifica se a operação de salvar um objeto `anime` em algum repositório lança uma exceção do tipo 
`ConstraintViolationException` com a mensagem "The anime name cannot be empty" quando o nome do anime está vazio. Essa é uma técnica comum de 
teste para garantir que as validações e restrições estejam funcionando corretamente ao salvar objetos em um sistema.