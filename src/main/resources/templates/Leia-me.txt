public Anime findById(Long id ) {
		return   animes.stream()
				.filter(anime -> anime.getId().equals(id))
				.findFirst().orElseThrow(()-> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found"));
}


Este script é um método em Java que recebe um ID como parâmetro e busca por um objeto Anime em uma lista de animes usando programação funcional 
com Stream.

Vamos analisar o código por partes:

   public Anime findById(Long id): Esta é a declaração do método público chamado findById que retorna um objeto do tipo Anime. Ele aceita um 
   parâmetro id do tipo Long.

   return animes.stream(): Aqui, é criado um fluxo (stream) a partir da lista de animes chamada animes. Um fluxo é uma sequência de elementos 
   que pode ser processada de maneira sequencial ou paralela.

   .filter(anime -> anime.getId().equals(id)): O método filter é usado para filtrar elementos do fluxo com base em uma condição. Neste caso, 
   está filtrando os animes cujo ID seja igual ao ID passado como parâmetro.

   .findFirst(): O método findFirst retorna o primeiro elemento do fluxo que satisfaça a condição definida no filtro. Neste caso, retorna o 
   primeiro anime com o ID correspondente.

   .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found")): O método orElseThrow é usado para retornar o valor 
   presente no fluxo, caso exista. Se o fluxo estiver vazio (nenhum anime corresponde ao ID), uma exceção é lançada. No caso, uma 
   ResponseStatusException com um status HTTP BAD_REQUEST (código 400) é lançada, indicando que o anime não foi encontrado.

Portanto, esse método busca por um anime na lista de animes pelo ID usando programação funcional com Stream. Se o anime for encontrado, ele é 
retornado. Caso contrário, uma exceção é lançada indicando que o anime não foi encontrado.

É importante notar que o código pressupõe a existência de uma lista de animes chamada animes que contém os objetos Anime a serem pesquisados. 
Além disso, a classe Anime deve ter um método getId() para acessar o ID do anime. A exceção ResponseStatusException é lançada com base no 
framework Spring Web para lidar com respostas HTTP em APIs.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A propriedade `server.error.include-stacktrace` é uma configuração que pode ser usada em aplicações Spring Boot para controlar se as informações 
de rastreamento de pilha (stack trace) são incluídas nas respostas de erro HTTP retornadas pela aplicação em caso de exceções.

Os valores possíveis para a propriedade `server.error.include-stacktrace` são:

1. `on-param` (valor padrão):
   - Isso significa que o rastreamento de pilha é incluído na resposta somente se um parâmetro de consulta chamado `trace` estiver presente na 
     solicitação HTTP. Isso permite que você escolha se deseja ou não incluir o rastreamento de pilha nas respostas de erro, controlando-o 
     através da presença ou ausência do parâmetro de consulta.

2. `always`:
   - Isso faz com que o rastreamento de pilha seja sempre incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta específico. Isso pode ser útil para depuração e diagnóstico de problemas.

3. `never`:
   - Isso faz com que o rastreamento de pilha nunca seja incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta. Essa opção pode ser usada para ocultar informações sensíveis ou internas da aplicação nos erros retornados aos usuários.

Essa propriedade é útil para controlar o nível de detalhes das mensagens de erro retornadas pelas APIs e pode ser configurada no arquivo 
`application.properties` ou `application.yml` da sua aplicação Spring Boot. Ela pode ajudar a equilibrar a necessidade de informações detalhadas 
para depuração com a segurança e a privacidade das informações do aplicativo.

Exemplo de configuração no `application.properties`:

```properties
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server.error.include-stacktrace=on-param
```

Exemplo de configuração no `application.yml`:

```yaml
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server:
  error:
    include-stacktrace: on-param
```

Lembre-se de que essa configuração afeta a maneira como as respostas de erro são geradas e retornadas pela sua aplicação Spring Boot.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A anotação @RequestBody é uma anotação fornecida pelo Spring Framework em aplicações Spring MVC e Spring WebFlux. Ela é usada para indicar que um 
parâmetro de método em um controlador deve ser vinculado ao corpo (body) da solicitação HTTP recebida. Essa anotação é frequentemente usada ao 
criar endpoints de API que recebem dados em formato JSON ou outros formatos no corpo da solicitação.

Quando você adiciona a anotação @RequestBody a um parâmetro de método, o Spring Framework assume que os dados no corpo da solicitação HTTP devem 
ser convertidos automaticamente para o tipo do parâmetro, geralmente um objeto Java.

A anotação @RequestBody é frequentemente usada em conjunto com outros métodos do Spring Framework, como @PostMapping, @PutMapping e outros, para 
criar endpoints de API que aceitam dados no corpo da solicitação. Isso é especialmente útil em cenários de criação, atualização ou envio de 
informações em APIs RESTful.

Lembre-se de que o Spring Framework usa a biblioteca Jackson para realizar a desserialização automática de JSON para objetos Java. Portanto, é 
importante ter as dependências do Jackson configuradas em seu projeto para que a anotação @RequestBody funcione corretamente.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeService: 

```
anime.setId(ThreadLocalRandom.current().nextLong(3, 100));
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeController: 

```
return new ResponseEntity<>(HttpStatus.NO_CONTENT);
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

O HttpStatus.NO_CONTENT é um valor enumerado (enum) da classe HttpStatus fornecida pelo Spring Framework. Ele representa o status HTTP 204 
No _Content, que é uma resposta padrão usada em APIs RESTful para indicar que uma solicitação foi processada com sucesso, mas não há conteúdo 
para retornar na resposta.

Quando uma solicitação é tratada com sucesso e o servidor não precisa enviar nenhum conteúdo de volta ao cliente, o status HTTP 204 
No_ Content é usado. Isso é comum em casos onde uma solicitação de exclusão, atualização ou outra ação bem-sucedida é processada, mas 
não há necessidade de enviar um corpo de resposta.

Em termos simples, o HttpStatus.NO_CONTENT é usado para indicar que a solicitação foi bem-sucedida e não há conteúdo adicional a ser 
enviado no corpo da resposta. Isso economiza largura de banda e melhora a eficiência da comunicação entre o cliente e o servidor.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vou explicar cada parte do seu arquivo `docker-compose.yml`:

1. `version: '3.1'`: Isso define a versão da especificação do Docker Compose que você está usando. No seu caso, está usando a versão 3.1. Cada 
    versão traz diferentes recursos e sintaxe.

2. `services`: Essa seção define os serviços (ou contêineres) que você deseja executar.

   - `db`: Este é o nome do serviço. Você o nomeou como "db", que é um nome comum para um serviço de banco de dados.
   
      - `image: mysql`: Especifica a imagem do Docker que você deseja usar para esse serviço. Neste caso, está usando a imagem oficial do MySQL 
         disponível no Docker Hub.
      
      - `container_name: mysql`: Isso define o nome do contêiner que será criado. Neste caso, está definindo o nome como "mysql".
      
      - `environment`: Define variáveis ​​de ambiente para o contêiner MySQL. No caso, está definindo a senha do root do MySQL como "root".
      
      - `ports`: Especifica a mapeamento de portas entre o host e o contêiner. Aqui, você está mapeando a porta 3306 do host para a porta 3306 
         do contêiner MySQL. Isso permite que você acesse o MySQL no contêiner por meio da porta 3306 no seu computador local.
      
      - `volumes`: Define os volumes que serão montados no contêiner. Está criando um volume chamado "devdojo_data" e montando-o na pasta 
        `/var/lib/mysql` dentro do contêiner MySQL. Isso é útil para armazenar os dados do banco de dados de forma persistente, mesmo que o 
        contêiner seja destruído.
   
3. `volumes`: Esta seção define os volumes que serão usados ​​pelos serviços.

   - `devdojo_data`: Este é o nome do volume. Está definindo um volume chamado "devdojo_data", que será usado para armazenar os dados do MySQL.

Dessa forma, o Docker Compose irá criar um contêiner MySQL usando a imagem oficial do MySQL, definindo a senha do root como "root", mapeando a 
porta 3306 do host para a porta 3306 do contêiner e criando um volume chamado "devdojo_data" para armazenar os dados do MySQL de forma 
persistente. O nome do contêiner será "mysql". Isso é útil para o desenvolvimento de aplicativos que usam o MySQL, pois permite que você tenha 
um banco de dados isolado e persistente em um contêiner.

--------------- // ---------------
IMPORTANTE!!!

 -> CTRL + C ou docker-compose stop: Para parar a execução do container do docker
 -> docker-compose up: Cria e inicia os containers definidos no arquivo docker-compose.yml.
 -> docker-compose down: Para e remove os containers definidos no arquivo docker-compose.yml.
 -> docker-compose ps: Lista os containers gerenciados pelo Docker Compose.
 -> docker-compose logs: Exibe os logs dos containers gerenciados pelo Docker Compose.
 -> docker-compose build: Constrói os serviços definidos no arquivo docker-compose.yml.
 -> docker-compose start: Inicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose stop: Para os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose restart: Reinicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker ps: Lista os conatiners que estão sendo executados no momento no docker.
 -> docker ps: Lista os containers em execução no momento.
 -> docker ps -a: Lista todos os containers, incluindo os que estão parados.

 --------------- // ---------------

Explicando cada parte desse script de configuração:

```
server:
  error:
    include-stacktrace: on-param

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
```

Este é um arquivo de configuração YAML que define várias configurações para um aplicativo Spring Boot que se conecta a um banco de dados MySQL. 
Vou explicar cada seção:

1. `server:`: Esta seção permite configurar algumas propriedades do servidor embutido do Spring Boot.

   - `error:`: Aqui, está configurando o tratamento de erros. `include-stacktrace: on-param` significa que as mensagens de erro incluirão 
     informações de rastreamento de pilha (stack trace) quando você passar um parâmetro de consulta chamado `on-param`.

2. `spring:`: Esta é a seção principal de configuração relacionada ao Spring Boot.

   - `datasource:`: Aqui, está configurando o DataSource, que é usado para se conectar ao banco de dados.

     - `url`: Esta é a URL de conexão JDBC para o banco de dados MySQL. O `jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true` 
        indica que o banco de dados está localizado em `localhost` na porta `3306`. O `anime` é o nome do banco de dados. Os parâmetros 
        `useSSL=false` e `createDatabaseIfNotExists=true` configuram a conexão para não usar SSL (útil em ambientes de desenvolvimento) e para 
        criar o banco de dados automaticamente se ele não existir.

     - `username`: Define o nome de usuário para autenticação no banco de dados. Aqui, é definido como "root".

     - `password`: Define a senha para autenticação no banco de dados. Aqui, é definido como "root".

   - `jpa:`: Esta é a seção de configuração relacionada à JPA (Java Persistence API), que é usada para trabalhar com persistência de dados em Java.

     - `hibernate:`: Configurações específicas do Hibernate, que é a implementação JPA padrão do Spring Boot.

       - `ddl-auto`: Essa propriedade controla como o Hibernate gerencia o esquema do banco de dados. No valor "update", o Hibernate tentará 
          atualizar automaticamente o esquema do banco de dados com base nas mudanças nas entidades (classes de modelo) do seu aplicativo. Isso 
          é útil durante o desenvolvimento, pois permite que você faça alterações nas suas entidades sem precisar recriar manualmente as tabelas 
          no banco de dados.

Em resumo, esse arquivo de configuração define como o Spring Boot se conectará a um banco de dados MySQL, configurações do Hibernate para 
atualização automática do esquema e algumas configurações de tratamento de erros. Certifique-se de substituir os valores de `username` e 
`password` por valores seguros e adequados para seu ambiente de desenvolvimento ou produção.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos Criar uma Classe DTO AnimePostRequestBody, uma classe DTO (Data Transfer Object) é um padrão de projeto usado no desenvolvimento de 
software para transferir dados entre diferentes partes de um sistema. Ela é uma classe simples que contém campos para armazenar dados e pode
incluir métodos para acessar e manipular esses dados. O principal objetivo de uma classe DTO é encapsular os dados e permitir sua transferência 
eficiente entre diferentes componentes de um sistema, muitas vezes em cenários onde a estrutura dos dados entre esses componentes é diferente.

Os DTOs são frequentemente usados em aplicações que seguem uma arquitetura em camadas, como as aplicações baseadas em microservices, onde 
diferentes partes do sistema podem ter diferentes necessidades de dados e formatos de representação. Eles ajudam a evitar o vazamento de 
abstrações de dados e a reduzir o acoplamento entre as camadas.

Algumas razões pelas quais você pode querer usar DTOs incluem:

1. **Redução de tráfego de rede**: Quando você precisa transferir dados entre um cliente e um servidor, ou entre microservices, pode ser mais 
   eficiente transferir apenas os dados necessários para a operação em vez de todos os campos de uma entidade completa.

2. **Mapeamento entre objetos**: Em um sistema, você pode ter diferentes representações de um objeto para diferentes partes da aplicação 
   (por exemplo, uma representação completa para exibição na interface do usuário e uma representação resumida para APIs). DTOs ajudam a mapear 
   essas diferentes representações.

3. **Segurança**: Em certos casos, você pode querer ocultar certos campos sensíveis ou confidenciais de uma entidade ao transferir dados. DTOs 
   permitem que você selecione apenas os campos necessários para transferência.

4. **Evolução do sistema**: DTOs também permitem que você evolua diferentes partes do sistema independentemente umas das outras. Se a estrutura 
   interna de uma entidade mudar, você pode ajustar apenas o mapeamento entre a entidade e seus DTOs correspondentes, sem afetar a camada que 
   consome esses DTOs.

5. **Aumento de performance**: Em algumas situações, especialmente quando você lida com grandes volumes de dados, o uso de DTOs específicos para 
   as operações pode melhorar a performance, reduzindo a quantidade de dados transferidos e simplificando o processamento.

Lembre-se de que a criação de DTOs adiciona alguma complexidade ao código, pois você terá que gerenciar o mapeamento entre as entidades do 
domínio e os DTOs. Portanto, é importante considerar cuidadosamente se o uso de DTOs é apropriado para o seu caso de uso.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Builder

A anotação `@Builder` é uma anotação do projeto Lombok, uma biblioteca popular para reduzir a verbosidade do código em Java. A anotação `@Builder` 
é usada para gerar automaticamente um padrão de criação de objetos imutáveis usando o padrão Builder. Ela é frequentemente usada em conjunto com 
outras anotações do Lombok, como `@Data` ou `@Value`.

Quando você anota uma classe com `@Builder`, o Lombok cria automaticamente um padrão de construção fluent para a classe, permitindo que você 
crie instâncias dessa classe com mais facilidade e clareza.

Aqui está um exemplo simples de como você usaria a anotação `@Builder`:

```
import lombok.Builder;

@Builder
public class Person {
    private String firstName;
    private String lastName;
    private int age;
}
```

Com essa anotação, o Lombok automaticamente cria um construtor privado na classe `Person` e uma classe interna chamada `PersonBuilder`. Isso 
permite que você crie instâncias de `Person` usando um padrão fluente, como este:

```
Person person = Person.builder()
    .firstName("John")
    .lastName("Doe")
    .age(30)
    .build();
```

Isso ajuda a melhorar a legibilidade do código ao criar objetos com muitos campos, eliminando a necessidade de criar diversos construtores ou 
utilizar construtores telescópicos (com muitos parâmetros) que podem se tornar difíceis de entender.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Framework de Mapeamento MapStruct

O MapStruct é uma biblioteca que simplifica o processo de mapeamento entre objetos Java. Ele gera automaticamente o código de mapeamento 
eficiente em tempo de compilação com base nas definições de mapeamento que você especifica em interfaces anotadas com @Mapper. O objetivo 
principal do MapStruct é evitar a necessidade de escrever manualmente o código de mapeamento repetitivo e suscetível a erros, reduzindo a 
complexidade e o esforço envolvidos nesse processo.

Aqui estão os conceitos-chave e como você pode usar o MapStruct para realizar mapeamentos entre objetos:

Definindo Interfaces @Mapper:
Você cria interfaces Java anotadas com @Mapper para definir as regras de mapeamento entre os tipos de objetos. Essas interfaces podem conter 
métodos de mapeamento. O MapStruct gera automaticamente a implementação desses métodos com base nas configurações de mapeamento que você fornece.

Mapeamento Automático:
O MapStruct tenta mapear automaticamente os campos com nomes correspondentes e tipos compatíveis. Por exemplo, se você tiver um campo chamado 
nome em ambas as classes de origem e destino, o MapStruct mapeará automaticamente esses campos.

Configuração de Mapeamento Personalizado:
Em alguns casos, você pode precisar de mapeamento personalizado entre campos com nomes diferentes ou tipos incompatíveis. Você pode usar a 
anotação @Mapping para configurar o mapeamento personalizado. Isso permite que você especifique como os campos devem ser mapeados.

Injeção de Dependência (Spring Integration):
Com a configuração apropriada, o MapStruct pode gerar implementações que podem ser facilmente injetadas como beans gerenciados pelo Spring 
Framework. Isso é útil para obter benefícios do Spring, como gerenciamento de ciclo de vida e transações.

Processadores de Anotações:
O MapStruct utiliza processadores de anotações para gerar o código de mapeamento em tempo de compilação. Para usar o MapStruct, você precisa 
adicionar a dependência do MapStruct ao seu projeto e configurar a anotação @Mapper em suas interfaces de mapeamento.

 --------------- // ---------------

Instalação no Maven 
https://mapstruct.org/documentation/installation/

Vamos abordar a tag <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> que fica dentro da propriedade. Essa tag define o mapstruct e a 
versão (1.5.5.Final) a ser utilizada. 

A tag <org.mapstruct.version> é uma propriedade definida no arquivo pom.xml do projeto Maven. Ela é usada para armazenar a versão da biblioteca 
MapStruct que deseja usar em seu projeto. Ao definir essa propriedade, você pode facilmente atualizar a versão do MapStruct em um único lugar, o 
que torna mais conveniente e consistente o controle da versão da biblioteca em todo o projeto.

Detalhes sobre a tag <org.mapstruct.version>:

<org.mapstruct.version>: Isso indica o início da definição da propriedade. O nome da propriedade segue a convenção usual de utilizar a estrutura 
<groupId>.<artifactId>, substituindo os pontos por traços (-).

1.5.5.Final: Este é o valor atribuído à propriedade, que representa a versão específica do MapStruct que você deseja usar em seu projeto.

A tag <path> dentro da configuração do plugin Maven maven-compiler-plugin é usada para especificar os caminhos para os processadores de anotações 
que serão usados durante a compilação. No contexto do MapStruct, o processador de anotações é responsável por gerar automaticamente o código de 
mapeamento com base nas interfaces de mapeamento que você define.

Detalhes sobre os valores especificados dentro da tag <path>:

<groupId>org.mapstruct</groupId>: Este é o identificador de grupo (Group ID) da biblioteca MapStruct no repositório Maven. Ele identifica 
exclusivamente a organização ou projeto responsável pela biblioteca.

<artifactId>mapstruct-processor</artifactId>: Este é o identificador de artefato (Artifact ID) da biblioteca MapStruct no repositório Maven. Ele 
identifica o nome específico da biblioteca.

<version>${org.mapstruct.version}</version>: Esta é a versão do MapStruct que será usada como processador de anotações durante a compilação. O 
${org.mapstruct.version} é uma referência a uma propriedade definida no seu arquivo pom.xml para especificar a versão do MapStruct que  deseja 
usar.

A configuração da tag <path> informa ao Maven onde encontrar o processador de anotações do MapStruct. Quando o Maven executa o processo de 
compilação, ele identifica os processadores de anotações no caminho especificado e os aplica para gerar o código necessário.

No geral, essa configuração é crucial para garantir que o MapStruct funcione corretamente durante a compilação, gerando o código de mapeamento 
automaticamente com base nas interfaces definidas. 

--------------- // ---------------

Anotação `@Mapper` -> @Mapper(componentModel = "spring")

A anotação `@Mapper` com o parâmetro `componentModel = "spring"`. A anotação `@Mapper` faz parte da biblioteca MapStruct, que é uma ferramenta 
de geração automática de código usada para simplificar a implementação de mapeamentos entre objetos Java. A configuração 
`componentModel = "spring"` é uma das formas de integrar o MapStruct com o framework Spring.

Aqui estão os pontos principais sobre o uso dessa anotação:

1. **MapStruct Overview:**
   O MapStruct permite que você defina interfaces anotadas com `@Mapper` para definir os mapeamentos entre diferentes tipos de objetos. Em vez 
   de escrever manualmente o código de mapeamento, o MapStruct gera automaticamente o código de mapeamento eficiente em tempo de compilação.

2. **`@Mapper` Anotação:**
   A anotação `@Mapper` é colocada em uma interface que você cria para definir os métodos de mapeamento. Esses métodos de mapeamento devem ter a 
   assinatura apropriada, mapeando atributos de um objeto para outro. O MapStruct gera a implementação desses métodos.

3. **`componentModel = "spring"`:**
   O parâmetro `componentModel` na anotação `@Mapper` permite a integração direta com o Spring Framework. Quando definido como `spring`, 
   o MapStruct automaticamente cria uma implementação gerenciada pelo Spring para a interface anotada com `@Mapper`. Isso significa que você 
   pode injetar essa interface mapeadora onde for necessário no seu código Spring.

4. **Vantagens do Uso do Spring com o MapStruct:**
   - Injeção de dependência fácil: Como o MapStruct gera uma implementação gerenciada pelo Spring, você pode injetar essa implementação em outras 
     partes do seu código.
   - Uso natural de recursos do Spring, como transações e gerenciamento de ciclo de vida.

5. **Exemplo de Uso:**

Aqui está um exemplo qualquer que poderia usar a anotação `@Mapper` com `componentModel = "spring"`:

```
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface ProdutoMapper {
    @Mapping(target = "preco", source = "preço") // Exemplo de mapeamento personalizado
    ProdutoDTO produtoToProdutoDTO(Produto produto);
}
```

Neste exemplo, a interface `ProdutoMapper` usa a anotação `@Mapper` com `componentModel = "spring"`. O método `produtoToProdutoDTO` é responsável 
por mapear um objeto `Produto` para um objeto `ProdutoDTO`. A anotação `@Mapping` é usada para definir mapeamentos personalizados entre os 
atributos.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Em uma estrutura de projeto, o pacote "handler" geralmente é usado para agrupar classes que lidam com a manipulação de solicitações HTTP, 
especialmente aquelas que não se encaixam bem em um controlador tradicional. O uso de um pacote "handler" pode ajudar a organizar o código 
relacionado ao tratamento de solicitações específicas, além de manter os controladores mais focados nas operações principais da sua aplicação.

Aqui estão alguns cenários comuns em que um pacote "handler" pode ser usado:

1. **Tratamento de Erros Globais**: Você pode ter classes dentro do pacote "handler" que lidam com o tratamento de erros globais da aplicação. 
   Isso pode incluir a captura de exceções não tratadas e o envio de respostas de erro padronizadas.

2. **Integração com APIs Externas**: Se a sua aplicação se comunica com APIs externas, você pode criar classes no pacote "handler" para 
   encapsular a lógica de integração, como fazer chamadas HTTP, manipular respostas e lidar com erros.

3. **Autenticação e Autorização Personalizadas**: Se você precisa de lógica personalizada para autenticação e autorização, pode criar classes no 
   pacote "handler" para lidar com essas responsabilidades.

4. **Validação de Dados**: Se você tem validações de dados específicas que não se encaixam nas anotações de validação padrão do Spring, pode 
   criar classes no pacote "handler" para lidar com essa validação.

5. **Conversão de Formatos**: Se você precisa converter dados de um formato para outro, como manipular dados XML ou JSON, pode criar classes no 
   pacote "handler" para essa conversão.

6. **Tarefas Agendadas**: Se você tem tarefas agendadas que precisam ser executadas em intervalos específicos, pode criar classes no pacote 
   "handler" para lidar com essas tarefas.

Lembre-se de que não existe uma regra estrita para o que deve ser colocado em um pacote "handler". A nomenclatura e a organização do seu projeto 
podem variar com base nas melhores práticas adotadas pela sua equipe e nas necessidades específicas da aplicação. O objetivo é manter o código 
organizado e fácil de entender, agrupando funcionalidades relacionadas em pacotes lógicos.

--------------- // ---------------

Anotação `@ControllerAdvice`

A anotação `@ControllerAdvice` é uma anotação do Spring Framework que permite definir classes que fornecem tratamento global para exceções em 
toda a aplicação. Essas classes são conhecidas como "global exception handlers" (manipuladores globais de exceção) e têm a capacidade de 
centralizar a lógica de tratamento de exceções, evitando a duplicação de código em diversos pontos do código.

Aqui estão as principais funcionalidades e usos da anotação `@ControllerAdvice`:

1. **Tratamento Global de Exceções**: Ao anotar uma classe com `@ControllerAdvice`, você pode definir métodos que capturam exceções específicas 
   ou genéricas e fornecem um tratamento unificado para elas.

2. **Centralização de Lógica**: Com um "controller advice", você pode centralizar a lógica de tratamento de exceções em um único local. Isso 
   evita que você precise repetir o mesmo código de tratamento de exceções em vários controladores.

3. **Respostas Personalizadas de Erro**: Com `@ControllerAdvice`, você pode personalizar as respostas de erro, como definir códigos de status, 
   mensagens de erro e outros detalhes da resposta.

4. **Tratamento de Exceções de Validação**: Você pode usar `@ControllerAdvice` para lidar com exceções de validação, como as lançadas quando 
   dados inválidos são enviados para os controladores.

5. **Tratamento de Exceções de Formato**: Se a aplicação recebe dados em formatos diversos (JSON, XML, etc.), você pode usar `@ControllerAdvice` 
   para lidar com exceções de conversão e formatação.

6. **Integração com Exceções Personalizadas**: Você pode criar exceções personalizadas para cenários específicos da sua aplicação e definir 
   tratamento específico para essas exceções usando `@ControllerAdvice`.

--------------- // ---------------

A anotação @ExceptionHandler é uma anotação do Spring Framework que indica um método que deve ser invocado para lidar com uma exceção específica 
lançada durante a execução de um controlador. Essa anotação é comumente usada em conjunto com a anotação @ControllerAdvice para definir 
tratamentos globais de exceção ou tratamentos específicos para determinados controladores.

No contexto da anotação @ExceptionHandler(BadRequestException.class), o que acontece é:

 1. @ExceptionHandler: Indica que o método anotado é responsável por tratar uma exceção específica.

 2. (BadRequestException.class): Isso especifica qual exceção o método deve tratar. No exemplo, BadRequestException.class é uma classe de 
    exceção que representa uma situação em que ocorreu uma requisição inválida (código de status HTTP 400 Bad Request).