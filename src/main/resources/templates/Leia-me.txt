public Anime findById(Long id ) {
		return   animes.stream()
				.filter(anime -> anime.getId().equals(id))
				.findFirst().orElseThrow(()-> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found"));
}


Este script é um método em Java que recebe um ID como parâmetro e busca por um objeto Anime em uma lista de animes usando programação funcional 
com Stream.

Vamos analisar o código por partes:

   public Anime findById(Long id): Esta é a declaração do método público chamado findById que retorna um objeto do tipo Anime. Ele aceita um 
   parâmetro id do tipo Long.

   return animes.stream(): Aqui, é criado um fluxo (stream) a partir da lista de animes chamada animes. Um fluxo é uma sequência de elementos 
   que pode ser processada de maneira sequencial ou paralela.

   .filter(anime -> anime.getId().equals(id)): O método filter é usado para filtrar elementos do fluxo com base em uma condição. Neste caso, 
   está filtrando os animes cujo ID seja igual ao ID passado como parâmetro.

   .findFirst(): O método findFirst retorna o primeiro elemento do fluxo que satisfaça a condição definida no filtro. Neste caso, retorna o 
   primeiro anime com o ID correspondente.

   .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found")): O método orElseThrow é usado para retornar o valor 
   presente no fluxo, caso exista. Se o fluxo estiver vazio (nenhum anime corresponde ao ID), uma exceção é lançada. No caso, uma 
   ResponseStatusException com um status HTTP BAD_REQUEST (código 400) é lançada, indicando que o anime não foi encontrado.

Portanto, esse método busca por um anime na lista de animes pelo ID usando programação funcional com Stream. Se o anime for encontrado, ele é 
retornado. Caso contrário, uma exceção é lançada indicando que o anime não foi encontrado.

É importante notar que o código pressupõe a existência de uma lista de animes chamada animes que contém os objetos Anime a serem pesquisados. 
Além disso, a classe Anime deve ter um método getId() para acessar o ID do anime. A exceção ResponseStatusException é lançada com base no 
framework Spring Web para lidar com respostas HTTP em APIs.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A propriedade `server.error.include-stacktrace` é uma configuração que pode ser usada em aplicações Spring Boot para controlar se as informações 
de rastreamento de pilha (stack trace) são incluídas nas respostas de erro HTTP retornadas pela aplicação em caso de exceções.

Os valores possíveis para a propriedade `server.error.include-stacktrace` são:

1. `on-param` (valor padrão):
   - Isso significa que o rastreamento de pilha é incluído na resposta somente se um parâmetro de consulta chamado `trace` estiver presente na 
     solicitação HTTP. Isso permite que você escolha se deseja ou não incluir o rastreamento de pilha nas respostas de erro, controlando-o 
     através da presença ou ausência do parâmetro de consulta.

2. `always`:
   - Isso faz com que o rastreamento de pilha seja sempre incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta específico. Isso pode ser útil para depuração e diagnóstico de problemas.

3. `never`:
   - Isso faz com que o rastreamento de pilha nunca seja incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta. Essa opção pode ser usada para ocultar informações sensíveis ou internas da aplicação nos erros retornados aos usuários.

Essa propriedade é útil para controlar o nível de detalhes das mensagens de erro retornadas pelas APIs e pode ser configurada no arquivo 
`application.properties` ou `application.yml` da sua aplicação Spring Boot. Ela pode ajudar a equilibrar a necessidade de informações detalhadas 
para depuração com a segurança e a privacidade das informações do aplicativo.

Exemplo de configuração no `application.properties`:

```properties
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server.error.include-stacktrace=on-param
```

Exemplo de configuração no `application.yml`:

```yaml
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server:
  error:
    include-stacktrace: on-param
```

Lembre-se de que essa configuração afeta a maneira como as respostas de erro são geradas e retornadas pela sua aplicação Spring Boot.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A anotação @RequestBody é uma anotação fornecida pelo Spring Framework em aplicações Spring MVC e Spring WebFlux. Ela é usada para indicar que um 
parâmetro de método em um controlador deve ser vinculado ao corpo (body) da solicitação HTTP recebida. Essa anotação é frequentemente usada ao 
criar endpoints de API que recebem dados em formato JSON ou outros formatos no corpo da solicitação.

Quando você adiciona a anotação @RequestBody a um parâmetro de método, o Spring Framework assume que os dados no corpo da solicitação HTTP devem 
ser convertidos automaticamente para o tipo do parâmetro, geralmente um objeto Java.

A anotação @RequestBody é frequentemente usada em conjunto com outros métodos do Spring Framework, como @PostMapping, @PutMapping e outros, para 
criar endpoints de API que aceitam dados no corpo da solicitação. Isso é especialmente útil em cenários de criação, atualização ou envio de 
informações em APIs RESTful.

Lembre-se de que o Spring Framework usa a biblioteca Jackson para realizar a desserialização automática de JSON para objetos Java. Portanto, é 
importante ter as dependências do Jackson configuradas em seu projeto para que a anotação @RequestBody funcione corretamente.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeService: 

```
anime.setId(ThreadLocalRandom.current().nextLong(3, 100));
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeController: 

```
return new ResponseEntity<>(HttpStatus.NO_CONTENT);
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

O HttpStatus.NO_CONTENT é um valor enumerado (enum) da classe HttpStatus fornecida pelo Spring Framework. Ele representa o status HTTP 204 
No _Content, que é uma resposta padrão usada em APIs RESTful para indicar que uma solicitação foi processada com sucesso, mas não há conteúdo 
para retornar na resposta.

Quando uma solicitação é tratada com sucesso e o servidor não precisa enviar nenhum conteúdo de volta ao cliente, o status HTTP 204 
No_ Content é usado. Isso é comum em casos onde uma solicitação de exclusão, atualização ou outra ação bem-sucedida é processada, mas 
não há necessidade de enviar um corpo de resposta.

Em termos simples, o HttpStatus.NO_CONTENT é usado para indicar que a solicitação foi bem-sucedida e não há conteúdo adicional a ser 
enviado no corpo da resposta. Isso economiza largura de banda e melhora a eficiência da comunicação entre o cliente e o servidor.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vou explicar cada parte do seu arquivo `docker-compose.yml`:

1. `version: '3.1'`: Isso define a versão da especificação do Docker Compose que você está usando. No seu caso, está usando a versão 3.1. Cada 
    versão traz diferentes recursos e sintaxe.

2. `services`: Essa seção define os serviços (ou contêineres) que você deseja executar.

   - `db`: Este é o nome do serviço. Você o nomeou como "db", que é um nome comum para um serviço de banco de dados.
   
      - `image: mysql`: Especifica a imagem do Docker que você deseja usar para esse serviço. Neste caso, está usando a imagem oficial do MySQL 
         disponível no Docker Hub.
      
      - `container_name: mysql`: Isso define o nome do contêiner que será criado. Neste caso, está definindo o nome como "mysql".
      
      - `environment`: Define variáveis ​​de ambiente para o contêiner MySQL. No caso, está definindo a senha do root do MySQL como "root".
      
      - `ports`: Especifica a mapeamento de portas entre o host e o contêiner. Aqui, você está mapeando a porta 3306 do host para a porta 3306 
         do contêiner MySQL. Isso permite que você acesse o MySQL no contêiner por meio da porta 3306 no seu computador local.
      
      - `volumes`: Define os volumes que serão montados no contêiner. Está criando um volume chamado "devdojo_data" e montando-o na pasta 
        `/var/lib/mysql` dentro do contêiner MySQL. Isso é útil para armazenar os dados do banco de dados de forma persistente, mesmo que o 
        contêiner seja destruído.
   
3. `volumes`: Esta seção define os volumes que serão usados ​​pelos serviços.

   - `devdojo_data`: Este é o nome do volume. Está definindo um volume chamado "devdojo_data", que será usado para armazenar os dados do MySQL.

Dessa forma, o Docker Compose irá criar um contêiner MySQL usando a imagem oficial do MySQL, definindo a senha do root como "root", mapeando a 
porta 3306 do host para a porta 3306 do contêiner e criando um volume chamado "devdojo_data" para armazenar os dados do MySQL de forma 
persistente. O nome do contêiner será "mysql". Isso é útil para o desenvolvimento de aplicativos que usam o MySQL, pois permite que você tenha 
um banco de dados isolado e persistente em um contêiner.

--------------- // ---------------
IMPORTANTE!!!

 -> CTRL + C ou docker-compose stop: Para parar a execução do container do docker
 -> docker-compose up: Cria e inicia os containers definidos no arquivo docker-compose.yml.
 -> docker-compose down: Para e remove os containers definidos no arquivo docker-compose.yml.
 -> docker-compose ps: Lista os containers gerenciados pelo Docker Compose.
 -> docker-compose logs: Exibe os logs dos containers gerenciados pelo Docker Compose.
 -> docker-compose build: Constrói os serviços definidos no arquivo docker-compose.yml.
 -> docker-compose start: Inicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose stop: Para os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose restart: Reinicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker ps: Lista os conatiners que estão sendo executados no momento no docker.
 -> docker ps: Lista os containers em execução no momento.
 -> docker ps -a: Lista todos os containers, incluindo os que estão parados.

 --------------- // ---------------

Explicando cada parte desse script de configuração:

```
server:
  error:
    include-stacktrace: on-param

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
```

Este é um arquivo de configuração YAML que define várias configurações para um aplicativo Spring Boot que se conecta a um banco de dados MySQL. 
Vou explicar cada seção:

1. `server:`: Esta seção permite configurar algumas propriedades do servidor embutido do Spring Boot.

   - `error:`: Aqui, está configurando o tratamento de erros. `include-stacktrace: on-param` significa que as mensagens de erro incluirão 
     informações de rastreamento de pilha (stack trace) quando você passar um parâmetro de consulta chamado `on-param`.

2. `spring:`: Esta é a seção principal de configuração relacionada ao Spring Boot.

   - `datasource:`: Aqui, está configurando o DataSource, que é usado para se conectar ao banco de dados.

     - `url`: Esta é a URL de conexão JDBC para o banco de dados MySQL. O `jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true` 
        indica que o banco de dados está localizado em `localhost` na porta `3306`. O `anime` é o nome do banco de dados. Os parâmetros 
        `useSSL=false` e `createDatabaseIfNotExists=true` configuram a conexão para não usar SSL (útil em ambientes de desenvolvimento) e para 
        criar o banco de dados automaticamente se ele não existir.

     - `username`: Define o nome de usuário para autenticação no banco de dados. Aqui, é definido como "root".

     - `password`: Define a senha para autenticação no banco de dados. Aqui, é definido como "root".

   - `jpa:`: Esta é a seção de configuração relacionada à JPA (Java Persistence API), que é usada para trabalhar com persistência de dados em Java.

     - `hibernate:`: Configurações específicas do Hibernate, que é a implementação JPA padrão do Spring Boot.

       - `ddl-auto`: Essa propriedade controla como o Hibernate gerencia o esquema do banco de dados. No valor "update", o Hibernate tentará 
          atualizar automaticamente o esquema do banco de dados com base nas mudanças nas entidades (classes de modelo) do seu aplicativo. Isso 
          é útil durante o desenvolvimento, pois permite que você faça alterações nas suas entidades sem precisar recriar manualmente as tabelas 
          no banco de dados.

Em resumo, esse arquivo de configuração define como o Spring Boot se conectará a um banco de dados MySQL, configurações do Hibernate para 
atualização automática do esquema e algumas configurações de tratamento de erros. Certifique-se de substituir os valores de `username` e 
`password` por valores seguros e adequados para seu ambiente de desenvolvimento ou produção.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos Criar uma Classe DTO AnimePostRequestBody, uma classe DTO (Data Transfer Object) é um padrão de projeto usado no desenvolvimento de 
software para transferir dados entre diferentes partes de um sistema. Ela é uma classe simples que contém campos para armazenar dados e pode
incluir métodos para acessar e manipular esses dados. O principal objetivo de uma classe DTO é encapsular os dados e permitir sua transferência 
eficiente entre diferentes componentes de um sistema, muitas vezes em cenários onde a estrutura dos dados entre esses componentes é diferente.

Os DTOs são frequentemente usados em aplicações que seguem uma arquitetura em camadas, como as aplicações baseadas em microservices, onde 
diferentes partes do sistema podem ter diferentes necessidades de dados e formatos de representação. Eles ajudam a evitar o vazamento de 
abstrações de dados e a reduzir o acoplamento entre as camadas.

Algumas razões pelas quais você pode querer usar DTOs incluem:

1. **Redução de tráfego de rede**: Quando você precisa transferir dados entre um cliente e um servidor, ou entre microservices, pode ser mais 
   eficiente transferir apenas os dados necessários para a operação em vez de todos os campos de uma entidade completa.

2. **Mapeamento entre objetos**: Em um sistema, você pode ter diferentes representações de um objeto para diferentes partes da aplicação 
   (por exemplo, uma representação completa para exibição na interface do usuário e uma representação resumida para APIs). DTOs ajudam a mapear 
   essas diferentes representações.

3. **Segurança**: Em certos casos, você pode querer ocultar certos campos sensíveis ou confidenciais de uma entidade ao transferir dados. DTOs 
   permitem que você selecione apenas os campos necessários para transferência.

4. **Evolução do sistema**: DTOs também permitem que você evolua diferentes partes do sistema independentemente umas das outras. Se a estrutura 
   interna de uma entidade mudar, você pode ajustar apenas o mapeamento entre a entidade e seus DTOs correspondentes, sem afetar a camada que 
   consome esses DTOs.

5. **Aumento de performance**: Em algumas situações, especialmente quando você lida com grandes volumes de dados, o uso de DTOs específicos para 
   as operações pode melhorar a performance, reduzindo a quantidade de dados transferidos e simplificando o processamento.

Lembre-se de que a criação de DTOs adiciona alguma complexidade ao código, pois você terá que gerenciar o mapeamento entre as entidades do 
domínio e os DTOs. Portanto, é importante considerar cuidadosamente se o uso de DTOs é apropriado para o seu caso de uso.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Builder

A anotação `@Builder` é uma anotação do projeto Lombok, uma biblioteca popular para reduzir a verbosidade do código em Java. A anotação `@Builder` 
é usada para gerar automaticamente um padrão de criação de objetos imutáveis usando o padrão Builder. Ela é frequentemente usada em conjunto com 
outras anotações do Lombok, como `@Data` ou `@Value`.

Quando você anota uma classe com `@Builder`, o Lombok cria automaticamente um padrão de construção fluent para a classe, permitindo que você 
crie instâncias dessa classe com mais facilidade e clareza.

Aqui está um exemplo simples de como você usaria a anotação `@Builder`:

```
import lombok.Builder;

@Builder
public class Person {
    private String firstName;
    private String lastName;
    private int age;
}
```

Com essa anotação, o Lombok automaticamente cria um construtor privado na classe `Person` e uma classe interna chamada `PersonBuilder`. Isso 
permite que você crie instâncias de `Person` usando um padrão fluente, como este:

```
Person person = Person.builder()
    .firstName("John")
    .lastName("Doe")
    .age(30)
    .build();
```

Isso ajuda a melhorar a legibilidade do código ao criar objetos com muitos campos, eliminando a necessidade de criar diversos construtores ou 
utilizar construtores telescópicos (com muitos parâmetros) que podem se tornar difíceis de entender.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Framework de Mapeamento MapStruct

O MapStruct é uma biblioteca que simplifica o processo de mapeamento entre objetos Java. Ele gera automaticamente o código de mapeamento 
eficiente em tempo de compilação com base nas definições de mapeamento que você especifica em interfaces anotadas com @Mapper. O objetivo 
principal do MapStruct é evitar a necessidade de escrever manualmente o código de mapeamento repetitivo e suscetível a erros, reduzindo a 
complexidade e o esforço envolvidos nesse processo.

Aqui estão os conceitos-chave e como você pode usar o MapStruct para realizar mapeamentos entre objetos:

Definindo Interfaces @Mapper:
Você cria interfaces Java anotadas com @Mapper para definir as regras de mapeamento entre os tipos de objetos. Essas interfaces podem conter 
métodos de mapeamento. O MapStruct gera automaticamente a implementação desses métodos com base nas configurações de mapeamento que você fornece.

Mapeamento Automático:
O MapStruct tenta mapear automaticamente os campos com nomes correspondentes e tipos compatíveis. Por exemplo, se você tiver um campo chamado 
nome em ambas as classes de origem e destino, o MapStruct mapeará automaticamente esses campos.

Configuração de Mapeamento Personalizado:
Em alguns casos, você pode precisar de mapeamento personalizado entre campos com nomes diferentes ou tipos incompatíveis. Você pode usar a 
anotação @Mapping para configurar o mapeamento personalizado. Isso permite que você especifique como os campos devem ser mapeados.

Injeção de Dependência (Spring Integration):
Com a configuração apropriada, o MapStruct pode gerar implementações que podem ser facilmente injetadas como beans gerenciados pelo Spring 
Framework. Isso é útil para obter benefícios do Spring, como gerenciamento de ciclo de vida e transações.

Processadores de Anotações:
O MapStruct utiliza processadores de anotações para gerar o código de mapeamento em tempo de compilação. Para usar o MapStruct, você precisa 
adicionar a dependência do MapStruct ao seu projeto e configurar a anotação @Mapper em suas interfaces de mapeamento.

 --------------- // ---------------

Instalação no Maven 
https://mapstruct.org/documentation/installation/

Vamos abordar a tag <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> que fica dentro da propriedade. Essa tag define o mapstruct e a 
versão (1.5.5.Final) a ser utilizada. 

A tag <org.mapstruct.version> é uma propriedade definida no arquivo pom.xml do projeto Maven. Ela é usada para armazenar a versão da biblioteca 
MapStruct que deseja usar em seu projeto. Ao definir essa propriedade, você pode facilmente atualizar a versão do MapStruct em um único lugar, o 
que torna mais conveniente e consistente o controle da versão da biblioteca em todo o projeto.

Detalhes sobre a tag <org.mapstruct.version>:

<org.mapstruct.version>: Isso indica o início da definição da propriedade. O nome da propriedade segue a convenção usual de utilizar a estrutura 
<groupId>.<artifactId>, substituindo os pontos por traços (-).

1.5.5.Final: Este é o valor atribuído à propriedade, que representa a versão específica do MapStruct que você deseja usar em seu projeto.

A tag <path> dentro da configuração do plugin Maven maven-compiler-plugin é usada para especificar os caminhos para os processadores de anotações 
que serão usados durante a compilação. No contexto do MapStruct, o processador de anotações é responsável por gerar automaticamente o código de 
mapeamento com base nas interfaces de mapeamento que você define.

Detalhes sobre os valores especificados dentro da tag <path>:

<groupId>org.mapstruct</groupId>: Este é o identificador de grupo (Group ID) da biblioteca MapStruct no repositório Maven. Ele identifica 
exclusivamente a organização ou projeto responsável pela biblioteca.

<artifactId>mapstruct-processor</artifactId>: Este é o identificador de artefato (Artifact ID) da biblioteca MapStruct no repositório Maven. Ele 
identifica o nome específico da biblioteca.

<version>${org.mapstruct.version}</version>: Esta é a versão do MapStruct que será usada como processador de anotações durante a compilação. O 
${org.mapstruct.version} é uma referência a uma propriedade definida no seu arquivo pom.xml para especificar a versão do MapStruct que  deseja 
usar.

A configuração da tag <path> informa ao Maven onde encontrar o processador de anotações do MapStruct. Quando o Maven executa o processo de 
compilação, ele identifica os processadores de anotações no caminho especificado e os aplica para gerar o código necessário.

No geral, essa configuração é crucial para garantir que o MapStruct funcione corretamente durante a compilação, gerando o código de mapeamento 
automaticamente com base nas interfaces definidas. 

--------------- // ---------------

Anotação `@Mapper` -> @Mapper(componentModel = "spring")

A anotação `@Mapper` com o parâmetro `componentModel = "spring"`. A anotação `@Mapper` faz parte da biblioteca MapStruct, que é uma ferramenta 
de geração automática de código usada para simplificar a implementação de mapeamentos entre objetos Java. A configuração 
`componentModel = "spring"` é uma das formas de integrar o MapStruct com o framework Spring.

Aqui estão os pontos principais sobre o uso dessa anotação:

1. **MapStruct Overview:**
   O MapStruct permite que você defina interfaces anotadas com `@Mapper` para definir os mapeamentos entre diferentes tipos de objetos. Em vez 
   de escrever manualmente o código de mapeamento, o MapStruct gera automaticamente o código de mapeamento eficiente em tempo de compilação.

2. **`@Mapper` Anotação:**
   A anotação `@Mapper` é colocada em uma interface que você cria para definir os métodos de mapeamento. Esses métodos de mapeamento devem ter a 
   assinatura apropriada, mapeando atributos de um objeto para outro. O MapStruct gera a implementação desses métodos.

3. **`componentModel = "spring"`:**
   O parâmetro `componentModel` na anotação `@Mapper` permite a integração direta com o Spring Framework. Quando definido como `spring`, 
   o MapStruct automaticamente cria uma implementação gerenciada pelo Spring para a interface anotada com `@Mapper`. Isso significa que você 
   pode injetar essa interface mapeadora onde for necessário no seu código Spring.

4. **Vantagens do Uso do Spring com o MapStruct:**
   - Injeção de dependência fácil: Como o MapStruct gera uma implementação gerenciada pelo Spring, você pode injetar essa implementação em outras 
     partes do seu código.
   - Uso natural de recursos do Spring, como transações e gerenciamento de ciclo de vida.

5. **Exemplo de Uso:**

Aqui está um exemplo qualquer que poderia usar a anotação `@Mapper` com `componentModel = "spring"`:

```
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface ProdutoMapper {
    @Mapping(target = "preco", source = "preço") // Exemplo de mapeamento personalizado
    ProdutoDTO produtoToProdutoDTO(Produto produto);
}
```

Neste exemplo, a interface `ProdutoMapper` usa a anotação `@Mapper` com `componentModel = "spring"`. O método `produtoToProdutoDTO` é responsável 
por mapear um objeto `Produto` para um objeto `ProdutoDTO`. A anotação `@Mapping` é usada para definir mapeamentos personalizados entre os 
atributos.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Em uma estrutura de projeto, o pacote "handler" geralmente é usado para agrupar classes que lidam com a manipulação de solicitações HTTP, 
especialmente aquelas que não se encaixam bem em um controlador tradicional. O uso de um pacote "handler" pode ajudar a organizar o código 
relacionado ao tratamento de solicitações específicas, além de manter os controladores mais focados nas operações principais da sua aplicação.

Aqui estão alguns cenários comuns em que um pacote "handler" pode ser usado:

1. **Tratamento de Erros Globais**: Você pode ter classes dentro do pacote "handler" que lidam com o tratamento de erros globais da aplicação. 
   Isso pode incluir a captura de exceções não tratadas e o envio de respostas de erro padronizadas.

2. **Integração com APIs Externas**: Se a sua aplicação se comunica com APIs externas, você pode criar classes no pacote "handler" para 
   encapsular a lógica de integração, como fazer chamadas HTTP, manipular respostas e lidar com erros.

3. **Autenticação e Autorização Personalizadas**: Se você precisa de lógica personalizada para autenticação e autorização, pode criar classes no 
   pacote "handler" para lidar com essas responsabilidades.

4. **Validação de Dados**: Se você tem validações de dados específicas que não se encaixam nas anotações de validação padrão do Spring, pode 
   criar classes no pacote "handler" para lidar com essa validação.

5. **Conversão de Formatos**: Se você precisa converter dados de um formato para outro, como manipular dados XML ou JSON, pode criar classes no 
   pacote "handler" para essa conversão.

6. **Tarefas Agendadas**: Se você tem tarefas agendadas que precisam ser executadas em intervalos específicos, pode criar classes no pacote 
   "handler" para lidar com essas tarefas.

Lembre-se de que não existe uma regra estrita para o que deve ser colocado em um pacote "handler". A nomenclatura e a organização do seu projeto 
podem variar com base nas melhores práticas adotadas pela sua equipe e nas necessidades específicas da aplicação. O objetivo é manter o código 
organizado e fácil de entender, agrupando funcionalidades relacionadas em pacotes lógicos.

--------------- // ---------------

Anotação `@ControllerAdvice`

A anotação `@ControllerAdvice` é uma anotação do Spring Framework que permite definir classes que fornecem tratamento global para exceções em 
toda a aplicação. Essas classes são conhecidas como "global exception handlers" (manipuladores globais de exceção) e têm a capacidade de 
centralizar a lógica de tratamento de exceções, evitando a duplicação de código em diversos pontos do código.

Aqui estão as principais funcionalidades e usos da anotação `@ControllerAdvice`:

1. **Tratamento Global de Exceções**: Ao anotar uma classe com `@ControllerAdvice`, você pode definir métodos que capturam exceções específicas 
   ou genéricas e fornecem um tratamento unificado para elas.

2. **Centralização de Lógica**: Com um "controller advice", você pode centralizar a lógica de tratamento de exceções em um único local. Isso 
   evita que você precise repetir o mesmo código de tratamento de exceções em vários controladores.

3. **Respostas Personalizadas de Erro**: Com `@ControllerAdvice`, você pode personalizar as respostas de erro, como definir códigos de status, 
   mensagens de erro e outros detalhes da resposta.

4. **Tratamento de Exceções de Validação**: Você pode usar `@ControllerAdvice` para lidar com exceções de validação, como as lançadas quando 
   dados inválidos são enviados para os controladores.

5. **Tratamento de Exceções de Formato**: Se a aplicação recebe dados em formatos diversos (JSON, XML, etc.), você pode usar `@ControllerAdvice` 
   para lidar com exceções de conversão e formatação.

6. **Integração com Exceções Personalizadas**: Você pode criar exceções personalizadas para cenários específicos da sua aplicação e definir 
   tratamento específico para essas exceções usando `@ControllerAdvice`.

--------------- // ---------------

A anotação @ExceptionHandler é uma anotação do Spring Framework que indica um método que deve ser invocado para lidar com uma exceção específica 
lançada durante a execução de um controlador. Essa anotação é comumente usada em conjunto com a anotação @ControllerAdvice para definir 
tratamentos globais de exceção ou tratamentos específicos para determinados controladores.

No contexto da anotação @ExceptionHandler(BadRequestException.class), o que acontece é:

 1. @ExceptionHandler: Indica que o método anotado é responsável por tratar uma exceção específica.

 2. (BadRequestException.class): Isso especifica qual exceção o método deve tratar. No exemplo, BadRequestException.class é uma classe de 
    exceção que representa uma situação em que ocorreu uma requisição inválida (código de status HTTP 400 Bad Request).

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação `@Transactional`

A anotação `@Transactional` é uma anotação usada no Spring Framework para controlar a transação de operações em um banco de dados. Ela define um 
escopo transacional para um método ou um conjunto de métodos, garantindo que essas operações sejam executadas de forma atômica, consistente, 
isolada e durável (princípios ACID de transações).

A anotação `@Transactional` pode ser aplicada a nível de classe ou método. Quando aplicada a nível de classe, ela se aplica a todos os métodos 
públicos da classe. Quando aplicada a nível de método, ela se aplica apenas ao método específico. Ela pode ser usada em controladores, serviços 
ou qualquer componente gerenciado pelo Spring.

Aqui estão algumas funcionalidades da anotação `@Transactional`:

1. **Atomicidade**: Todas as operações dentro do escopo transacional são tratadas como uma unidade atômica. Isso significa que todas as operações 
   são bem-sucedidas ou todas falham, evitando estados intermediários inconsistentes no banco de dados.

2. **Consistência**: A transação garante que o banco de dados esteja em um estado consistente antes e depois das operações.

3. **Isolamento**: A anotação permite controlar o nível de isolamento das transações, garantindo que as operações de uma transação não 
   interfiram nas operações de outras transações concorrentes.

4. **Durabilidade**: As alterações feitas dentro do escopo transacional são permanentes e persistem mesmo após um reinício do sistema.

Exemplo qualquer de uso:

```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
    }

    @Transactional(readOnly = true)
    public User getUserById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
```

No exemplo acima, a anotação `@Transactional` é usada nos métodos `createUser` e `getUserById` do serviço `UserService`. No método `createUser`, 
a anotação garante que a operação de salvamento no banco de dados seja tratada como uma única transação. No método `getUserById`, a anotação 
com o parâmetro `readOnly = true` define que a transação será somente para leitura, o que pode otimizar o desempenho quando não há necessidade 
de operações de gravação no banco de dados.

a anotação @Transactional pode ser usada em vários métodos da camada de serviço, incluindo os métodos de busca, atualização e exclusão. Ela 
ajuda a garantir a consistência das operações e a controlar o escopo da transação em torno dessas operações.

Além da propriedade readOnly, existem outras propriedades que podem ser usadas com a anotação @Transactional para controlar o comportamento da 
transação:

1. isolation: Define o nível de isolamento da transação. Você pode usar valores como:
   -> Isolation.DEFAULT - O nível de isolamento padrão definido pelo banco de dados ou pelo ambiente de execução. Isso geralmente equivale a 
                          Isolation.READ_COMMITTED.
   
   -> Isolation.READ_UNCOMMITTED - O nível mais baixo de isolamento. As transações podem ver alterações não confirmadas por outras transações. 
                                   Isso pode resultar em leituras sujas (dirty reads), onde as informações podem ser imprecisas.
    
   -> Isolation.READ_COMMITTED - As transações só podem ver dados confirmados por outras transações. Isso evita leituras sujas, mas ainda 
                                 permite o fenômeno de leituras não repetíveis.
                                 
   -> Isolation.REPEATABLE_READ - Garante que, uma vez que uma linha seja lida por uma transação, qualquer leitura subsequente da mesma linha 
                                  durante a mesma transação retornará o mesmo valor. Isso evita leituras não repetíveis, mas ainda permite o 
                                  fenômeno da leitura fantasma.
   
   -> Isolation.SERIALIZABLE - É o nível de isolamento mais alto. Garante que as transações ocorram como se fossem executadas uma após a outra, 
                               evitando leituras sujas, leituras não repetíveis e leituras fantasmas. No entanto, isso pode levar a um desempenho 
                               mais baixo devido ao bloqueio rigoroso.

 A escolha do nível de isolamento depende dos requisitos de consistência, desempenho e concorrência da sua aplicação. Níveis de isolamento mais 
 altos fornecem maior consistência, mas podem resultar em bloqueios e possivelmente em degradação de desempenho. Por outro lado, níveis de 
 isolamento mais baixos podem resultar em melhores desempenhos, mas podem introduzir inconsistências nos dados lidos.

2. propagation: Define a propagação da transação quando chamado a partir de outro método transacional. Valores possíveis incluem: 
   -> Propagation.REQUIRED - Esse é o valor padrão. Se um método transacional é chamado dentro de outro método que já está em uma transação, o 
                             método chamado participará da transação existente. Caso contrário, uma nova transação será criada. Isso significa 
                             que vários métodos dentro de uma mesma transação compartilham a mesma transação, e se a transação pai for revertida, 
                             todas as operações serão revertidas.
   
   -> Propagation.REQUIRES_NEW -  Esse valor garante que um novo contexto de transação seja criado para o método chamado, independentemente de 
                                  haver uma transação em andamento no método chamador. Isso cria uma transação separada para o método chamado, 
                                  isolando completamente suas operações da transação pai.
   
   -> Propagation.MANDATORY - Esse valor indica que o método deve ser chamado dentro de uma transação existente. Se não houver uma transação, 
                              uma exceção será lançada. Isso garante que um método só será executado dentro de uma transação existente.
   
   -> entre outros.

Exemplo qualquer de uso:

```
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
        updateUserStats();
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateUserStats() {
        // Atualizar estatísticas do usuário em uma nova transação independente
    }

    @Transactional(propagation = Propagation.MANDATORY)
    public User getUserById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
```
 No exemplo acima, o método createUser chama o método updateUserStats com Propagation.REQUIRED, o que significa que ambos compartilham a mesma 
 transação. O método updateUserStats utiliza Propagation.REQUIRES_NEW, criando uma nova transação. O método getUserById usa Propagation.MANDATORY, 
 garantindo que ele seja chamado apenas dentro de uma transação existente.

3. timeout: Define o tempo limite da transação em segundos. A transação será revertida se o tempo limite for excedido.

4. rollbackFor e noRollbackFor: Define as exceções que devem ou não causar o rollback da transação.

5. rollbackForClassName e noRollbackForClassName: Versões por nome das propriedades acima.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

As anotações como `@NotEmpty`, `@NotNull`, `@Min`, `@Max`, `@Size`, entre outras, fazem parte da biblioteca de validação do Bean Validation, que 
é integrada ao Spring Boot através da dependência `spring-boot-starter-validation`. Essas anotações são usadas para validar os dados de entrada 
e garantir que atendam aos critérios definidos antes de serem processados pela aplicação. Aqui estão algumas das anotações mais comuns:

1. **`@NotNull`**: Essa anotação é usada para garantir que o valor do campo não seja nulo.

2. **`@NotEmpty`**: Essa anotação é usada para garantir que uma coleção, uma string ou um array não esteja vazio ou nulo.

3. **`@NotBlank`**: Semelhante ao `@NotEmpty`, mas também verifica se a string não consiste apenas em espaços em branco.

4. **`@Min`**: Essa anotação define o valor mínimo que um campo numérico pode ter.

5. **`@Max`**: Essa anotação define o valor máximo que um campo numérico pode ter.

6. **`@Size`**: Essa anotação define o tamanho mínimo e máximo de uma coleção, string ou array.

7. **`@Pattern`**: Essa anotação permite validar uma string usando uma expressão regular.

8. **`@Email`**: Essa anotação valida se uma string é um endereço de e-mail válido.

9. **`@Valid`**: Essa anotação é usada para indicar que uma propriedade deve ser validada recursivamente. Pode ser usada, por exemplo, para validar objetos aninhados.

Exemplo de uso das anotações:

```java
public class User {

    @NotNull
    @Size(min = 2, max = 50)
    private String name;

    @NotEmpty
    @Email
    private String email;

    @Min(18)
    private int age;

    // Getters e setters
}
```

Neste exemplo, a classe `User` possui campos anotados com `@NotNull`, `@Size`, `@NotEmpty`, `@Email` e `@Min`. Quando um objeto `User` é validado 
usando o Bean Validation, as restrições definidas por essas anotações serão aplicadas para garantir que os dados atendam aos critérios 
estabelecidos. Caso contrário, exceções de validação serão lançadas, informando que os dados não estão em conformidade com as regras definidas.

--------------- // ---------------

Anotação @Valid

A anotação @Valid é uma anotação do Bean Validation que é usada para indicar que um objeto aninhado deve ser validado. Essa anotação é frequentemente usada em campos que são objetos complexos ou coleções dentro de uma classe.

Quando você coloca a anotação @Valid em um campo, o mecanismo de validação do Bean Validation verifica se o objeto contido nesse campo está em 
conformidade com as regras de validação definidas para ele. Se o objeto não for válido, as restrições definidas pelas anotações no próprio objeto 
aninhado serão aplicadas, e as exceções de validação apropriadas serão lançadas.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @SuperBuilder

A anotação @SuperBuilder faz parte do projeto Lombok, que é uma biblioteca do Java que ajuda a reduzir a quantidade de código boilerplate, como 
getters, setters, construtores e outros métodos repetitivos, tornando o código mais conciso e legível.

A anotação @SuperBuilder é usada para criar construtores fluentes em classes que herdam de outras classes. Ela é particularmente útil quando 
você está trabalhando com herança e deseja que as subclasses tenham construtores com a mesma funcionalidade da classe pai.

O uso de @SuperBuilder economiza muito código e torna mais fácil criar objetos complexos com herança. É importante notar que você precisará 
configurar o Lombok corretamente em seu projeto para usar essa anotação.

--------------- // ---------------

Anotação @Getter

A anotação @Getter faz parte do projeto Lombok, que é uma biblioteca Java que ajuda a reduzir a verbosidade do código, eliminando a necessidade 
de escrever métodos getters manualmente. Ela é usada para gerar automaticamente métodos getter para os campos (atributos) de uma classe.

A anotação @Getter é uma maneira eficiente de criar métodos getter em suas classes, economizando tempo e reduzindo a quantidade de código que 
você precisa escrever manualmente. Isso também ajuda a manter seu código mais limpo e legível.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A classe ResponseEntityExceptionHandler faz parte do framework Spring e é projetada para lidar com exceções globais em um aplicativo Spring 
Boot que produz respostas HTTP. Ela é uma classe abstrata que estende ResponseEntityExceptionHandler e fornece métodos para tratar várias 
exceções comuns, como erros de validação, exceções de servidor interno, exceções de método não suportado e muito mais.

A principal finalidade da ResponseEntityExceptionHandler é capturar exceções lançadas em seu aplicativo e transformá-las em respostas HTTP 
adequadas, que geralmente têm um formato JSON ou XML para serem consumidos por clientes da API.

Você pode personalizar o tratamento de exceções de acordo com as necessidades do seu aplicativo, adicionando métodos adicionais anotados com 
@ExceptionHandler para lidar com tipos de exceções específicos.

Em resumo, ResponseEntityExceptionHandler é uma classe útil para lidar com exceções globalmente em seu aplicativo Spring Boot e personalizar as 
respostas HTTP retornadas em caso de erros. Ela é amplamente usada para padronizar o tratamento de exceções em APIs RESTful.

Alguns dos métodos mais comuns fornecidos pela classe `ResponseEntityExceptionHandler` que são frequentemente utilizados para lidar com exceções 
em um aplicativo Spring Boot:

1. `handleExceptionInternal`: Este método é usado para lidar com exceções gerais e pode ser personalizado para gerar uma resposta HTTP 
    personalizada. É frequentemente usado para lidar com exceções não tratadas.

2. `handleMethodArgumentNotValid`: Este método lida com exceções relacionadas à validação de argumentos de métodos, geralmente lançadas quando 
    os dados de entrada não estão em conformidade com as regras de validação definidas. Ele pode ser usado em conjunto com anotações de 
    validação, como `@Valid`.

3. `handleHttpRequestMethodNotSupported`: Este método lida com exceções lançadas quando um método HTTP não é suportado em um endpoint específico. 
    Por exemplo, ao tentar acessar um endpoint com um método HTTP que não é permitido, como POST em um endpoint que só permite GET.

4. `handleHttpMediaTypeNotSupported`: Este método lida com exceções relacionadas à falta de suporte ao tipo de mídia (por exemplo, JSON, XML) 
    solicitado pelo cliente.

5. `handleHttpMediaTypeNotAcceptable`: Este método lida com exceções lançadas quando o servidor não pode produzir uma resposta no formato de 
    mídia aceitável pelo cliente.

6. `handleMissingPathVariable`: Lidar com exceções lançadas quando um caminho da URL esperado não é encontrado.

7. `handleNoHandlerFoundException`: Este método lida com exceções quando nenhum manipulador (controlador) é encontrado para a solicitação do 
    cliente.

8. `handleTypeMismatch`: Este método lida com exceções lançadas quando um valor do parâmetro não pode ser convertido para o tipo esperado.

9. `handleDataIntegrityViolation`: Usado para tratar exceções relacionadas à integridade dos dados, geralmente lançadas quando há violações de 
    restrições de chave primária ou chave única.

Estes são apenas alguns dos métodos disponíveis na classe `ResponseEntityExceptionHandler`. Você pode criar métodos personalizados adicionais 
para lidar com exceções específicas de seu aplicativo. Além disso, você pode personalizar as respostas HTTP retornadas para cada tipo de exceção, 
definindo um objeto `ResponseEntity` personalizado com o status HTTP e o corpo desejados.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Classes `Page` e `Pageable` no contexto de aplicativos Spring Data e Spring Boot:

1. **`Page`**:
   - A classe `Page` é uma parte do framework Spring Data e é usada para representar uma página de resultados de consulta em uma lista paginada 
     de elementos.
   - Ela encapsula uma lista de elementos de dados junto com informações sobre a página, como número total de páginas, número total de elementos, 
     tamanho da página e outros detalhes relacionados à paginação.
   - É frequentemente usada quando você deseja dividir grandes conjuntos de dados em partes menores para melhorar a eficiência e a usabilidade 
     de seu aplicativo.
   - O Spring Data geralmente retorna objetos `Page` como resultado de consultas que envolvem a paginação, permitindo fácil navegação pelos 
     resultados.

2. **`Pageable`**:
   - A interface `Pageable` é usada para representar informações sobre a paginação, como número da página, tamanho da página, ordenação e outros 
     detalhes relacionados à recuperação de resultados paginados.
   - Ela define métodos para acessar e configurar essas informações, permitindo que você especifique qual página de resultados deseja recuperar, 
     qual é o tamanho da página e como os resultados devem ser ordenados.
   - No Spring Data, você geralmente cria objetos `Pageable` e os passa como argumentos para métodos de consulta que suportam a paginação. Dessa 
     forma, você pode personalizar a consulta para retornar a página desejada.

Em resumo, `Page` é usada para encapsular uma página de resultados paginados, enquanto `Pageable` é usada para configurar os detalhes da 
paginação, como número da página, tamanho da página e ordenação. Essas classes são muito úteis ao lidar com grandes volumes de dados e ao criar 
consultas paginadas em aplicativos Spring Data.

O Page<Anime> é usado para representar um conjunto paginado de objetos do tipo Anime. Isso pode ser útil ao consultar grandes conjuntos de dados 
em um banco de dados e dividir os resultados em páginas para melhorar o desempenho e a usabilidade de um aplicativo.

A classe Page geralmente oferece métodos para navegar pelas páginas, acessar informações sobre a página atual, como número total de páginas, 
tamanho da página, número total de elementos, etc. Isso permite a criação de recursos de paginação em APIs ou interfaces de usuário, onde os 
resultados são exibidos em partes gerenciáveis.

--------------- // ---------------

Acessando no Postman:

Usando paginação (define qtd de páginas) - listar todos os animes
http://localhost:8080/animes?size=5

Usando paginação (define a página acessada) - listar todos os animes
http://localhost:8080/animes?size=5&page=3

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Configuration

A anotação `@Configuration` é uma das anotações fundamentais do Spring Framework e é usada para indicar que uma classe é uma classe de 
configuração. Ela desempenha um papel crucial na configuração de aplicativos Spring e na definição de beans gerenciados pelo Spring Container.

Aqui estão os principais pontos sobre a anotação `@Configuration`:

1. **O Que Faz**: A anotação `@Configuration` é usada para identificar classes que definem configurações para o aplicativo. Essas configurações 
   podem incluir definições de beans, configurações de componentes e outras configurações relacionadas ao Spring.

2. **Classes de Configuração**: As classes anotadas com `@Configuration` geralmente contêm métodos anotados com `@Bean`. Esses métodos definem 
   os beans gerenciados pelo Spring e suas configurações.

3. **Beans Gerenciados**: Os métodos anotados com `@Bean` dentro de uma classe `@Configuration` são interpretados pelo Spring como instruções 
   para criar beans gerenciados. Esses beans são inicializados e configurados pelo Spring Container e podem ser injetados em outras partes do 
   aplicativo.

4. **Substituição para XML**: A anotação `@Configuration` é frequentemente usada como uma alternativa ao uso de configurações XML para definir 
   beans. Ela oferece uma abordagem mais programática e baseada em código para a configuração do aplicativo.

5. **Escopo Singleton por Padrão**: Os beans definidos em classes anotadas com `@Configuration` têm escopo singleton por padrão. Isso significa 
   que o Spring Container cria apenas uma instância do bean e a reutiliza sempre que o bean é injetado em outras partes do aplicativo.

6. **Component Scanning**: Classes anotadas com `@Configuration` também podem ser detectadas automaticamente pelo mecanismo de varredura de 
   componentes do Spring, tornando-as elegíveis para uso como configurações.

Em resumo, a anotação `@Configuration` é uma parte fundamental da configuração baseada em Java no Spring Framework e desempenha um papel 
importante na definição e configuração de beans gerenciados pelo Spring. Ela permite que você configure seu aplicativo de forma programática, 
facilitando a organização e a manutenção do código de configuração.

--------------- // ---------------

Interface `WebMvcConfigurer`

A interface `WebMvcConfigurer` é uma parte importante do Spring Framework e é usada para configurar vários aspectos do mecanismo Spring MVC 
(Model-View-Controller) em um aplicativo web. Ela permite personalizar e ajustar o comportamento padrão do Spring MVC de acordo com as 
necessidades do seu aplicativo.

Principais funcionalidades que você pode realizar ao implementar a interface `WebMvcConfigurer`:

1. **Configuração de Controladores**: Você pode adicionar seus próprios controladores personalizados, bem como configurar controladores padrão 
   do Spring MVC.

2. **Configuração de Visualizações**: É possível definir como as visualizações são resolvidas e configurar visualizações personalizadas.

3. **Interceptadores**: Você pode adicionar interceptadores para executar código antes e depois do processamento da solicitação pelo controlador.

4. **Recursos Estáticos**: É possível configurar o tratamento de recursos estáticos, como arquivos CSS, JavaScript e imagens.

5. **Conversores e Formatadores**: Você pode registrar conversores e formatadores personalizados para mapear dados de solicitação para objetos 
   Java e vice-versa.

6. **Validação**: Você pode configurar validação personalizada para objetos de formulário.

7. **Gerenciamento de Recursos**: É possível configurar o local de armazenamento de recursos, como arquivos de upload.

8. **Configuração de Content Negotiation**: Definir regras para a negociação de conteúdo com base no cabeçalho `Accept` da solicitação.

9. **Configuração de Mapeamento de URLs**: Personalizar o mapeamento de URLs para controladores e recursos.

10. **Tratamento de Exceções**: Configurar como as exceções são tratadas e personalizar páginas de erro.

11. **Configuração do Local**: Definir o local e a codificação padrão para seu aplicativo.

Para implementar a interface `WebMvcConfigurer`, você geralmente cria uma classe de configuração que estende `WebMvcConfigurerAdapter` 
(desde o Spring 5, você pode implementar diretamente `WebMvcConfigurer`). Em seguida, você sobrescreve os métodos apropriados para personalizar 
o comportamento do Spring MVC.

Aqui está um exemplo simples de uma classe que implementa `WebMvcConfigurer` para configurar um interceptor:

```java
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor());
    }
}
```

Neste exemplo, a classe `MyWebMvcConfig` é anotada com `@Configuration` e implementa `WebMvcConfigurer`. Ela sobrescreve o método 
`addInterceptors` para adicionar um interceptor personalizado.

Em resumo, a interface `WebMvcConfigurer` fornece uma maneira flexível de personalizar o comportamento do Spring MVC em um aplicativo web. Ela 
permite que você adapte o Spring MVC para atender às necessidades específicas do seu projeto, tornando-o uma ferramenta poderosa para configurar 
a camada de controle de um aplicativo web Spring.

--------------- // ---------------

O método `addArgumentResolvers` faz parte da interface `WebMvcConfigurer` e é usado para configurar os resolutores de argumentos personalizados 
que serão usados pelo Spring MVC ao lidar com solicitações HTTP.

Em um controlador Spring MVC, os métodos podem receber argumentos que representam partes da solicitação HTTP, como parâmetros da URL, cabeçalhos 
HTTP, corpo da solicitação e muito mais. O Spring MVC usa resolutores de argumentos para converter esses componentes da solicitação em objetos 
que podem ser passados como argumentos para os métodos do controlador.

O método `addArgumentResolvers` permite que você registre resolutores de argumentos personalizados para que o Spring MVC possa usá-los ao 
processar solicitações HTTP. Isso é útil quando você deseja estender o comportamento padrão do Spring MVC para lidar com tipos de argumento 
personalizados ou quando precisa realizar alguma lógica especial durante a resolução de argumentos.

Você pode criar resolutores de argumentos personalizados para atender às necessidades específicas do seu aplicativo. Por exemplo, você pode 
criar um resolutor de argumentos que converte um cabeçalho HTTP personalizado em um objeto Java específico ou realiza alguma validação 
personalizada durante a resolução de argumentos.

Em resumo, o método `addArgumentResolvers` é usado para configurar resolutores de argumentos personalizados no Spring MVC, permitindo que você 
estenda e personalize o processamento de solicitações HTTP nos controladores.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Utilizando o Sorting para ordenar a lista por name - usando o Postman ou o Thunder Client (VSCode)
http://localhost:8080/animes?size=20&sort=name


--------------- // ---------------

Esse script faz parte da configuração de log em um aplicativo Spring que utiliza o framework Hibernate para interagir com um banco de dados. 
Essa configuração está usando o mecanismo de log SLF4J (Simple Logging Facade for Java) com uma configuração específica para o Hibernate.

Aqui está uma explicação do script:

```yaml
logging:  # Início da configuração de log
  level:  # Nível de log
    org:  # Pacote raiz para a configuração de níveis de log
      hibernate:  # Pacote Hibernate para a configuração de níveis de log
        SQL: DEBUG  # Define o nível de log DEBUG para as mensagens SQL do Hibernate
```

- `logging`: Isso marca o início da configuração de log para o aplicativo.

- `level`: Aqui você pode definir os níveis de log para diferentes pacotes ou classes do seu aplicativo.

- `org`: Este é o pacote raiz para a configuração de níveis de log. Qualquer pacote ou classe que esteja abaixo deste pacote no sistema de pacotes 
   Java será afetado por essa configuração.

- `hibernate`: Este é um subpacote do Hibernate dentro do pacote `org`. Esta configuração específica se aplica apenas ao Hibernate.

- `SQL: DEBUG`: Aqui, o nível de log DEBUG é configurado para as mensagens SQL geradas pelo Hibernate. Isso significa que o Hibernate registrará 
   mensagens de log com o nível DEBUG sempre que executar consultas SQL. Isso pode ser útil para depurar e entender o que está acontecendo no 
   banco de dados quando o Hibernate interage com ele.

Em resumo, esse script configura o nível de log DEBUG para as mensagens SQL do Hibernate. Isso permite que você veja detalhes das consultas SQL 
executadas pelo Hibernate, o que pode ser útil durante o desenvolvimento e a depuração de aplicativos que utilizam o Hibernate para persistência 
de dados.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

O que é o `RestTemplate` e como funcionam os métodos `getForEntity` e `getForObject`.

RestTemplate

O `RestTemplate` é uma classe da biblioteca Spring Framework que fornece uma maneira conveniente de interagir com serviços RESTful por meio de 
chamadas HTTP. Ele simplifica a comunicação cliente-servidor em aplicativos Java que precisam consumir serviços web RESTful.

O `RestTemplate` oferece métodos para executar operações HTTP como GET, POST, PUT e DELETE, permitindo que você faça chamadas a serviços web 
externos e manipule as respostas recebidas de maneira programática.

`getForEntity` e `getForObject`

Ambos `getForEntity` e `getForObject` são métodos do `RestTemplate` usados para fazer solicitações HTTP GET e receber uma resposta de um serviço 
REST.

1. `getForEntity`: Este método é usado quando você deseja obter informações adicionais além do corpo da resposta HTTP, como cabeçalhos e status. 
   Ele retorna uma instância de `ResponseEntity` que contém todos os detalhes da resposta, incluindo o corpo da resposta, status HTTP e cabeçalhos.

```java
ResponseEntity<T> responseEntity = restTemplate.getForEntity(url, responseType);
```

Exemplo:

```java
ResponseEntity<String> response = restTemplate.getForEntity("https://api.example.com/resource", String.class);
HttpStatus httpStatus = response.getStatusCode();
String responseBody = response.getBody();
```

2. `getForObject`: Este método é usado quando você está apenas interessado no corpo da resposta HTTP e não precisa dos cabeçalhos ou do status. 
Ele retorna diretamente o corpo da resposta como um objeto do tipo especificado.

```java
T response = restTemplate.getForObject(url, responseType);
```

Exemplo:

```java
String responseBody = restTemplate.getForObject("https://api.example.com/resource", String.class);
```

Ambos os métodos são úteis em diferentes situações, dependendo de quais informações específicas da resposta você precisa. Se você precisa de 
informações como cabeçalhos e status, use `getForEntity`. Se você só precisa do corpo da resposta, use `getForObject`.

Lembre-se de que, ao usar esses métodos, você deve tratar exceções de rede, como `RestClientException`, que podem ocorrer se houver problemas de 
conectividade com o serviço REST ou se a solicitação não for bem-sucedida. Além disso, é importante tratar possíveis exceções ao fazer o parsing 
do corpo da resposta, dependendo do tipo esperado.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

O script abaixo usa o `RestTemplate` para fazer uma chamada HTTP GET a uma URL específica e receber uma resposta que é do tipo `List<Anime>`. Vamos analisar o código linha por linha:

ResponseEntity<List<Anime>> exchange = new RestTemplate().exchange("http://localhost:8080/animes/all",
                HttpMethod.GET, null,
                new ParameterizedTypeReference<List<Anime>>() {
                });

1. `ResponseEntity<List<Anime>> exchange = new RestTemplate().exchange("http://localhost:8080/animes/all", HttpMethod.GET, null, new 
    ParameterizedTypeReference<List<Anime>>() {});`

   - `ResponseEntity<List<Anime>>`: Isso declara uma variável chamada `exchange` do tipo `ResponseEntity` que irá armazenar a resposta da 
      chamada HTTP. Neste caso, a resposta é esperada como uma lista de objetos do tipo `Anime`.

   - `new RestTemplate()`: Aqui, estamos criando uma nova instância de `RestTemplate`, que é uma classe do Spring Framework usada para fazer 
      chamadas HTTP a serviços web.

   - `.exchange("http://localhost:8080/animes/all", HttpMethod.GET, null, new ParameterizedTypeReference<List<Anime>>() {})`: Este é o método 
      `exchange` do `RestTemplate`, usado para fazer uma chamada HTTP. Vamos analisar os argumentos:

     - `"http://localhost:8080/animes/all"`: É a URL para a qual a chamada HTTP será feita. Neste caso, a URL é 
        `"http://localhost:8080/animes/all"`.

     - `HttpMethod.GET`: Indica que estamos fazendo uma chamada HTTP GET. Ou seja, estamos solicitando informações do servidor.

     - `null`: Este é o corpo da solicitação HTTP. Como estamos fazendo uma chamada GET sem enviar dados no corpo, usamos `null`.

     - `new ParameterizedTypeReference<List<Anime>>() {}`: Aqui, estamos especificando que tipo de resposta esperamos da chamada HTTP. Neste 
        caso, estamos esperando uma lista de objetos do tipo `Anime`. A classe `ParameterizedTypeReference` é usada para representar tipos 
      genéricos, como listas ou mapas com tipos específicos de elementos.

Após a execução deste script, a variável `exchange` conterá a resposta da chamada HTTP. Se a chamada for bem-sucedida, `exchange` conterá a 
lista de objetos `Anime` retornados pelo servidor. Você pode acessar os elementos da lista e outras informações, como cabeçalhos HTTP e status, 
usando métodos disponíveis em `ResponseEntity`. Por exemplo, `exchange.getBody()` lhe dará a lista de animes.

Este código é útil quando você precisa fazer chamadas HTTP a serviços web RESTful e deseja receber respostas tipadas, especialmente quando a 
resposta é uma lista ou outro tipo genérico.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

O script abaixo está usando o padrão de design **Builder** para criar uma instância da classe `Anime`. Vamos analisar cada parte:

```
Anime kingdom = Anime.builder().name("kingdom").build();
Anime kingdomSave = new RestTemplate().postForObject("http://localhost:8080/animes/", kingdom, Anime.class);
```

1. `Anime.builder()`: Aqui, você está chamando um método estático chamado `builder()` na classe `Anime`. Esse método retorna um construtor 
especial chamado de **builder** que é usado para criar objetos da classe `Anime` de maneira mais conveniente e legível.

2. `.name("kingdom")`: Uma vez que você tenha o **builder**, pode chamar métodos no builder para definir os valores dos atributos do objeto 
que deseja criar. Neste caso, você está chamando o método `name()` no builder e passando a string `"kingdom"` como argumento. Isso define o 
nome do anime como "kingdom".

3. `.build()`: Finalmente, você chama o método `build()` no **builder**. Isso cria e retorna uma instância da classe `Anime` com os atributos 
que você definiu anteriormente. O objeto resultante, neste caso, é atribuído à variável `kingdom`.

Em resumo, este script cria um objeto `Anime` com o nome definido como "kingdom" usando o padrão de design **Builder**, que é uma abordagem 
comum para construir objetos com muitos atributos opcionais ou configuráveis de maneira mais clara e concisa. O objeto resultante, `kingdom`, 
agora possui o nome "kingdom" definido como seu atributo.

Já o outro script está usando a classe `RestTemplate` para fazer uma solicitação HTTP POST e criar um novo recurso do tipo `Anime` no servidor. 
Vamos dividi-lo em partes:

1. `new RestTemplate()`: Isso cria uma instância da classe `RestTemplate`, que é uma classe fornecida pelo Spring Framework para fazer chamadas 
HTTP em aplicativos Java. O `RestTemplate` é usado para realizar operações HTTP, como POST, GET, PUT e DELETE.

2. `.postForObject("http://localhost:8080/animes/", kingdom, Anime.class)`: Aqui, você está chamando o método `postForObject()` do 
`RestTemplate`. Este método é usado para enviar uma solicitação HTTP POST para a URL especificada e esperar uma resposta que pode ser 
desserializada em um objeto Java da classe especificada (`Anime.class` neste caso).

   - `"http://localhost:8080/animes/"`: Esta é a URL de destino para a solicitação POST. Presumivelmente, esta é a URL onde seu servidor está 
       ouvindo para criar um novo recurso do tipo `Anime`.

   - `kingdom`: Este é o objeto `Anime` que você deseja enviar como parte do corpo da solicitação POST. Em outras palavras, você está enviando 
      os detalhes do anime que deseja criar no servidor.

   - `Anime.class`: Isso indica que você espera que a resposta da solicitação seja desserializada em um objeto `Anime`. Isso significa que o 
      servidor deve responder com os detalhes do anime recém-criado, e o `RestTemplate` irá transformar essa resposta em um objeto `Anime` que é armazenado na variável `kingdomSave`.

Portanto, após a execução desta linha de código, `kingdomSave` conterá os detalhes do anime recém-criado no servidor, como ID, nome, ou qualquer 
outro atributo que tenha sido configurado pelo servidor durante a criação. Isso é útil quando você deseja criar recursos no servidor por meio 
de uma solicitação HTTP POST e, em seguida, manipular ou exibir as informações retornadas pelo servidor.

--------------- // ---------------

O script abaixo cria um objeto `HttpHeaders` e o configura para indicar que o conteúdo da solicitação ou resposta HTTP é do tipo JSON 
(JavaScript Object Notation). 

```
private static HttpHeaders createJSonHeader(){
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.setContentType(MediaType.APPLICATION_JSON);
        return httpHeaders;
    }
```

Vamos analisá-lo linha por linha:

1. `HttpHeaders httpHeaders = new HttpHeaders();`: Aqui, você está criando uma instância de `HttpHeaders`, que é uma classe fornecida pelo 
Spring Framework para representar os cabeçalhos HTTP de uma solicitação ou resposta HTTP. Cada cabeçalho HTTP pode conter informações 
específicas, como o tipo de conteúdo, cookies, autenticação, etc.

2. `httpHeaders.setContentType(MediaType.APPLICATION_JSON);`: Esta linha configura o cabeçalho `Content-Type` para indicar que o conteúdo da 
solicitação ou resposta será no formato JSON. O método `setContentType` é usado para definir o tipo de conteúdo do cabeçalho.

   - `MediaType.APPLICATION_JSON`: `MediaType` é uma classe que faz parte do Spring Framework e contém várias constantes estáticas que 
      representam tipos de mídia comuns. `APPLICATION_JSON` é uma dessas constantes e representa o tipo de mídia JSON.

3. `return httpHeaders;`: Finalmente, a função retorna o objeto `HttpHeaders` configurado. Isso permite que você use esse objeto para definir 
os cabeçalhos de uma solicitação HTTP, especificando que o conteúdo é JSON. Por exemplo, você pode definir esses cabeçalhos em uma solicitação 
POST ou PUT para indicar que está enviando dados JSON para o servidor.

Em resumo, o objetivo dessa função é fornecer um cabeçalho HTTP configurado corretamente para lidar com dados JSON em suas solicitações ou 
respostas HTTP. Isso é útil quando você está trabalhando com APIs RESTful ou qualquer outra situação em que precise especificar o tipo de 
conteúdo como JSON.

O Método "createJSonHeader()" acima vai ser chamado por esse script:

```
Anime boruto = Anime.builder().name("Boruto").build();
        ResponseEntity<Anime> borutoSave = new RestTemplate().exchange("http://localhost:8080/animes/",
                HttpMethod.POST, new HttpEntity<>(boruto, createJSonHeader()), Anime.class);      
        System.out.println("Anime salvo: " + borutoSave);
```

Este script é usado para fazer uma solicitação HTTP POST a um servidor que se espera estar rodando localmente na URL 
`http://localhost:8080/animes/`. Ele cria um novo objeto `Anime` chamado "Boruto" e, em seguida, o envia para o servidor usando uma solicitação 
POST. Vamos analisar as partes do script:

1. `Anime boruto = Anime.builder().name("Boruto").build();`: Aqui, você está criando um novo objeto `Anime` usando um padrão de construção 
(Builder Pattern). O `builder()` é um método que cria um construtor de objeto `Anime` e, em seguida, você chama `name("Boruto")` para definir o 
nome do anime como "Boruto". Finalmente, `build()` é chamado para criar o objeto `Anime`.

2. `new RestTemplate()`: Aqui, você está criando uma instância de `RestTemplate`. O `RestTemplate` é uma classe da biblioteca Spring Framework 
que facilita o envio de solicitações HTTP para um servidor. Ele é usado para interagir com APIs RESTful.

3. `new HttpEntity<>(boruto, createJSonHeader())`: Este é o corpo da solicitação HTTP POST. Ele cria uma instância de `HttpEntity`, que é usada 
para representar o corpo da solicitação HTTP. O corpo é o objeto `boruto` que você deseja enviar para o servidor, e `createJSonHeader()` é 
chamado para criar os cabeçalhos HTTP necessários, indicando que o conteúdo é do tipo JSON.

4. `HttpMethod.POST`: Aqui, você está especificando que deseja fazer uma solicitação HTTP POST. Isso é apropriado quando você deseja criar um 
novo recurso no servidor.

5. `Anime.class`: Este é o tipo de retorno esperado da solicitação. Você está informando ao `RestTemplate` que deseja que o resultado da 
solicitação seja desserializado em um objeto `Anime`. Isso é útil para processar a resposta do servidor.

6. `ResponseEntity<Anime> borutoSave = new RestTemplate().exchange(...)`: Aqui, você está usando o método `exchange()` do `RestTemplate` para 
enviar a solicitação HTTP. Ele retorna um `ResponseEntity<Anime>`, que contém a resposta do servidor, incluindo o status HTTP, cabeçalhos e 
corpo da resposta.

7. `System.out.println("Anime salvo: " + borutoSave);`: Finalmente, você está imprimindo a resposta do servidor no console. Isso mostrará 
informações sobre a solicitação, como o status HTTP (por exemplo, 200 OK se a solicitação for bem-sucedida) e outros detalhes relevantes.

No geral, este script cria um objeto `Anime` chamado "Boruto" e o envia para o servidor usando uma solicitação POST. Em seguida, ele imprime a 
resposta do servidor no console para que você possa ver os detalhes da solicitação e confirmar se o anime foi salvo com sucesso no servidor.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos fazer teste unitário escrito usando o framework JUnit 5 e a biblioteca AssertJ para testar a persistência de um objeto `Anime` em um 
repositório. Vamos quebrá-lo em partes:

```java
@Test
@DisplayName("Save creates anime when Successful")
void savePersistenceAnimeWhenSuccessful(){
    Anime animeToBeSaved = createAnime();

    Anime animeSaved = this.animeRepository.save(animeToBeSaved);

    Assertions.assertThat(animeSaved).isNotNull();
    Assertions.assertThat(animeSaved.getId()).isNotNull();
    Assertions.assertThat(animeSaved.getName()).isEqualTo(animeToBeSaved.getName());
}
```

- `@Test`: Esta anotação do JUnit 5 indica que o método é um caso de teste. Esse método será executado quando você executar seus testes.

- `@DisplayName("Save creates anime when Successful")`: Esta anotação fornece um nome personalizado para o teste que será exibido nos resultados 
   do teste. Isso ajuda a identificar o que exatamente está sendo testado.

- `void savePersistenceAnimeWhenSuccessful()`: Este é o método de teste em si. Ele não aceita argumentos e não retorna nada, pois é um teste de 
   verificação de estado.

- `Anime animeToBeSaved = createAnime();`: Aqui, está criando um objeto `Anime` chamado `animeToBeSaved` usando o método `createAnime()` 
   para inicializá-lo. Este é o objeto que você planeja salvar no repositório.

- `Anime animeSaved = this.animeRepository.save(animeToBeSaved);`: Aqui, está usando o método `save()` do `animeRepository` para salvar o objeto
  `animeToBeSaved` no repositório. O método `save()` retorna o objeto `animeSaved` após a persistência no banco de dados.

- `Assertions.assertThat(animeSaved).isNotNull();`: Esta linha usa a biblioteca AssertJ para verificar se o objeto `animeSaved` não é nulo. Se 
   a persistência for bem-sucedida, o objeto salvo não deve ser nulo.

- `Assertions.assertThat(animeSaved.getId()).isNotNull();`: Aqui, está verificando se o `id` do objeto `animeSaved` não é nulo. Isso é 
   importante porque geralmente o `id` é gerado pelo banco de dados durante a persistência.

- `Assertions.assertThat(animeSaved.getName()).isEqualTo(animeToBeSaved.getName());`: Esta linha verifica se o nome do objeto `animeSaved` é 
   igual ao nome do objeto `animeToBeSaved`. Isso garante que os dados salvos correspondam aos dados originais que você planejou salvar.

```java
private Anime createAnime(){
    return Anime.builder().name("Hajime in Ippo").build();
}
```

- `private Anime createAnime()`: Este é um método auxiliar usado para criar um objeto `Anime` com um nome específico, neste caso, "Hajime in 
   Ippo". Este método é chamado no início do teste para criar o objeto que será salvo no repositório.

Em resumo, esse teste verifica se a persistência de um objeto `Anime` no repositório é bem-sucedida. Ele cria um objeto, o salva no repositório 
e, em seguida, verifica se o objeto salvo não é nulo, se possui um `id` não nulo e se o nome é igual ao nome original. Se todas essas 
verificações passarem, o teste é considerado bem-sucedido. Caso contrário, qualquer falha indicaria um problema na persistência.

--------------- // ---------------

Outro exemplo de um teste unitário escrito usando o JUnit 5 e a biblioteca AssertJ. Este teste verifica se a atualização de um objeto `Anime` 
no repositório é bem-sucedida. Vamos analisá-lo em detalhes:

```java
@Test
@DisplayName("Save update anime when Successful")
void saveUpdateAnimeWhenSuccessful(){
    Anime animeToBeSaved = createAnime();

    Anime animeSaved = this.animeRepository.save(animeToBeSaved);
    animeSaved.setName("Overlod");

    Anime animeUpdate = this.animeRepository.save(animeSaved);

    Assertions.assertThat(animeUpdate).isNotNull();
    Assertions.assertThat(animeUpdate.getId()).isNotNull();
    Assertions.assertThat(animeUpdate.getName()).isEqualTo(animeSaved.getName());
}
```

- `@Test`: Esta anotação indica que o método é um caso de teste a ser executado.

- `@DisplayName("Save update anime when Successful")`: Esta anotação fornece um nome personalizado para o teste, que será exibido nos resultados 
   do teste.

- `void saveUpdateAnimeWhenSuccessful()`: Este é o método de teste em si, que não aceita argumentos e não retorna nada, pois é um teste de 
   verificação de estado.

- `Anime animeToBeSaved = createAnime();`: Aqui, está criando um objeto `Anime` chamado `animeToBeSaved` usando o método `createAnime()` 
   para inicializá-lo. Este é o objeto que você planeja salvar no repositório.

- `Anime animeSaved = this.animeRepository.save(animeToBeSaved);`: Aqui, está usando o método `save()` do `animeRepository` para salvar o objeto 
  `animeToBeSaved` no repositório. O objeto salvo é atribuído à variável `animeSaved`.

- `animeSaved.setName("Overlod");`: Aqui, está atualizando o nome do objeto `animeSaved` para "Overlod". Esta linha simula uma atualização de 
   dados em um objeto já persistido no repositório.

- `Anime animeUpdate = this.animeRepository.save(animeSaved);`: Aqui, está usando novamente o método `save()` do `animeRepository` para atualizar 
   o objeto `animeSaved` no repositório. O objeto atualizado é atribuído à variável `animeUpdate`.

- `Assertions.assertThat(animeUpdate).isNotNull();`: Esta linha usa a biblioteca AssertJ para verificar se o objeto `animeUpdate` não é nulo. 
   Se a atualização for bem-sucedida, o objeto atualizado não deve ser nulo.

- `Assertions.assertThat(animeUpdate.getId()).isNotNull();`: Aqui, está verificando se o `id` do objeto `animeUpdate` não é nulo. Isso é 
   importante porque geralmente o `id` é gerado pelo banco de dados durante a persistência.

- `Assertions.assertThat(animeUpdate.getName()).isEqualTo(animeSaved.getName());`: Esta linha verifica se o nome do objeto `animeUpdate` é 
   igual ao nome atualizado ("Overlod") que foi definido em `animeSaved`. Isso garante que os dados do objeto atualizado correspondam às alterações planejadas.

Em resumo, este teste verifica se a atualização de um objeto `Anime` no repositório é bem-sucedida. Ele cria um objeto, salva-o no repositório, 
atualiza o nome e, em seguida, verifica se o objeto atualizado não é nulo, se possui um `id` não nulo e se o nome corresponde à atualização 
planejada. Se todas essas verificações passarem, o teste é considerado bem-sucedido, indicando que a atualização ocorreu como esperado. Caso 
contrário, qualquer falha indicaria um problema na atualização.

--------------- // ---------------

Outro exemplo de teste unitário escrito com JUnit 5 e AssertJ. Neste caso, o teste verifica se a exclusão (ou remoção) de um objeto `Anime` do 
repositório é bem-sucedida. Vamos analisar o código linha a linha:

```java
@Test
@DisplayName("Delete removes anime when Successful")
void DeleteAnimeWhenSuccessful(){
    Anime animeToBeSaved = createAnime();

    Anime animeSaved = this.animeRepository.save(animeToBeSaved);

    this.animeRepository.delete(animeSaved);
    
    Optional<Anime> animeOptional = this.animeRepository.findById(animeSaved.getId());

    Assertions.assertThat(animeOptional.isEmpty());
}
```

- `@Test`: Esta anotação indica que o método é um caso de teste a ser executado.

- `@DisplayName("Delete removes anime when Successful")`: Esta anotação fornece um nome personalizado para o teste, que será exibido nos 
   resultados do teste.

- `void DeleteAnimeWhenSuccessful()`: Este é o método de teste em si, que não aceita argumentos e não retorna nada, pois é um teste de 
   verificação de estado.

- `Anime animeToBeSaved = createAnime();`: Aqui, está criando um objeto `Anime` chamado `animeToBeSaved` usando o método `createAnime()` 
   para inicializá-lo. Este é o objeto que você planeja salvar no repositório.

- `Anime animeSaved = this.animeRepository.save(animeToBeSaved);`: Aqui, está usando o método `save()` do `animeRepository` para salvar o objeto 
  `animeToBeSaved` no repositório. O objeto salvo é atribuído à variável `animeSaved`.

- `this.animeRepository.delete(animeSaved);`: Aqui, está excluindo o objeto `animeSaved` do repositório usando o método `delete()` do 
  `animeRepository`. Isso simula a ação de exclusão de um objeto persistido.

- `Optional<Anime> animeOptional = this.animeRepository.findById(animeSaved.getId());`: Aqui, está tentando encontrar o objeto `animeSaved` 
  no repositório usando o método `findById()`. O resultado é armazenado em um `Optional` chamado `animeOptional`. Se o objeto foi excluído com sucesso, isso deverá retornar um `Optional` vazio.

- `Assertions.assertThat(animeOptional.isEmpty());`: Aqui, está usando AssertJ para verificar se o `animeOptional` está vazio. Se 
   estiver vazio, isso significa que o objeto não foi encontrado no repositório, o que indica que a exclusão foi bem-sucedida.

Em resumo, este teste verifica se a exclusão de um objeto `Anime` do repositório é bem-sucedida. Ele cria um objeto, salva-o no repositório, 
exclui-o do repositório e depois verifica se o objeto não pode mais ser encontrado no repositório, o que seria indicativo de uma exclusão 
bem-sucedida. Se a asserção passar, o teste é considerado bem-sucedido.

--------------- // ---------------

No teste find by name:

```java
@Test
@DisplayName("Find by name returns list anime when Successful")
void findByNameAnimeWhenSuccessful(){
    // Cria um objeto Anime que será salvo no banco de dados
    Anime animeToBeSaved = createAnime();

    // Salva o anime no banco de dados usando o repositório
    Anime animeSaved = this.animeRepository.save(animeToBeSaved);

    // Obtém o nome do anime salvo
    String anime = animeSaved.getName();

    // Realiza uma consulta no banco de dados para encontrar animes pelo nome
    List<Anime> animes = this.animeRepository.findByName(anime);

    // Afirmações (Assertions) para verificar se o teste é bem-sucedido

    // 1. Verifica se a lista de animes encontrada não está vazia
    Assertions.assertThat(animes).isNotEmpty();

    // 2. Verifica se a lista de animes encontrada contém o anime salvo anteriormente
    Assertions.assertThat(animes).contains(animeSaved);
}
```

1. Começa criando um objeto `Anime` chamado `animeToBeSaved` que representa um anime a ser salvo no banco de dados.

2. Em seguida, salva esse anime no banco de dados usando o método `save` do repositório `animeRepository`. Isso insere o anime no banco de dados 
   para que você possa consultá-lo posteriormente.

3. Obtém o nome do anime salvo na variável `anime`.

4. Em seguida, executa uma consulta no banco de dados usando o método `findByName` do repositório `animeRepository`. Isso deve encontrar todos 
   os animes com o mesmo nome que o anime salvo anteriormente.

5. Aqui, realiza as asserções para verificar se o teste é bem-sucedido:
   - A primeira asserção verifica se a lista de animes encontrada não está vazia, o que significa que pelo menos um anime com o mesmo nome foi 
     encontrado no banco de dados.
   - A segunda asserção verifica se a lista de animes encontrada contém o anime salvo anteriormente, garantindo que o anime foi corretamente 
     armazenado e recuperado do banco de dados.

Basicamente, este teste verifica se o método `findByName` do repositório `animeRepository` é capaz de encontrar um anime pelo seu nome no banco 
de dados e se o anime encontrado é o mesmo que foi salvo anteriormente.

--------------- // ---------------

Teste que retorna uma lista vazia se não tiver o nome do anime no BD

```java
@Test
@DisplayName("Find by name returns empty list when no anime is found")
void findByName_returnsEmptyList_whenAnimeIsNotFound(){

    // Realiza uma consulta no banco de dados para encontrar animes pelo nome "outro anime"
    List<Anime> animes = this.animeRepository.findByName("outro anime");

    // Afirmações (Assertions) para verificar se o teste é bem-sucedido

    // Verifica se a lista de animes encontrada está vazia (isEmpty)
    Assertions.assertThat(animes).isEmpty();
}
```

1. Executa uma consulta no banco de dados usando o método `findByName` do repositório `animeRepository`, especificando o nome "outro anime" 
   como o critério de pesquisa.

2. A consulta será realizada no banco de dados para encontrar todos os animes com o nome "outro anime". No entanto, se não houver animes com 
   esse nome no banco de dados, a lista de resultados será vazia.

3. Em seguida, realiza uma asserção para verificar se o teste é bem-sucedido:
   - A asserção `Assertions.assertThat(animes).isEmpty()` verifica se a lista de animes encontrada está vazia. Se estiver vazia, isso significa 
     que nenhum anime foi encontrado com o nome "outro anime", o que é o resultado esperado neste caso de teste.

Basicamente, este teste verifica se o método `findByName` do repositório `animeRepository` retorna uma lista vazia quando nenhum anime com o 
nome especificado é encontrado no banco de dados. Isso é útil para garantir que o método se comporte corretamente em casos em que nenhum 
resultado é encontrado.

-------------------------------------------------------------------- // -----------------------------------------------------------------------
BDDMockito

O BDDMockito é uma extensão do Mockito, uma biblioteca amplamente usada para criar mocks em testes unitários em Java. O BDDMockito, por sua vez, 
segue o estilo BDD (Behavior-Driven Development) para escrever testes de maneira mais descritiva e legível. Ele fornece um conjunto de métodos 
e recursos que facilitam a escrita de testes com esse estilo. Alguns dos métodos mais comuns do BDDMockito:

1. `given(...).willReturn(...)`:
   - O método `given` é usado para definir um cenário de teste. Você usa `given` para configurar o comportamento esperado do mock.
   - O método `willReturn` indica o que o mock deve retornar quando o método sendo testado for chamado.

```java
given(animeRepository.findById(1L)).willReturn(Optional.of(anime));
```

Neste exemplo, estamos configurando o mock `animeRepository` para retornar um objeto `Optional` contendo um anime quando o método `findById` 
for chamado com o argumento `1L`.

2. `doNothing()`:
   - O método `doNothing` é usado para especificar que nenhuma ação deve ser executada quando um método de um mock for chamado.
   
```java
doNothing().when(animeRepository).deleteById(1L);
```

Aqui, estamos dizendo que quando o método `deleteById` for chamado com o argumento `1L`, nada deve acontecer.

3. `verify(...)`:
   - O método `verify` é usado para verificar se um método de um mock foi chamado com os argumentos corretos e o número correto de vezes.

```java
verify(animeRepository, times(1)).findById(1L);
```

Neste exemplo, estamos verificando se o método `findById` do mock `animeRepository` foi chamado exatamente uma vez com o argumento `1L`.

4. `willThrow(...)`:
   - O método `willThrow` é usado para indicar que um mock deve lançar uma exceção quando um método específico é chamado.

```java
willThrow(new RuntimeException("Erro")).given(animeRepository).save(any(Anime.class));
```

Aqui, estamos configurando o mock `animeRepository` para lançar uma exceção quando o método `save` for chamado com qualquer instância de `Anime`.

5. `any(...)`:
   - O método `any` é usado para corresponder a qualquer argumento de um tipo específico ao configurar ou verificar o comportamento de um mock.

```java
given(animeRepository.save(any(Anime.class))).willReturn(anime);
```

Neste exemplo, estamos configurando o mock `animeRepository` para retornar o objeto `anime` quando o método `save` for chamado com qualquer 
instância de `Anime`.

6. `thenReturn(...)`:
   - Usado para retornar um valor específico quando um método do mock é chamado.

```java
given(animeRepository.findById(1L)).willReturn(Optional.of(anime));
```

7. `will(...)`:
   - Permite configurar comportamentos de mocks de maneira mais flexível.

```java
will(invocation -> {
    Long id = invocation.getArgument(0);
    return id == 1L ? Optional.of(anime) : Optional.empty();
}).given(animeRepository).findById(anyLong());
```

8. `doReturn(...).when(...)`:
   - Usado para especificar o retorno de um método de mock em uma linha separada.

```java
doReturn(Optional.of(anime)).when(animeRepository).findById(1L);
```

9. `timeout(...)`:
   - Permite verificar se um método de mock foi chamado dentro de um determinado período de tempo.

```java
verify(animeRepository, timeout(100)).findById(1L);
```

10. `atLeast(...)`, `atMost(...)`, `never()`:
    - São usados para verificar se um método de mock foi chamado um número mínimo, máximo ou zero de vezes, respectivamente.

```java
verify(animeRepository, atLeast(1)).save(any(Anime.class));
verify(animeRepository, atMost(3)).findById(anyLong());
verify(animeRepository, never()).delete(any(Anime.class));
```

11. `thenThrow(...)`:
    - Usado para indicar que um mock deve lançar uma ou mais exceções quando um método é chamado.

```java
thenThrow(new RuntimeException("Erro")).given(animeRepository).deleteById(1L);
```

12. `callsRealMethods()`:
    - Usado para instruir o mock a chamar os métodos reais de uma classe parcialmente mockada.

```java
given(animeRepository.findById(1L)).willCallRealMethod();
```

Esses são apenas alguns dos métodos mais comuns disponíveis no BDDMockito. Eles ajudam a criar cenários de teste, configurar comportamentos de 
mocks e verificar interações entre o código sendo testado e os mocks de maneira mais descritiva e legível, seguindo o estilo BDD.

--------------- // ---------------

Class PageImpl

O `PageImpl` é uma classe da biblioteca Spring Data que representa uma página de resultados de consulta em uma lista paginada. Ela é 
frequentemente usada ao lidar com consultas que retornam um grande número de resultados, que precisam ser divididos em páginas menores para 
facilitar a exibição e a navegação.

A classe `PageImpl` é uma implementação de `Page`, que por sua vez estende `Slice`. Ela contém a lista de elementos da página atual, informações 
sobre a página atual, o número total de elementos e outras informações de paginação. Isso torna muito conveniente para trabalhar com resultados 
paginados ao usar o Spring Data.

Principais atributos e métodos da classe `PageImpl`:

- `content`: Essa é a lista de elementos da página atual.

- `number`: O número da página atual (começando em 0 para a primeira página).

- `size`: O tamanho da página (ou seja, o número máximo de elementos na página).

- `totalElements`: O número total de elementos em todas as páginas.

- `totalPages`: O número total de páginas.

- `hasContent()`: Verifica se a página atual contém elementos.

- `hasPrevious()`: Verifica se há uma página anterior.

- `hasNext()`: Verifica se há uma próxima página.

- `isFirst()`: Verifica se a página atual é a primeira.

- `isLast()`: Verifica se a página atual é a última.

- `nextPageable()`: Obtém o `Pageable` para a próxima página.

- `previousPageable()`: Obtém o `Pageable` para a página anterior.

Essa classe é especialmente útil quando você está construindo APIs RESTful que suportam a paginação de dados. Ela permite que você retorne 
facilmente apenas uma parte dos resultados para o cliente, tornando a aplicação mais eficiente em termos de recursos.

Exemplo de como você pode criar uma instância de `PageImpl`:

```java
List<Anime> content = /* Obtenha os elementos da página */;
Pageable pageable = PageRequest.of(pageNumber, pageSize); // pageNumber e pageSize são parâmetros da página atual
long totalElements = /* Obtenha o número total de elementos */;
Page<Anime> page = new PageImpl<>(content, pageable, totalElements);
```

Isso cria uma página de resultados `Page<Anime>` com a lista de elementos, informações de página e o número total de elementos. Você pode então 
usar essa página para retornar resultados paginados em sua API ou para realizar operações de paginação em seu serviço.

Lembre-se de que o uso efetivo de `PageImpl` depende do contexto em que você está trabalhando e das necessidades específicas de sua aplicação, 
especialmente quando se trata de consultas de banco de dados paginadas usando o Spring Data.

--------------- // ---------------

@BeforeEach
void SetUp(){
   PageImpl<Anime> animePage = new PageImpl<>(List.of(AnimeCreator.createAnimeToBeSaved()));
   BDDMockito.when(animeService.listAll(ArgumentMatchers.any())).thenReturn(animePage);
}

O script acima faz parte de um teste de unidade usando o framework Mockito no contexto do Spring Boot. Ele está configurando o comportamento de 
um serviço (no caso, `animeService`) usando a anotação `@BeforeEach`, que é executada antes de cada teste na classe de teste.

Explicação passo a passo do que esse script faz:

1. `@BeforeEach`: Esta anotação indica que o método `SetUp` deve ser executado antes de cada teste na classe de teste. Isso é útil para garantir 
    que o ambiente esteja configurado corretamente antes de cada teste, mantendo o isolamento entre os testes.

2. `PageImpl<Anime> animePage = new PageImpl<>(List.of(AnimeCreator.createAnimeToBeSaved()))`: Aqui, está sendo criada uma instância de 
   `PageImpl` que representa uma página de resultados paginados de objetos `Anime`. Ela contém uma única entrada que é criada pelo método 
   `AnimeCreator.createAnimeToBeSaved()`. Isso é feito para simular uma página de resultados com um único anime.

3. `BDDMockito.when(animeService.listAll(ArgumentMatchers.any())).thenReturn(animePage)`: Esta linha está configurando o comportamento do 
    serviço `animeService` usando o Mockito. Ela instrui o Mockito a responder à chamada do método `listAll` do `animeService` com qualquer 
    argumento (usando `ArgumentMatchers.any()`) retornando a `animePage` criada anteriormente. Em outras palavras, quando o método `listAll` 
    for chamado no serviço, ele retornará a página simulada de resultados.

A finalidade dessa configuração é simular o comportamento do serviço `animeService` durante o teste. Quando um teste que usa `animeService` for 
executado, em vez de fazer uma chamada real ao serviço, ele receberá a página de resultados simulada, permitindo assim que o teste seja isolado 
e previsível.

Em resumo, esse script está configurando o comportamento do serviço `animeService` para retornar uma página de resultados simulada durante os 
testes, garantindo que os testes sejam executados de forma controlada e independente do funcionamento real do serviço.

--------------- // ---------------

@Test
@DisplayName("List returns list of anime inside page object when successful")
void list_ReturnsListOfanimesInsidePageObject_whenSuccessful() {

  String expectedName = AnimeCreator.createValidAnime().getName();

   Page<Anime> animePage = animeController.list(null).getBody();

   Assertions.assertThat(animePage).isNotNull();
   Assertions.assertThat(animePage).isNotEmpty().hasSize(1);
   Assertions.assertThat(animePage.toList().get(0).getName()).isEqualTo(expectedName);
}

O script acima é um exemplo de um teste unitário em uma classe que testa um controlador Spring (nesse caso, `animeController`) que retorna uma 
lista de animes paginados.

Explicação passo a passo do que esse script faz:

1. `@Test`: Essa anotação marca o método como um método de teste unitário que deve ser executado pelo framework de teste (geralmente JUnit ou 
    TestNG).

2. `String expectedName = AnimeCreator.createValidAnime().getName();`: Aqui, está definindo uma variável `expectedName` para armazenar o nome 
    esperado de um anime válido. Isso é usado posteriormente para verificar se o anime retornado pelo controlador tem o nome esperado.

3. `Page<Anime> animePage = animeController.list(null).getBody();`: Nesta linha, está chamando o método `list` do `animeController`. Esse método 
    retorna uma resposta HTTP contendo uma lista de animes. Com `.getBody()`, está obtendo o corpo da resposta, que deve é um objeto 
    `Page<Anime>`.

4. `Assertions.assertThat(animePage).isNotNull();`: Aqui, está usando a biblioteca de assertivas (geralmente o AssertJ) para fazer afirmações 
    sobre o objeto `animePage`. É verifica se `animePage` não é nulo.

5. `Assertions.assertThat(animePage).isNotEmpty().hasSize(1);`: Essa linha faz duas verificações. Primeiro, ela verifica se `animePage` não 
    está vazio (ou seja, contém pelo menos um anime). Em segundo lugar, ela verifica se o tamanho da página é igual a 1, o que significa que há 
    exatamente um anime na página.

6. `Assertions.assertThat(animePage.toList().get(0).getName()).isEqualTo(expectedName);`: Aqui, está obtendo o primeiro anime da página usando 
   `animePage.toList().get(0)` e verificando se o nome desse anime é igual ao `expectedName` que definiu anteriormente. Isso verifica se o 
   anime retornado pelo controlador tem o nome esperado.

Resumindo, esse teste verifica se o método `list` do `animeController` retorna uma página de animes não nula, com pelo menos um anime, e se o 
nome desse anime é igual ao nome esperado. Isso ajuda a garantir que o endpoint do controlador esteja funcionando corretamente ao listar animes.

--------------- // ---------------

@Test
@DisplayName("List returns list of anime when successful")
void listAll_ReturnsListOfanimes_whenSuccessful() {

 String expectedName = AnimeCreator.createValidAnime().getName();

  List<Anime> listAnimes = animeController.listAll().getBody();

   Assertions.assertThat(listAnimes).isNotNull();
   Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);
   Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);
}

O script acima, marcado com `@Test` e com a anotação `@DisplayName`, testa o comportamento de um método chamado `listAll` do controlador 
`animeController`. Aqui está uma explicação passo a passo do que ele faz:

1. `@Test`: Essa anotação marca o método como um método de teste que deve ser executado pelo framework de teste (geralmente JUnit ou TestNG).

2. `@DisplayName("List returns list of anime when successful")`: Essa anotação `@DisplayName` permite que forneça um nome mais legível para o 
    teste. Neste caso, o nome do teste é "List returns list of anime when successful".

3. `String expectedName = AnimeCreator.createValidAnime().getName();`: Aqui, está definindo uma variável `expectedName` para armazenar o nome 
   esperado de um anime válido. Isso será usado posteriormente para verificar se o anime retornado pelo controlador tem o nome esperado.

4. `List<Anime> listAnimes = animeController.listAll().getBody();`: Nesta linha, você está chamando o método `listAll` do `animeController`. Esse método provavelmente retorna uma resposta HTTP contendo uma lista de animes. Com `.getBody()`, você está obtendo o corpo da resposta, que deve ser uma lista de objetos `Anime`.

5. `Assertions.assertThat(listAnimes).isNotNull();`: Aqui, está usando a biblioteca de assertivas (geralmente o AssertJ) para fazer uma 
    afirmação sobre a lista de animes (`listAnimes`). Aqui, verifica se a lista não é nula.

6. `Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);`: Esta linha faz duas verificações. Primeiro, verifica se a lista de animes não 
   está vazia (ou seja, contém pelo menos um anime). Em segundo lugar, verifica se o tamanho da lista é igual a 1, o que significa que há 
   exatamente um anime na lista.

7. `Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);`: Aqui, está obtendo o primeiro anime da lista usando 
`listAnimes.get(0)` e verificando se o nome desse anime é igual ao `expectedName` que você definiu anteriormente. Isso verifica se o anime 
retornado pelo controlador tem o nome esperado.

Em resumo, esse método de teste verifica se o método `listAll` do `animeController` retorna uma lista de animes não nula, com pelo menos um 
anime, e se o nome desse anime é igual ao nome esperado. Isso ajuda a garantir que o endpoint do controlador esteja funcionando corretamente 
ao listar todos os animes.

--------------- // ---------------

@Test
    @DisplayName("findById returns anime when successful")
    void findById_ReturnsAnime_whenSuccessful() {

       Long expectedId = AnimeCreator.createValidAnime().getId();

       Anime anime = animeController.findById(1L).getBody();

        Assertions.assertThat(anime).isNotNull();
        Assertions.assertThat(anime.getId()).isNotNull().isEqualTo(expectedId);
    }

O script acima marcado com `@Test` e com a anotação `@DisplayName`, testa o comportamento de um método chamado `findById` do controlador 
`animeController`. Aqui está uma explicação passo a passo do que ele faz:

1. `@Test`: Essa anotação marca o método como um método de teste que deve ser executado pelo framework de teste (geralmente JUnit ou TestNG).

2. `@DisplayName("findById returns anime when successful")`: Essa anotação `@DisplayName` permite que você forneça um nome mais legível para o 
    teste. Neste caso, o nome do teste é "findById returns anime when successful".

3. `Long expectedId = AnimeCreator.createValidAnime().getId();`: Aqui, está definindo uma variável `expectedId` para armazenar o ID esperado de 
    um anime válido. Isso será usado posteriormente para verificar se o anime retornado pelo controlador tem o ID esperado.

4. `Anime anime = animeController.findById(1L).getBody();`: Nesta linha está chamando o método `findById` do `animeController` com um ID 
específico (neste caso, 1L). Esse método retorna uma resposta HTTP contendo um objeto `Anime`. Com `.getBody()`, aqui, está obtendo o corpo da 
resposta, que deve ser o objeto `Anime` com o ID especificado.

5. `Assertions.assertThat(anime).isNotNull();`: Aqui, está usando a biblioteca de assertivas (geralmente o AssertJ) para fazer uma afirmação 
    sobre o objeto `anime`. Aqui, verifica se o objeto não é nulo, o que significa que um anime foi encontrado com o ID especificado.

6. `Assertions.assertThat(anime.getId()).isNotNull().isEqualTo(expectedId);`: Esta linha faz duas verificações. Primeiro, verifica se o ID do 
    anime retornado não é nulo. Em segundo lugar, verifica se o ID do anime é igual ao `expectedId` que você definiu anteriormente. Isso 
    verifica se o anime retornado pelo controlador tem o ID esperado.

Em resumo, esse método de teste verifica se o método `findById` do `animeController` retorna um objeto `Anime` não nulo, com o ID correto. Isso 
ajuda a garantir que o endpoint do controlador esteja funcionando corretamente ao buscar um anime pelo ID.

--------------- // ---------------

@Test
@DisplayName("findByNome returns a list of anime when successful")
void findByNome_ReturnsListOfAnime_whenSuccessful() {

  String expectedName = AnimeCreator.createValidAnime().getName();

   List<Anime> listAnimes = animeController.findByName("anime").getBody();

   Assertions.assertThat(listAnimes).isNotNull();
   Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);
   Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);
}

O script acima também testa o comportamento de um método no controlador `animeController`. Vamos explicar passo a passo o que esse teste faz:

1. `@Test`: Essa anotação marca o método como um método de teste que deve ser executado durante os testes automatizados.

2. `@DisplayName("findByNome returns a list of anime when successful")`: A anotação `@DisplayName` permite fornecer um nome mais descritivo para 
   o teste. Neste caso, o nome é "findByNome returns a list of anime when successful".

3. `String expectedName = AnimeCreator.createValidAnime().getName();`: Aqui, está definindo uma variável `expectedName` para armazenar o nome 
    esperado de um anime válido. Isso será usado posteriormente para verificar se o anime retornado pelo controlador tem o nome esperado.

4. `List<Anime> listAnimes = animeController.findByName("anime").getBody();`: Esta linha está chamando o método `findByName` do `animeController` 
    com o argumento "anime". O método retornará uma resposta HTTP que contém uma lista de objetos `Anime`. O `.getBody()` é usado para obter o 
    corpo da resposta, que deve ser a lista de animes.

5. `Assertions.assertThat(listAnimes).isNotNull();`: Aqui, está usando as asserções da biblioteca (provavelmente AssertJ) para verificar se a 
    lista de animes (`listAnimes`) não é nula. Isso garante que a chamada ao método `findByName` do controlador tenha retornado uma lista 
    válida.

6. `Assertions.assertThat(listAnimes).isNotEmpty().hasSize(1);`: Esta linha faz duas verificações. Primeiro, ela verifica se a lista de animes
    não está vazia, ou seja, contém pelo menos um anime. Em segundo lugar, ela verifica se a lista tem tamanho igual a 1. Isso indica que apenas 
    um anime foi encontrado com o nome "anime".

7. `Assertions.assertThat(listAnimes.get(0).getName()).isEqualTo(expectedName);`: Aqui, está verificando se o nome do primeiro anime na lista 
    (`listAnimes.get(0).getName()`) é igual ao `expectedName` que definiu anteriormente. Isso garante que o anime retornado pelo controlador 
    tenha o nome esperado.

Resumindo, esse teste verifica se o método `findByName` do `animeController` retorna uma lista não nula de animes, contendo pelo menos um anime 
com o nome esperado. Isso ajuda a garantir que o endpoint do controlador esteja funcionando corretamente ao buscar animes pelo nome.

--------------- // ---------------

@Test
@DisplayName("findByNome returns an empty list of anime is not found")
void findByNome_ReturnsEmptyListOfAnime_whenIsNotFound() {

   BDDMockito.when(animeService.findByName(ArgumentMatchers.anyString()))
       .thenReturn(Collections.emptyList()); 

   List<Anime> listAnimes = animeController.findByName("anime").getBody();

   Assertions.assertThat(listAnimes).isNotNull();
   Assertions.assertThat(listAnimes).isEmpty();
}

O método de teste acima verifica o comportamento de um endpoint em que o serviço `animeService` retorna uma lista vazia quando não encontra 
nenhum anime com o nome especificado. Vamos analisar cada parte do script:

1. `void findByNome_ReturnsEmptyListOfAnime_whenIsNotFound()`: Este é um método de teste semelhante aos outros, mas com um foco específico. Ele 
    testa o cenário em que nenhum anime é encontrado com o nome especificado.

2. `BDDMockito.when(animeService.findByName(ArgumentMatchers.anyString()))`: Aqui, está usando o framework Mockito (com a extensão BDDMockito) 
    para criar um comportamento simulado. Aqui, está dizendo que quando o método `findByName` do `animeService` for chamado com qualquer 
    argumento de string (`ArgumentMatchers.anyString()`), ele deve retornar uma lista vazia (`Collections.emptyList()`).

3. `List<Anime> listAnimes = animeController.findByName("anime").getBody();`: Nesta linha, está chamando o método `findByName` do 
    `animeController` com o argumento "anime". O método provavelmente retornará uma resposta HTTP que contém uma lista de objetos `Anime`. 
    Aqui, está pegando o corpo da resposta usando `.getBody()` e armazenando-o na variável `listAnimes`.

4. `Assertions.assertThat(listAnimes).isNotNull();`: Aqui, está usando as asserções para verificar se a lista de animes (`listAnimes`) não é 
    nula. Isso garante que a chamada ao método `findByName` do controlador tenha retornado uma resposta válida.

5. `Assertions.assertThat(listAnimes).isEmpty();`: Esta linha verifica se a lista de animes está vazia. Isso é esperado neste cenário, pois 
    configurou o `animeService` para retornar uma lista vazia quando não encontra nenhum anime com o nome especificado.

Em resumo, esse teste garante que o endpoint do controlador `animeController` lida adequadamente com a situação em que nenhum anime é encontrado 
com o nome especificado e retorna uma lista vazia como resposta.

--------------- // ---------------

@Test
@DisplayName("save returns anime when successful")
void save_ReturnsAnime_whenSuccessful() {

  Anime anime = animeController.save(AnimePostRequestBodyCreator.createAnimePostRequestBody()).getBody();
  Assertions.assertThat(anime).isNotNull().isEqualTo(AnimeCreator.createValidAnime());  
}

O método acima de teste verifica o comportamento de um endpoint em que o serviço `animeController` cria e salva um novo anime com sucesso. 
Vamos analisar cada parte do script:

1. `@Test`: Essa anotação marca o método como um método de teste para o JUnit. Isso significa que o método será executado como parte do processo 
    de teste.

2. `@DisplayName("save returns anime when successful")`: Essa anotação fornece um nome personalizado para o teste que será exibido nos relatórios 
    de teste. Neste caso, o nome personalizado é "save returns anime when successful", que descreve o comportamento esperado do teste.

3. `void save_ReturnsAnime_whenSuccessful()`: Este é o método de teste em si. Ele testa se o endpoint de salvar um anime no `animeController` 
   retorna um anime quando a operação é bem-sucedida.

4. `Anime anime = animeController.save(AnimePostRequestBodyCreator.createAnimePostRequestBody()).getBody();`: Nesta linha, está chamando o 
    método `save` do `animeController` e passando um objeto `AnimePostRequestBody` criado pelo método `createAnimePostRequestBody` como 
    argumento. A chamada ao método `getBody()` obtém o corpo da resposta HTTP, que deve conter o anime criado.

5. `Assertions.assertThat(anime)`: Esta linha inicia uma série de verificações usando asserções do AssertJ. 

6. `isNotNull()`: Verifica se o anime retornado não é nulo, ou seja, se foi criado e retornado com sucesso.

7. `isEqualTo(AnimeCreator.createValidAnime())`: Verifica se o anime retornado é igual ao anime válido criado previamente com 
   `AnimeCreator.createValidAnime()`. Isso garante que os dados do anime retornado coincidam com os dados esperados.

Em resumo, esse teste verifica se o endpoint do `animeController` é capaz de criar e retornar um anime com sucesso quando os dados são 
fornecidos corretamente. Ele verifica se o objeto anime retornado não é nulo e se seus atributos correspondem aos valores esperados.

--------------- // ---------------

void replace_UpdatesAnime_whenSuccessful() {

   Assertions.assertThatCode(() -> animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody())).doesNotThrowAnyException();

   ResponseEntity<Void> entity = animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody());

   Assertions.assertThat(entity).isNotNull();  
   Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);
}

O script acima é um exemplo de um teste de unidade em que você está testando o método `replace` de um controlador chamado `animeController`. 
Vou explicar cada parte do script:

1. `Assertions.assertThatCode(() -> animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody())).doesNotThrowAnyException();`:
   - Este trecho de código usa o AssertJ para verificar se a chamada do método `replace` não lança nenhuma exceção (`doesNotThrowAnyException`). 
     Isso é uma forma de testar se o método é executado com sucesso e não gera exceções inesperadas.

2. `ResponseEntity<Void> entity = animeController.replace(AnimePutRequestBodyCreator.createAnimePutRequestBody());`:
   - Aqui, o método `replace` do `animeController` é chamado novamente para obter a resposta (uma instância de `ResponseEntity<Void>`) após o 
     primeiro teste para verificar o status da resposta.

3. `Assertions.assertThat(entity).isNotNull();`:
   - Verifica se a variável `entity` (a resposta da chamada do método `replace`) não é nula. Isso garante que a chamada do método tenha 
     retornado uma resposta.

4. `Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);`:
   - Verifica se o código de status da resposta (`entity.getStatusCode()`) é igual a `HttpStatus.NO_CONTENT`. Isso verifica se a resposta 
     indica que a operação foi bem-sucedida e não retornou conteúdo (um código de status 204).

Basicamente, esse teste está verificando se o método `replace` do `animeController` pode ser chamado com sucesso sem lançar exceções, se ele 
retorna uma resposta não nula e se essa resposta tem um código de status `HttpStatus.NO_CONTENT`. Isso é útil para garantir que o método esteja 
funcionando conforme o esperado e que as atualizações de anime sejam tratadas corretamente.

--------------- // ---------------

void delete_RemovesAnime_whenSuccessful() {

   Assertions.assertThatCode(() -> animeController.delete(1L)).doesNotThrowAnyException();

   ResponseEntity<Void> entity = animeController.delete(1L);

   Assertions.assertThat(entity).isNotNull();  
   Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);
}

O script acima é um exemplo de um teste de unidade que verifica o comportamento do método `delete` de um controlador chamado `animeController`. 
Vou explicar cada parte do script:

1. `Assertions.assertThatCode(() -> animeController.delete(1L)).doesNotThrowAnyException();`:
   - Neste trecho, o AssertJ é usado para verificar se a chamada do método `delete` não lança nenhuma exceção (`doesNotThrowAnyException`). Isso 
     é uma forma de testar se o método é executado com sucesso e não gera exceções inesperadas.

2. `ResponseEntity<Void> entity = animeController.delete(1L);`:
   - Aqui, o método `delete` do `animeController` é chamado novamente para obter a resposta (uma instância de `ResponseEntity<Void>`) após o 
     primeiro teste para verificar o status da resposta.

3. `Assertions.assertThat(entity).isNotNull();`:
   - Verifica se a variável `entity` (a resposta da chamada do método `delete`) não é nula. Isso garante que a chamada do método tenha retornado 
     uma resposta.

4. `Assertions.assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NO_CONTENT);`:
   - Verifica se o código de status da resposta (`entity.getStatusCode()`) é igual a `HttpStatus.NO_CONTENT`. Isso verifica se a resposta 
     indica que a operação foi bem-sucedida e que o recurso foi removido com sucesso (um código de status 204).

Em resumo, este teste verifica se o método `delete` do `animeController` pode ser chamado com sucesso sem lançar exceções, se ele retorna uma 
resposta não nula e se essa resposta tem um código de status `HttpStatus.NO_CONTENT`. Isso é útil para garantir que o método esteja funcionando 
conforme o esperado e que a remoção de um anime seja tratada corretamente.

--------------- // ---------------

@DisplayName("Save throw ConstraintViolationException_WhenNameIsEmpty")
@Test
void save_ThrowsConstraintViolationException_WhenNameIsEmpty(){

        Anime anime = new Anime();

        Assertions.assertThatExceptionOfType(ConstraintViolationException.class)
        .isThrownBy(() -> this.animeRepository.save(anime))
        .withMessageContaining("The anime name cannot be empty");

    }

O script acima é teste de unidade escrito em Java usando a biblioteca de teste JUnit e a biblioteca de assertiva AssertJ. Vou explicar o que 
está acontecendo linha por linha:

1. `void save_ThrowsConstraintViolationException_WhenNameIsEmpty() {`

   - Isso é uma declaração de um método de teste chamado `save_ThrowsConstraintViolationException_WhenNameIsEmpty`. O método de teste é 
     declarado com a palavra-chave `void` porque não retorna nenhum valor.

2. `Anime anime = new Anime();`

   - Aqui, uma nova instância da classe `Anime` é criada e armazenada na variável `anime`. Presumivelmente, a classe `Anime` representa algum 
     tipo de entidade ou objeto relacionado a animes.

3. `Assertions.assertThatExceptionOfType(ConstraintViolationException.class)`

   - Esta linha usa a biblioteca AssertJ para definir uma asserção. A função `assertThatExceptionOfType` é usada para verificar se uma exceção 
     de um tipo específico é lançada durante a execução do código dentro do bloco `isThrownBy`.

4. `.isThrownBy(() -> this.animeRepository.save(anime))`

   - Aqui, está sendo configurada uma expectativa de que a operação dentro do lambda `() -> this.animeRepository.save(anime)` lançará uma 
     exceção do tipo `ConstraintViolationException`. Essa operação estar relacionada a salvar o objeto `anime` no repositório, como um banco 
     de dados.

5. `.withMessageContaining("The anime name cannot be empty");`

   - Esta linha verifica se a mensagem de exceção lançada contém a frase "The anime name cannot be empty". Isso é útil para verificar se a 
     exceção possui uma mensagem específica associada a ela.

Resumindo, este teste de unidade verifica se a operação de salvar um objeto `anime` em algum repositório lança uma exceção do tipo 
`ConstraintViolationException` com a mensagem "The anime name cannot be empty" quando o nome do anime está vazio. Essa é uma técnica comum de 
teste para garantir que as validações e restrições estejam funcionando corretamente ao salvar objetos em um sistema.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @SpringBootTest

A anotação `@SpringBootTest` é uma anotação usada em aplicações Spring Boot, que é uma estrutura popular para o desenvolvimento de aplicativos 
Java baseados em Spring. Essa anotação é usada para configurar testes de integração em seu aplicativo Spring Boot e fornece várias opções de 
configuração. O `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)`, está configurando um ambiente de teste específico.

Aqui estão os detalhes dessa anotação:

1. `@SpringBootTest`: Esta anotação indica que você está criando um teste de integração para sua aplicação Spring Boot. Ela inicializa o 
contexto da aplicação Spring e carrega todas as configurações, incluindo as configurações de beans, conforme definido em sua aplicação.

2. `webEnvironment`: É um atributo da anotação que define o ambiente em que o teste será executado. No exemplo, 
`SpringBootTest.WebEnvironment.RANDOM_PORT` é usado. Isso significa que o teste será executado em um ambiente de web, e o Spring Boot escolherá 
aleatoriamente uma porta disponível para iniciar o servidor incorporado.

Isso é especialmente útil para testes que precisam acessar sua aplicação por meio de solicitações HTTP, como testes de integração de API. Ao 
usar um número de porta aleatório, você evita conflitos de porta se vários testes estiverem sendo executados simultaneamente.

Portanto, a anotação `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)` é usada para criar um teste de integração 
que carrega o contexto da aplicação Spring Boot e inicia um servidor web incorporado em uma porta aleatória para que você possa testar a 
funcionalidade de sua aplicação que requer comunicação via HTTP. Isso é muito útil para garantir que sua aplicação esteja funcionando 
corretamente em um ambiente semelhante ao ambiente de produção.

--------------- // ---------------

Anotação @AutoConfigureTestDatabase

A anotação `@AutoConfigureTestDatabase` é usada em testes de integração em aplicativos Spring Boot para configurar automaticamente o banco de 
dados que será usado durante os testes. Ela é uma maneira conveniente de definir as configurações de banco de dados específicas para testes sem 
a necessidade de configurar manualmente essas configurações.

Essa anotação permite que você controle como o banco de dados é configurado para seus testes. Alguns dos principais atributos que você pode usar 
com `@AutoConfigureTestDatabase` incluem:

1. `replace`: Esse atributo permite especificar como o banco de dados deve ser substituído. Os valores comuns são `Replace.NONE` (não 
substituir), `Replace.AUTO_CONFIGURED` (substituir apenas o banco de dados que é configurado automaticamente) e `Replace.NONE` (usar a 
configuração padrão do banco de dados).

2. `connection`: Este atributo permite que você especifique o nome da fonte de dados a ser usada para os testes. Isso é útil quando você deseja 
usar uma fonte de dados específica para testes em vez da fonte de dados principal configurada para sua aplicação.

3. `initScripts` e `schema`: Esses atributos permitem que você especifique scripts SQL de inicialização e esquema que devem ser executados antes 
dos testes. Isso é útil para preparar o banco de dados com dados iniciais ou esquemas específicos para cada teste.

Em resumo, `@AutoConfigureTestDatabase` é uma anotação útil para personalizar a configuração do banco de dados em testes de integração em 
aplicativos Spring Boot, permitindo que você tenha controle sobre como o banco de dados é configurado e inicializado durante os testes.

--------------- // ---------------

Classe TestRestTemplate

A classe `TestRestTemplate` é uma classe fornecida pelo Spring Framework e é usada comumente em testes de integração de aplicativos Spring Boot 
para fazer solicitações HTTP a endpoints da sua aplicação durante os testes. Ela é uma extensão da classe `RestTemplate` projetada 
especificamente para facilitar os testes de integração e permite que você interaja com a sua aplicação como faria em um cenário real, fazendo 
solicitações HTTP e verificando as respostas.

Aqui estão alguns pontos-chave sobre a classe `TestRestTemplate`:

1. **Integração com o ambiente Spring Boot:** A `TestRestTemplate` é configurada automaticamente para usar o ambiente de teste do Spring Boot. 
Isso significa que ela aproveita a configuração de aplicativo e contexto de aplicativo que você definiu para seus testes.

2. **Uso de URLs relativas:** Em vez de fornecer URLs absolutas para seus endpoints, você pode usar URLs relativas com a `TestRestTemplate`. 
Ela se baseia na configuração do servidor incorporado que é iniciado durante o teste para determinar a URL base.

3. **Fácil verificação de respostas:** A `TestRestTemplate` facilita a verificação das respostas das solicitações HTTP. Você pode usar métodos 
convenientes para acessar o status da resposta, o corpo da resposta e os cabeçalhos de resposta, facilitando a validação dos resultados dos 
testes.

Aqui está um exemplo simples de como você pode usar a `TestRestTemplate` em um teste de integração:

```java
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.ResponseEntity;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class MeuTesteDeIntegracao {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    public void testEndpoint() {
        ResponseEntity<String> response = restTemplate.getForEntity("/meu-endpoint", String.class);

        // Verificar o status da resposta
        assertEquals(200, response.getStatusCodeValue());

        // Verificar o corpo da resposta
        assertEquals("Conteúdo Esperado", response.getBody());
    }
}
```

Neste exemplo, estamos injetando a `TestRestTemplate` usando a anotação `@Autowired` e a usando para fazer uma solicitação GET a um endpoint da 
aplicação. Em seguida, verificamos o status da resposta e o corpo da resposta para garantir que a resposta seja a esperada.

A `TestRestTemplate` é uma ferramenta útil para simplificar os testes de integração de aplicativos Spring Boot que envolvem comunicação via 
HTTP com a sua aplicação. Ela torna mais fácil simular solicitações HTTP e verificar as respostas em seus testes de unidade.

--------------- // ---------------

Anotação @LocalServerPort

A anotação `@LocalServerPort` é uma anotação fornecida pelo Spring Framework e é frequentemente usada em testes de integração de aplicativos 
Spring Boot para obter a porta na qual o servidor web incorporado foi iniciado durante o teste. Essa anotação é especialmente útil quando você 
precisa fazer solicitações HTTP para a sua aplicação durante os testes e precisa saber em qual porta o servidor está ouvindo.

Aqui estão algumas informações importantes sobre a anotação `@LocalServerPort`:

1. **Injeção de Porta:** Você pode usar `@LocalServerPort` para injetar automaticamente a porta do servidor web em uma variável em seu teste. A 
anotação funciona com tipos inteiros, então você pode declarar uma variável do tipo `int` e o Spring injetará automaticamente o número da porta 
nessa variável.

2. **Uso com a `TestRestTemplate`:** Uma maneira comum de usar `@LocalServerPort` é em conjunto com a classe `TestRestTemplate`, que é usada 
para fazer solicitações HTTP em seus testes de integração. Você pode combinar essas duas funcionalidades para construir a URL completa para seus 
endpoints da aplicação durante o teste.

Aqui está um exemplo simples de como você pode usar `@LocalServerPort` em um teste de integração:

```java
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.web.client.RestTemplate;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class MeuTesteDeIntegracao {

    @LocalServerPort
    private int portaDoServidor;

    @Test
    public void testEndpoint() {
        String url = "http://localhost:" + portaDoServidor + "/meu-endpoint";
        RestTemplate restTemplate = new RestTemplate();
        String resposta = restTemplate.getForObject(url, String.class);

        // Realize verificações com a resposta
    }
}
```

Neste exemplo, a anotação `@LocalServerPort` é usada para injetar o número da porta em `portaDoServidor`, que é então usado para construir a URL 
completa para o endpoint que será testado.

Isso é especialmente útil quando você deseja que seus testes de integração sejam independentes de portas fixas, permitindo que o Spring Boot 
selecione automaticamente uma porta disponível para o servidor web incorporado durante o teste.

--------------- // ---------------

Wrapper

Um "wrapper" (ou invólucro, em tradução livre) é um conceito geralmente usado na programação para se referir a um componente, classe, ou função 
que encapsula ou envolve outro componente, classe ou função. O objetivo principal de um wrapper é fornecer uma interface mais conveniente ou 
uma camada de abstração em torno do componente subjacente para simplificar seu uso ou fornecer funcionalidades adicionais.

Aqui estão alguns contextos comuns em que wrappers são usados:

1. **Wrappers para Bibliotecas Externas**: Muitas vezes, quando você está trabalhando com bibliotecas externas ou APIs, você pode criar wrappers 
em torno delas para tornar a interação mais fácil e segura. Por exemplo, você pode criar um wrapper em torno de uma API de serviço da web para 
fornecer métodos mais simples e semelhantes à linguagem que encapsulam a lógica de autenticação, tratamento de erros, etc.

2. **Wrappers para Tipos de Dados Primitivos**: Em linguagens de programação, você pode criar classes de invólucro (como `Integer` em Java) para 
tipos de dados primitivos (como `int`) para fornecer funcionalidades adicionais, como métodos auxiliares.

3. **Wrappers para Gerenciamento de Recursos**: Wrappers também podem ser usados para gerenciar recursos, como arquivos, conexões de banco de 
dados, sockets, etc. Eles garantem que os recursos sejam adequadamente abertos, usados e fechados, mesmo em cenários de exceção.

4. **Wrappers para Testes**: Em testes de unidade ou testes de integração, você pode criar wrappers para isolar o componente que está sendo 
testado, permitindo que você substitua partes do componente com simulações ou mock objects para facilitar os testes.

5. **Wrappers para APIs de Terceiros**: Quando você está integrando com serviços de terceiros, como APIs de redes sociais, serviços de pagamento, 
etc., você pode criar wrappers para lidar com a comunicação e autenticação, tornando a integração mais simples e encapsulando detalhes complexos.

Em resumo, um wrapper é uma camada intermediária de código que envolve e simplifica a interação com componentes subjacentes, classes ou recursos 
para tornar o uso mais conveniente, seguro ou abstrato. Eles são usados para encapsular detalhes complexos e expor uma interface mais amigável 
para os desenvolvedores que desejam usar esses componentes.

--------------- // ---------------

A classe `PageableResponse` é um exemplo de um conceito de wrapper em programação, projetado para encapsular informações relacionadas a uma 
resposta paginada. Ela estende a classe `PageImpl` do Spring Data, que é frequentemente usada para representar resultados paginados de consultas 
em bancos de dados.

Aqui está uma explicação de cada parte dessa classe:

- `@Getter` e `@Setter`: Essas são anotações do projeto Lombok que geram automaticamente os métodos getter e setter para as propriedades da 
classe, evitando a necessidade de escrevê-los manualmente.

- `public class PageableResponse<T> extends PageImpl<T>`: Esta classe `PageableResponse` é parametrizada com um tipo genérico `T`, o que 
significa que ela pode ser usada para representar páginas de qualquer tipo de conteúdo. Ela estende `PageImpl<T>`, que é uma classe do Spring 
Data que implementa a interface `Page<T>` para representar uma página de resultados paginados.

As linhas subsequentes fazem o mesmo para outras propriedades JSON, como "number", "size", "totalElements", "last", "first", "totalPages", 
"numberOfElements", "pageable" e "sort". Cada uma dessas propriedades JSON é mapeada para um parâmetro correspondente do construtor.Os tipos 
dos parâmetros correspondem aos tipos esperados para essas propriedades no objeto JSON que está sendo desserializado.

- As seguintes propriedades são adicionadas à classe `PageableResponse`:

  - `private boolean first`: Indica se a página atual é a primeira.
  - `private boolean last`: Indica se a página atual é a última.
  - `private int totalPages`: O número total de páginas disponíveis.
  - `private int numberOfElements`: O número de elementos na página atual.

- `@JsonCreator(mode = Mode.PROPERTIES)`: Esta anotação é parte do Jackson, uma biblioteca usada para serializar e desserializar objetos JSON 
em Java. Ela indica que o construtor que segue deve ser usado para desserializar o objeto JSON.

- `@JsonIgnoreProperties(ignoreUnknown = true)`: Esta anotação do Jackson indica que qualquer propriedade desconhecida encontrada ao 
desserializar o objeto JSON deve ser ignorada. Isso é útil quando você está desserializando objetos JSON que podem conter propriedades 
adicionais que não são mapeadas para propriedades da classe.

- O construtor `public PageableResponse(...)` é usado para criar uma instância de `PageableResponse` a partir dos dados fornecidos, que são 
normalmente obtidos de uma consulta paginada. Ele chama o construtor da superclasse `PageImpl` com os parâmetros apropriados, configurando 
assim a parte básica da resposta paginada.

Em resumo, a classe `PageableResponse` é um exemplo de wrapper que encapsula informações relacionadas a uma resposta paginada, estendendo a 
classe `PageImpl` do Spring Data e adicionando propriedades extras e um construtor personalizado para desserialização de objetos JSON. Isso 
torna mais fácil trabalhar com respostas paginadas em seu código, fornecendo uma abstração conveniente para as informações de paginação.

--------------- // ---------------

Logback 
site: https://www.baeldung.com/logback

O Logback é uma estrutura de registro (logging) em Java muito popular e flexível. Ele é comumente usado para configurar e gerenciar logs em
aplicativos Java, incluindo testes. O Logback fornece várias funcionalidades para a geração, formatação e redirecionamento de logs. Para testes, 
o Logback pode ser configurado de várias maneiras para auxiliar no diagnóstico de problemas, registro de informações relevantes e rastreamento 
de execução. Aqui estão algumas das maneiras pelas quais o Logback pode ser útil em testes:

1. **Registro de Informações de Depuração**: Durante o desenvolvimento e execução de testes, é comum desejar registrar informações de depuração 
para rastrear o fluxo de execução, variáveis e resultados intermediários. O Logback permite que você configure níveis de log (por exemplo, 
DEBUG) para registrar informações detalhadas apenas quando necessário.

2. **Identificação de Problemas**: Quando um teste falha, é importante ter informações detalhadas para diagnosticar o problema. O Logback pode 
ser configurado para registrar informações relevantes, como mensagens de erro, pilha de chamadas (stack trace) e valores de variáveis, para 
ajudar na identificação de problemas.

3. **Rastreamento de Execução**: Em alguns casos, você pode desejar rastrear a execução de um teste, incluindo quando certos métodos são 
chamados e com que argumentos. O Logback pode ser usado para registrar essas informações, permitindo um rastreamento mais detalhado.

4. **Redirecionamento de Logs**: O Logback pode ser configurado para redirecionar logs para diferentes destinos, como arquivos de log ou 
consoles. Isso pode ser útil para verificar os logs após a execução do teste ou para depurar problemas específicos.

5. **Configuração Flexível**: O Logback permite a configuração flexível de logs por meio de arquivos de configuração, o que significa que você 
pode ajustar o comportamento de registro sem precisar modificar o código de teste. Isso é útil para alternar entre diferentes níveis de log ou 
direcionamentos de log com facilidade.

6. **Isolamento de Testes**: Às vezes, é importante isolar os logs gerados durante um teste específico para não interferir em outros testes ou 
no ambiente de desenvolvimento. O Logback pode ser configurado para fornecer essa isolamento.

7. **Integração com Estruturas de Teste**: Muitas estruturas de teste, como JUnit, TestNG e Spring Test, permitem a integração fácil com o 
Logback, facilitando a configuração e o uso de logs em testes automatizados.

Em resumo, o Logback é uma ferramenta versátil que pode melhorar significativamente a capacidade de diagnosticar e depurar problemas durante a 
execução de testes em aplicativos Java. Sua flexibilidade e recursos de configuração o tornam uma escolha popular para desenvolvedores que
 desejam controlar e analisar registros durante o desenvolvimento e teste de software.

--------------- // ---------------

Anotação: @DirtiesContext

A anotação `@DirtiesContext` é uma anotação usada em testes com o Spring Framework para indicar que o contexto de aplicação (ApplicationContext) 
deve ser "sujado" ou "resetado" após a execução de um método de teste específico. Isso significa que, quando um método de teste é marcado com 
`@DirtiesContext`, o Spring reinicializa o contexto de aplicação antes de executar o próximo teste, garantindo que cada teste seja executado 
em um contexto limpo e independente dos outros.

Essa anotação é útil em cenários em que um método de teste altera o estado do contexto de alguma forma e você deseja garantir que isso não 
afete outros testes. Por exemplo, se um teste cria ou modifica beans no contexto de aplicação e você deseja evitar que essas alterações afetem 
outros testes que compartilham o mesmo contexto, você pode usar `@DirtiesContext`.

Existem três modos principais de uso da anotação `@DirtiesContext`:

1. `@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)`: Isso indica que o contexto de aplicação será sujado após todos os 
métodos de teste em uma classe de teste terem sido executados. É útil quando vários métodos de teste em uma classe interagem de forma complexa 
com o contexto e você deseja garantir que o contexto seja recriado completamente após todos os testes.

2. `@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_CLASS)`: O contexto será sujado antes de todos os métodos de teste em uma 
classe de teste serem executados. Isso pode ser útil quando você deseja que o contexto seja reiniciado uma vez antes de qualquer teste na 
classe ser executado.

3. `@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)`: O contexto será sujado e recriado antes da execução de cada 
método de teste. Isso garante que cada teste seja executado em um contexto limpo e independente.

O uso específico da anotação `@DirtiesContext` depende dos requisitos do seu projeto e da necessidade de manter o estado consistente entre os 
testes. Certifique-se de usá-la com cuidado, pois reinicializar o contexto pode ter um impacto significativo no desempenho dos testes, 
especialmente se o contexto for grande ou complexo. No entanto, em muitos casos, é uma ferramenta útil para garantir que os testes sejam 
isolados uns dos outros.

--------------- // ---------------

@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)

1. `classMode` (Modo de Classe):
   - O atributo `classMode` especifica o modo em que o contexto de aplicação deve ser "sujado" ou "resetado". Ele aceita os seguintes valores:
     - `AFTER_CLASS`: Isso significa que o contexto será sujado uma vez após todos os métodos de teste em uma classe de teste terem sido executados.
     - `BEFORE_CLASS`: O contexto será sujado uma vez antes de todos os métodos de teste em uma classe de teste serem executados.
     - `AFTER_EACH_TEST_METHOD`: O contexto será sujado após a execução de cada método de teste (padrão).
     - `BEFORE_EACH_TEST_METHOD`: O contexto será sujado antes da execução de cada método de teste.

No exemplo acima, `classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD` indica que o contexto de aplicação será sujado e resetado 
antes da execução de cada método de teste. Isso ajuda a garantir que cada teste seja executado em um contexto limpo e independente, o que pode 
ser importante quando os testes alteram o estado do contexto de alguma forma.

O uso específico do modo de classe depende dos requisitos do seu projeto e da necessidade de manter o estado consistente entre os testes. Em 
muitos casos, o valor padrão (`BEFORE_EACH_TEST_METHOD`) é suficiente para garantir que os testes sejam isolados uns dos outros.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Spring Security

O Spring Security é uma estrutura amplamente utilizada para adicionar segurança a aplicativos baseados em Spring. O filtro `SecurityFilterChain` 
é um dos componentes cruciais do Spring Security e é usado para configurar as regras de segurança que serão aplicadas a diferentes partes de 
sua aplicação. O `SecurityFilterChain` é uma configuração composta por vários filtros que definem como a segurança deve ser aplicada em várias 
partes de sua aplicação.

Alguns conceitos-chave relacionados ao `SecurityFilterChain` no Spring Security:

1. **Security Filter Chain:** É um conjunto de filtros que são executados na ordem especificada para processar solicitações HTTP. Cada filtro 
executa uma tarefa específica relacionada à segurança, como autenticação, autorização, proteção contra CSRF, entre outros.

2. **Filter Chain Order:** Os filtros no `SecurityFilterChain` são executados em uma ordem específica, determinada pelo número de ordem (ou 
prioridade) de cada filtro. Isso permite que você controle a sequência exata em que os filtros são aplicados às solicitações.

3. **Filter Chain Entry Points:** Cada `SecurityFilterChain` geralmente começa com um "entry point", que é responsável por decidir como tratar 
solicitações não autenticadas. Por exemplo, ele pode redirecionar para uma página de login ou retornar um erro não autorizado.

4. **Matcher:** O Spring Security permite que você associe filtros a padrões de URL específicos por meio de matchers. Isso significa que você 
pode configurar regras de segurança diferentes para URLs diferentes em sua aplicação.

Aqui está um exemplo simplificado de como você pode configurar um `SecurityFilterChain` em uma aplicação Spring Security:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {

    @Override
    public void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests(authorizeRequests ->
                authorizeRequests
                    .antMatchers("/public/**").permitAll()
                    .antMatchers("/admin/**").hasRole("ADMIN")
                    .anyRequest().authenticated()
            )
            .formLogin(withDefaults());
    }
}
```

Neste exemplo:

- O `SecurityFilterChain` é configurado para permitir acesso não autenticado a URLs que correspondam a `/public/**`, exigir a função "ADMIN" 
  para URLs que correspondam a `/admin/**` e exigir autenticação para todas as outras URLs.

- `formLogin()` é usado para configurar o suporte à autenticação baseada em formulário.

O `SecurityFilterChain` é uma parte essencial da configuração do Spring Security e permite que você defina como as regras de segurança devem 
ser aplicadas em diferentes partes de sua aplicação. Ele oferece flexibilidade para personalizar a segurança de acordo com as necessidades 
específicas do seu aplicativo.

--------------- // ---------------

Anotação @EnableWebSecurity

A anotação `@EnableWebSecurity` é uma anotação importante e uma parte fundamental da configuração do Spring Security em aplicativos baseados em 
Spring. Essa anotação é geralmente usada em uma classe de configuração para habilitar o suporte do Spring Security e configurar as políticas de 
segurança para sua aplicação web.

Alguns pontos-chave sobre a anotação `@EnableWebSecurity`:

1. **Ativação do Spring Security:** Quando você anota uma classe de configuração com `@EnableWebSecurity`, você está ativando o suporte do 
Spring Security para seu aplicativo. Isso faz com que o Spring Security se torne parte do contexto de aplicativo e comece a aplicar as 
configurações de segurança.

2. **Personalização de Configurações:** A anotação `@EnableWebSecurity` é frequentemente usada em conjunto com uma classe de configuração que 
estende `WebSecurityConfigurerAdapter`. Isso permite que você personalize as configurações de segurança do Spring Security, como regras de 
autorização, autenticação, configurações de CORS (Cross-Origin Resource Sharing), proteção CSRF (Cross-Site Request Forgery), entre outros.

3. **Ponto de Início da Configuração:** A classe de configuração anotada com `@EnableWebSecurity` serve como o ponto de entrada para configurar 
políticas de segurança em seu aplicativo. Ela geralmente inclui métodos anotados com `@Override` que permitem personalizar aspectos específicos 
da segurança.

Em resumo, a anotação `@EnableWebSecurity` é essencial para ativar e configurar o Spring Security em seu aplicativo web Spring. Ela marca a 
classe de configuração que será usada para definir as políticas de segurança, como controle de acesso, autenticação e outras configurações 
relacionadas à segurança.

--------------- // ---------------

Classe WebSecurityConfigurerAdapter

A classe `WebSecurityConfigurerAdapter` é uma classe importante no framework Spring Security que fornece uma maneira conveniente de personalizar 
as configurações de segurança em um aplicativo web Spring. Ela faz parte do módulo Spring Security e é frequentemente estendida para criar 
classes de configuração personalizadas que definem políticas de segurança específicas para um aplicativo.

Principais pontos sobre a classe `WebSecurityConfigurerAdapter`:

1. **Personalização de Configurações de Segurança:** A classe `WebSecurityConfigurerAdapter` é uma classe base que pode ser estendida para 
personalizar as configurações de segurança do Spring Security em um aplicativo web. Ela oferece métodos configuráveis que permitem definir 
políticas de segurança, regras de autorização, autenticação e outras configurações relacionadas à segurança.

2. **Uso de Anotações:** Você pode usar anotações Java, como `@Configuration`, `@EnableWebSecurity`, `@EnableGlobalMethodSecurity`, `@Order` e 
outras, para configurar a classe que estende `WebSecurityConfigurerAdapter`. Essas anotações ajudam a definir quando e como as configurações de 
segurança personalizadas devem ser aplicadas.

3. **Métodos Configuráveis:** A classe `WebSecurityConfigurerAdapter` possui uma série de métodos configuráveis que podem ser sobrescritos na 
classe filha para definir comportamentos específicos de segurança. Alguns dos métodos mais comuns incluem:

   - `configure(HttpSecurity http)`: Este método permite configurar as regras de segurança para URLs específicos, como regras de autorização, 
      configurações de CORS, proteção CSRF e muito mais.

   - `configure(AuthenticationManagerBuilder auth)`: Este método permite configurar como a autenticação será realizada, como autenticação em 
      memória, autenticação baseada em banco de dados, autenticação LDAP, etc.

   - `configure(WebSecurity web)`: Este método permite configurar como as solicitações de recursos estáticos (por exemplo, arquivos CSS, 
      JavaScript) são tratadas em relação à segurança.

4. **Prioridade de Configuração:** Quando você estende a classe `WebSecurityConfigurerAdapter`, pode criar várias classes de configuração de 
    segurança, cada uma com um propósito diferente. A ordem de prioridade entre essas classes é determinada pelas anotações `@Order` ou pela 
    ordem de carregamento definida pelo Spring. Isso permite que você defina configurações gerais em uma classe e substitua ou adicione 
    configurações específicas em outras classes, se necessário.

5. **Integração com Spring Boot:** Se você estiver usando o Spring Boot, pode simplesmente criar uma classe que estenda 
   `WebSecurityConfigurerAdapter` e, em seguida, personalizar suas configurações de segurança. O Spring Boot fará a configuração automática do 
   Spring Security com base nas configurações que você fornecer.

Em resumo, a classe `WebSecurityConfigurerAdapter` é uma parte crucial do Spring Security que facilita a personalização e configuração das 
políticas de segurança em um aplicativo web Spring. Ela fornece métodos configuráveis que permitem definir como a autenticação e a autorização 
devem ser tratadas em seu aplicativo. É amplamente usada para criar configurações de segurança personalizadas em aplicativos Spring Security.

--------------- // ---------------

Classe PasswordEncoder

A classe `PasswordEncoder` é uma parte importante do Spring Security que é usada para codificar senhas e validar senhas codificadas em 
aplicativos web. Ela faz parte do módulo Spring Security e é essencial para a segurança de autenticação em sistemas onde as senhas dos usuários 
são armazenadas.

A principal função do `PasswordEncoder` é fornecer uma maneira segura de armazenar senhas no banco de dados e verificar se a senha fornecida 
pelo usuário durante o processo de autenticação corresponde à senha armazenada.

Principais aspectos da classe `PasswordEncoder`:

1. **Codificação de Senhas:** O principal objetivo do `PasswordEncoder` é transformar (codificar) uma senha em uma representação não reversível, 
conhecida como "hash". Isso é feito para que a senha real não seja armazenada diretamente no banco de dados. O hash é uma sequência de 
caracteres fixa e única que é gerada a partir da senha original. Quando um usuário tenta fazer login, a senha fornecida é codificada da mesma 
maneira e o resultado é comparado com o hash armazenado no banco de dados.

2. **Segurança:** O uso de um `PasswordEncoder` é crucial para a segurança de senhas. Ele protege as senhas dos usuários de exposição em caso 
de violação de dados. Mesmo que um invasor acesse o banco de dados, ele não pode obter as senhas reais, apenas os hashes.

3. **Múltiplos Algoritmos:** O Spring Security oferece várias implementações de `PasswordEncoder`, cada uma usando um algoritmo de hash 
diferente. Alguns dos algoritmos comuns incluem BCrypt, SCrypt, PBKDF2 e muito mais. A escolha do algoritmo dependerá dos requisitos de 
segurança do aplicativo. O BCrypt é frequentemente recomendado devido à sua segurança e desempenho.

4. **Configuração:** Em um aplicativo Spring Security, você pode configurar o `PasswordEncoder` para ser usado em sua classe de configuração 
que estende `WebSecurityConfigurerAdapter`. Isso é feito por meio do método `configure(AuthenticationManagerBuilder auth)`, onde você define 
como as senhas serão codificadas e verificadas durante o processo de autenticação.

5. **Verificação de Senha:** Além de codificar senhas, o `PasswordEncoder` também fornece métodos para verificar se uma senha não codificada 
(fornecida pelo usuário durante a autenticação) corresponde ao hash armazenado no banco de dados. O Spring Security cuida dessa verificação 
automaticamente quando você configura um `PasswordEncoder` apropriado.

--------------- // ---------------

Classe PasswordEncoderFactories

A classe `PasswordEncoderFactories` faz parte do Spring Security e é usada para criar instâncias de `PasswordEncoder` com base em vários 
algoritmos de codificação de senha. Ela fornece uma maneira fácil de criar um `PasswordEncoder` usando diferentes algoritmos, sem a necessidade 
de configurá-lo manualmente. A classe `PasswordEncoderFactories` é uma fábrica de `PasswordEncoder`.

Alguns dos métodos estáticos da classe `PasswordEncoderFactories` e os algoritmos de codificação de senha que eles podem criar:

1. **`createDelegatingPasswordEncoder()`**: Este método cria um `PasswordEncoder` que é capaz de verificar senhas codificadas com diferentes algoritmos. Ele suporta senhas codificadas com os seguintes algoritmos:
   - `bcrypt`: Usando o BCryptPasswordEncoder.
   - `noop`: Senhas não codificadas (não recomendado para produção).
   - `sha256`: Usando o StandardPasswordEncoder.
   - `sha256-hex`: Usando o StandardPasswordEncoder com hash em formato hexadecimal.
   - `sha256-b64`: Usando o StandardPasswordEncoder com hash em Base64.

2. **`createDelegatingPasswordEncoder(PasswordEncoder defaultPasswordEncoder, Map<String, PasswordEncoder> idToPasswordEncoder)`**: Este método 
permite que você crie um `PasswordEncoder` personalizado com um codificador padrão e um mapa de codificadores adicionais. Isso é útil quando 
você deseja adicionar suporte a algoritmos de codificação personalizados.

Exemplo simples de uso:

```java
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;

public class Main {
    public static void main(String[] args) {
        // Criar um PasswordEncoder delegado com BCrypt como padrão
        PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder();

        // Codificar uma senha usando BCrypt
        String encodedPassword = passwordEncoder.encode("minhaSenha");

        // Verificar se uma senha corresponde ao hash usando o PasswordEncoder
        boolean matches = passwordEncoder.matches("minhaSenha", encodedPassword);
        System.out.println("Senha corresponde: " + matches);
    }
}
```

Neste exemplo, usamos o `createDelegatingPasswordEncoder()` para criar um `PasswordEncoder` que suporta múltiplos algoritmos, com o BCrypt 
como padrão. Em seguida, codificamos uma senha usando o BCrypt e verificamos se outra senha corresponde ao hash usando o método `matches()`. O 
Spring Security cuidará automaticamente da seleção do algoritmo correto com base na senha armazenada no banco de dados.

--------------- // ---------------

Para acessar a listar pelo método HTTP GET, essa linha de código:
                .withUser("Daniel")
                .password(passwordEncoder.encode("admin"))
                .roles("USER", "ADMIN")

Precisa ser inserida na Auth Basic, nela será colocado o user "Daniel" e o password "admin" para que suas requisições  HTTP GET quando forem 
feitas possam ser validadas e autorizadas.

Esse trecho de código adicionado ".csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())" garante a criação de token que 
vai ser gerado no cookie do Postman ou do Thunder Client. É a partir desse token gerado que você irá copiar e colar na "Key" da aba "Headers" 
quando quiser utilizar o método HTTP POST. 

No Postman será inserido a key: "X-XSRF-TOKEN" e o value: <colar_token>
No Thunder Cliente será inserido no header: "X-XSRF-TOKEN" e o value: <colar_token>

--------------- // ---------------

CSRF Token no Spring Security

O Spring Security é uma estrutura popular para segurança em aplicativos Java e oferece suporte robusto para proteger aplicativos da web contra
várias ameaças, incluindo ataques CSRF (Cross-Site Request Forgery). No Spring Security, a proteção CSRF é implementada usando um recurso 
conhecido como "CSRF Token."

Aqui está uma visão geral de como o CSRF Token funciona no Spring Security:

1. **Geração do CSRF Token**:
   - Quando um usuário faz login em um aplicativo protegido pelo Spring Security, um token CSRF é gerado automaticamente pelo framework.
   - Esse token é exclusivo para a sessão do usuário e normalmente é armazenado em uma sessão HTTP ou em um cookie seguro.

2. **Inclusão no Formulário HTML**:
   - O token CSRF gerado é então incluído automaticamente em todos os formulários HTML gerados pelo aplicativo.
   - Isso é feito usando a tag `<input>` especial com o nome `_csrf` (esse nome pode ser personalizado, se necessário).

```html
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />
```

3. **Verificação do CSRF Token**:
   - Quando o usuário envia um formulário ou uma solicitação HTTP que modifica o estado do aplicativo (por exemplo, uma solicitação POST), o 
     Spring Security verifica automaticamente se o token CSRF fornecido na solicitação corresponde ao token armazenado na sessão do usuário.

   - Se os tokens não corresponderem, a solicitação será considerada suspeita e será rejeitada, protegendo assim contra ataques CSRF.

4. **Customização**:
   - O Spring Security permite personalizar várias configurações relacionadas ao CSRF Token, como o nome do parâmetro do token, como o token é 
     armazenado (por exemplo, em um cookie seguro), ou como o token é validado.

Em resumo, o CSRF Token no Spring Security é uma medida fundamental para proteger aplicativos da web contra ataques CSRF, e sua implementação 
é facilitada pelo framework, permitindo que os desenvolvedores foquem mais em sua lógica de negócios enquanto mantêm a segurança da aplicação.

--------------- // ---------------

Anotação @PreAuthorize

A anotação `@PreAuthorize` faz parte do Spring Security, que é um módulo do Spring Framework usado para adicionar recursos de segurança a 
aplicativos Java. Essa anotação é uma das maneiras de definir regras de autorização personalizadas em métodos de controladores, serviços ou 
outros componentes do Spring.

A anotação `@PreAuthorize` permite que você especifique condições de autorização em um método antes que o método seja executado. Essas condições 
são expressas usando uma linguagem de expressão que avalia se o usuário atual tem permissão para acessar o método. Essa expressão pode ser 
baseada em informações do usuário, como seu nome de usuário, funções (roles) ou qualquer outro atributo relevante.

Exemplo simples de como usar a anotação `@PreAuthorize`:

```java
import org.springframework.security.access.prepost.PreAuthorize;

@Controller
public class MyController {

    @GetMapping("/secure")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public String securePage() {
        // Código para a página protegida
        return "securePage";
    }
}
```

Neste exemplo:

- A anotação `@PreAuthorize` é usada no método `securePage()`.
- A expressão `"hasRole('ROLE_ADMIN')"` é definida como condição de autorização. Isso significa que apenas os usuários que têm a função (role) 
  "ROLE_ADMIN" têm permissão para acessar esse método.

Além disso, você pode usar operadores lógicos, como `and`, `or` e `not`, para criar condições mais complexas. Por exemplo:

```java
@PreAuthorize("hasRole('ROLE_ADMIN') and hasIpAddress('192.168.0.1')")
```

Neste caso, a condição de autorização exige que o usuário tenha a função "ROLE_ADMIN" e esteja acessando de um endereço IP específico 
(192.168.0.1).

Em resumo, a anotação `@PreAuthorize` é uma poderosa ferramenta do Spring Security que permite definir regras de autorização personalizadas em 
métodos de seus componentes Spring, ajudando a controlar o acesso a partes específicas do seu aplicativo com base em condições específicas.

--------------- // ---------------

Anotação @EnableGlobalMethodSecurity

A anotação `@EnableGlobalMethodSecurity` é usada em configurações do Spring Security para habilitar o suporte a segurança em nível de método. 
Quando usa a opção `prePostEnabled = true`, permite o uso de anotações de segurança, como `@PreAuthorize` e `@PostAuthorize`, para controlar o 
acesso a métodos específicos em seu aplicativo.

Detalhes dessa anotação:

- `@EnableGlobalMethodSecurity` é uma anotação de configuração do Spring Security.
- `prePostEnabled = true` é um parâmetro da anotação que, quando definido como `true`, habilita o uso de anotações de segurança baseadas em 
   expressões, como `@PreAuthorize` e `@PostAuthorize`, em seus métodos.

como isso funciona:

1. **Habilitar a Segurança em Nível de Método**:
   - Quando adiciona a anotação `@EnableGlobalMethodSecurity(prePostEnabled = true)` à sua configuração do Spring Security, significa que
    você está ativando o suporte a segurança em nível de método em seu aplicativo.

2. **Uso de Anotações de Segurança**:
   - Com o suporte a segurança em nível de método habilitado, você pode usar anotações de segurança, como `@PreAuthorize` e `@PostAuthorize`, 
     em métodos de seus controladores ou serviços.

   - Essas anotações permitem que você defina regras de autorização personalizadas para métodos específicos com base em expressões.

Exemplo de uso:

```java
import org.springframework.security.access.prepost.PreAuthorize;

@Service
public class MyService {

    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public void adminOnlyMethod() {
        // Este método só pode ser acessado por usuários com a função ROLE_ADMIN.
    }
}
```

Neste exemplo, o método `adminOnlyMethod` só pode ser executado por usuários que têm a função (role) "ROLE_ADMIN". Isso é possível graças ao 
uso da anotação `@PreAuthorize`, que é habilitada pela configuração `@EnableGlobalMethodSecurity(prePostEnabled = true)`.

Em resumo, a anotação `@EnableGlobalMethodSecurity(prePostEnabled = true)` é usada para habilitar o suporte a segurança em nível de método no 
Spring Security, permitindo o uso de anotações de segurança como `@PreAuthorize` e `@PostAuthorize` para controlar o acesso a métodos 
específicos com base em regras de autorização personalizadas. Isso é útil quando você precisa de granularidade nas permissões dentro de seu 
aplicativo, permitindo que diferentes métodos tenham diferentes requisitos de autorização.

OBS. A utilização dessas anotações (@PreAuthorize e @EnableGlobalMethodSecurity) é para exemplificar que somente quem for admin poderá utilizar 
o método HTTP GET, ou seja, na classe "SecurityConfig", o usuario Biana não terá autorização para criar um anime.


--------------- // ---------------

Anotação @AuthenticationPrincipal

A anotação `@AuthenticationPrincipal` é uma anotação do Spring Security que facilita o acesso ao objeto `Principal` (representando o usuário 
autenticado) em seus controladores ou serviços Spring. Essa anotação é especialmente útil quando você precisa acessar informações específicas 
do usuário autenticado em um método de controlador ou serviço.

Detalhes dessa anotação:

1. **Objeto `Principal`**:
   - O objeto `Principal` é uma parte fundamental do sistema de autenticação do Spring Security. Ele representa o usuário autenticado na sessão 
     atual.

2. **Uso do `@AuthenticationPrincipal`**:
   - A anotação `@AuthenticationPrincipal` permite injetar diretamente o objeto `Principal` no método de um controlador ou serviço Spring.
   - Ela simplifica o acesso às informações do usuário autenticado, tornando-as facilmente disponíveis como um parâmetro do método.

Essa anotação é útil quando você precisa acessar informações específicas do usuário autenticado em seus métodos de controlador ou serviço, 
tornando o código mais limpo e legível.

Além disso, observe que a anotação `@AuthenticationPrincipal` também pode ser usada com classes personalizadas em vez de `Principal`. Por 
exemplo, se você tiver uma classe `User` representando os detalhes do usuário autenticado, você pode usá-la em vez de `Principal`, desde que a 
classe implemente a interface `Principal`.

--------------- // ---------------

Interface UserDetails

A classe `UserDetails` faz parte do Spring Security e é uma parte fundamental do sistema de autenticação e autorização. Ela é uma interface que 
define um contrato para fornecer informações sobre um usuário autenticado no sistema. Implementar a interface `UserDetails` permite personalizar 
a forma como o Spring Security lida com os detalhes do usuário durante a autenticação e a autorização.

Aqui estão os principais componentes da interface `UserDetails` e como ela é usada:

1. **getUsername()**: Este método retorna o nome de usuário do usuário. O nome de usuário é usado para autenticar o usuário durante o processo 
de login. Ele é geralmente uma string única que identifica exclusivamente um usuário no sistema.

2. **getPassword()**: Retorna a senha do usuário. A senha geralmente está criptografada para segurança. Durante o processo de autenticação, o 
Spring Security compara a senha fornecida pelo usuário com a senha armazenada no `UserDetails`.

3. **getAuthorities()**: Retorna uma coleção de autoridades (papéis ou funções) associadas ao usuário. As autoridades representam as permissões 
do usuário e são usadas pelo Spring Security para controle de acesso. Uma autoridade pode ser algo como "ROLE_USER" ou "ROLE_ADMIN".

4. **isAccountNonExpired()**: Este método indica se a conta do usuário está ou não expirada. Se a conta estiver expirada, o usuário não poderá 
efetuar login.

5. **isAccountNonLocked()**: Verifica se a conta do usuário está bloqueada ou não. Se a conta estiver bloqueada, o usuário não poderá efetuar 
login.

6. **isCredentialsNonExpired()**: Verifica se as credenciais do usuário, geralmente a senha, estão ou não expiradas. Se as credenciais estiverem 
expiradas, o usuário não poderá efetuar login.

7. **isEnabled()**: Indica se a conta do usuário está habilitada ou não. Se a conta estiver desabilitada, o usuário não poderá efetuar login.

A classe `UserDetails` é uma interface e pode ser implementada de várias maneiras, dependendo das necessidades do seu aplicativo. Além disso, o 
Spring Security fornece uma implementação padrão chamada `User`, que implementa a interface `UserDetails` e é frequentemente usada para 
armazenar informações de usuário durante o processo de autenticação e autorização.

Em resumo, a classe `UserDetails` é uma interface do Spring Security que define um contrato para fornecer informações sobre um usuário 
autenticado, incluindo nome de usuário, senha, autoridades e status de conta. Implementar essa interface permite personalizar como o Spring 
Security lida com os detalhes do usuário em seu aplicativo.

--------------- // ---------------

Passo a Passo: 

1 - Vou criar um UserDetails, logo vou criar uma classe "CustomUserDetails" onde vai ser implementada pela Interface UserDetails.

2 - Vou criar uma interface Repository, logo vou criar uma interface "CustomUserDetailsRepository" onde vai ser extendida pela classe JpaRepository.

3 - Vou criar uma classe Service, logo vou criar uma classe "CustomUserDetailsService" onde vai ser implementada pela Interface UserDetailsService.

4 - Implementar a chamada do CustomUserDetails no método configure(AuthenticationManagerBuilder auth) na Classe SecurityConfig.

5 - Ao startizar o servidor (Spring Boot Dashboard) vai ser criado o "Password enconded", logo vamos copiar.

6 - Depois vamos ao banco de dados criar um custom-user-details inserindo nome: Daniel, userName: Daniel, Authorities: ROLE_ADMIN, ROLE_USER e o 
password que vamos colar o password enconded - por exemplo, {bcrypt}$2a$10$iUVlo4/B9wLSj4JGsAnbeufwKVRrrELzTRuEdHEKMANRijZavapZy

--------------- // ---------------

antMatchers()

A proteção de URL com `antMatchers()` é uma parte essencial da configuração de segurança do Spring Security. O método `antMatchers()` permite 
especificar padrões de URL e aplicar regras de segurança específicas a essas URLs. Isso é útil para definir quais URLs estão protegidas e quais 
regras de autorização se aplicam a elas. Aqui está uma explicação mais detalhada:

1. **`antMatchers(String... antPatterns)`**: O método `antMatchers()` é usado para definir padrões de URL que você deseja proteger ou aplicar 
regras de segurança. Você pode fornecer um ou mais padrões de URL como argumentos para este método. Um padrão de URL é uma string que pode 
conter wildcards, como `*` e `**`, para corresponder a várias URLs.

2. **Regras de Autorização**:
   - Após chamar `antMatchers()`, você pode encadear métodos para definir regras de autorização específicas para esses padrões de URL. Alguns 
     dos métodos comuns incluem:

     - `.permitAll()`: Permite que todas as solicitações correspondentes acessem a URL sem autenticação.
     - `.authenticated()`: Exige que os usuários estejam autenticados para acessar a URL.
     - `.hasRole("ROLE_NAME")`: Exige que os usuários tenham uma função específica para acessar a URL.
     - `.hasAnyRole("ROLE1", "ROLE2")`: Exige que os usuários tenham pelo menos uma das funções especificadas para acessar a URL.
     - `.hasAuthority("AUTHORITY_NAME")`: Exige que os usuários tenham uma autoridade específica para acessar a URL.
     - `.hasAnyAuthority("AUTH1", "AUTH2")`: Exige que os usuários tenham pelo menos uma das autoridades especificadas para acessar a URL.
     - `.hasIpAddress("IP_ADDRESS")`: Exige que as solicitações originem de um endereço IP específico.

3. **Exemplo de Uso**:
   - Vejamos um exemplo de uso do `antMatchers()` em uma classe de configuração do Spring Security:

   ```java
   @Override
   protected void configure(HttpSecurity http) throws Exception {
       http
           .authorizeRequests()
               .antMatchers("/public/**").permitAll() // URLs públicas acessíveis por todos
               .antMatchers("/admin/**").hasRole("ADMIN") // URLs restritas ao papel ADMIN
               .anyRequest().authenticated() // Todas as outras URLs exigem autenticação
           .and()
           .formLogin() // Configuração de formulário de login
               .loginPage("/login") // Página de login personalizada
               .permitAll()
           .and()
           .logout()
               .permitAll();
   }
   ```

Neste exemplo:

- URLs que correspondem a `/public/**` são acessíveis por todos sem autenticação.
- URLs que correspondem a `/admin/**` exigem que os usuários tenham a função "ADMIN" para acessá-las.
- Todas as outras URLs exigem autenticação.
- Além disso, a configuração inclui a página de login personalizada e configurações relacionadas ao logout.

O uso de `antMatchers()` permite uma configuração granular e flexível da segurança com base em padrões de URL. Isso é especialmente útil em 
aplicativos complexos com várias URLs e requisitos de segurança diferentes para cada uma delas.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Documentação com SpringDoc OpenAPI
Site: https://springdoc.org/

Dependência a ser adicionado no pom.xml - versão compatível:

<!-- Para utilizar o Swagger -->
<dependency>
	<groupId>org.springdoc</groupId>
	<artifactId>springdoc-openapi-ui</artifactId>
	<version>1.7.0</version>
</dependency>

<!-- Para Paginação -->
<dependency>
	<groupId>org.springdoc</groupId>
	<artifactId>springdoc-openapi-data-rest</artifactId>
	<version>1.7.0</version>
</dependency>
		
<!-- Para Spring Security -->
<dependency>
	<groupId>org.springdoc</groupId>
	<artifactId>springdoc-openapi-security</artifactId>
	<version>1.7.0</version>
</dependency>

Acessando pelo Swagger:
http://localhost:8080/swagger-ui.html

--------------- // ---------------

Anotação `@Parameter(hidden = true)`
A anotação `@Parameter(hidden = true)` faz parte da biblioteca Swagger (anteriormente conhecida como Swagger 2 ou Swagger UI) e é usada para 
ocultar um parâmetro de uma operação (por exemplo, um endpoint de API) na documentação gerada pelo Swagger. O Swagger é uma ferramenta que ajuda 
a documentar APIs RESTful de forma automática e também permite que os desenvolvedores interajam com a API por meio de uma interface gráfica.

Quando você anota um parâmetro de operação com `@Parameter(hidden = true)`, você está instruindo o Swagger a não incluir esse parâmetro na 
documentação gerada. Isso pode ser útil em situações em que você tem parâmetros internos ou não relevantes para a documentação pública da API e 
deseja ocultá-los para evitar confusão para os usuários da documentação.

Lembre-se de que a exibição ou ocultação de parâmetros na documentação do Swagger é uma consideração importante ao projetar sua API, pois afeta 
a experiência do usuário final que utiliza a documentação gerada automaticamente para entender como usar sua API. Portanto, use a anotação 
`@Parameter(hidden = true)` com sabedoria e apenas para ocultar informações que não sejam relevantes ou seguras para divulgar publicamente.

--------------- // ---------------

Anotação @ParameterObject

A anotação `@ParameterObject` é usada na documentação Swagger (anteriormente conhecida como Swagger 2 ou Swagger UI) para descrever um objeto 
de parâmetro que é usado em uma operação (por exemplo, um endpoint de API). Essa anotação permite documentar objetos complexos que são passados 
como parâmetros em operações RESTful, como, por exemplo paginação.

Ao usar `@ParameterObject`, você pode especificar informações sobre o objeto de parâmetro, como seu nome, descrição, exemplo e outros detalhes 
relevantes para a documentação da API.

A anotação `@ParameterObject` é útil quando você tem objetos complexos como parâmetros de operação e deseja fornecer informações detalhadas 
sobre esses objetos na documentação Swagger. Isso ajuda os desenvolvedores a entender como usar corretamente a API e quais informações precisam 
fornecer ao fazer chamadas para essa operação.