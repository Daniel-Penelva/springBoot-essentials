public Anime findById(Long id ) {
		return   animes.stream()
				.filter(anime -> anime.getId().equals(id))
				.findFirst().orElseThrow(()-> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found"));
}


Este script é um método em Java que recebe um ID como parâmetro e busca por um objeto Anime em uma lista de animes usando programação funcional 
com Stream.

Vamos analisar o código por partes:

   public Anime findById(Long id): Esta é a declaração do método público chamado findById que retorna um objeto do tipo Anime. Ele aceita um 
   parâmetro id do tipo Long.

   return animes.stream(): Aqui, é criado um fluxo (stream) a partir da lista de animes chamada animes. Um fluxo é uma sequência de elementos 
   que pode ser processada de maneira sequencial ou paralela.

   .filter(anime -> anime.getId().equals(id)): O método filter é usado para filtrar elementos do fluxo com base em uma condição. Neste caso, 
   está filtrando os animes cujo ID seja igual ao ID passado como parâmetro.

   .findFirst(): O método findFirst retorna o primeiro elemento do fluxo que satisfaça a condição definida no filtro. Neste caso, retorna o 
   primeiro anime com o ID correspondente.

   .orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST, "Anime not found")): O método orElseThrow é usado para retornar o valor 
   presente no fluxo, caso exista. Se o fluxo estiver vazio (nenhum anime corresponde ao ID), uma exceção é lançada. No caso, uma 
   ResponseStatusException com um status HTTP BAD_REQUEST (código 400) é lançada, indicando que o anime não foi encontrado.

Portanto, esse método busca por um anime na lista de animes pelo ID usando programação funcional com Stream. Se o anime for encontrado, ele é 
retornado. Caso contrário, uma exceção é lançada indicando que o anime não foi encontrado.

É importante notar que o código pressupõe a existência de uma lista de animes chamada animes que contém os objetos Anime a serem pesquisados. 
Além disso, a classe Anime deve ter um método getId() para acessar o ID do anime. A exceção ResponseStatusException é lançada com base no 
framework Spring Web para lidar com respostas HTTP em APIs.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A propriedade `server.error.include-stacktrace` é uma configuração que pode ser usada em aplicações Spring Boot para controlar se as informações 
de rastreamento de pilha (stack trace) são incluídas nas respostas de erro HTTP retornadas pela aplicação em caso de exceções.

Os valores possíveis para a propriedade `server.error.include-stacktrace` são:

1. `on-param` (valor padrão):
   - Isso significa que o rastreamento de pilha é incluído na resposta somente se um parâmetro de consulta chamado `trace` estiver presente na 
     solicitação HTTP. Isso permite que você escolha se deseja ou não incluir o rastreamento de pilha nas respostas de erro, controlando-o 
     através da presença ou ausência do parâmetro de consulta.

2. `always`:
   - Isso faz com que o rastreamento de pilha seja sempre incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta específico. Isso pode ser útil para depuração e diagnóstico de problemas.

3. `never`:
   - Isso faz com que o rastreamento de pilha nunca seja incluído nas respostas de erro, independentemente da presença de um parâmetro de 
     consulta. Essa opção pode ser usada para ocultar informações sensíveis ou internas da aplicação nos erros retornados aos usuários.

Essa propriedade é útil para controlar o nível de detalhes das mensagens de erro retornadas pelas APIs e pode ser configurada no arquivo 
`application.properties` ou `application.yml` da sua aplicação Spring Boot. Ela pode ajudar a equilibrar a necessidade de informações detalhadas 
para depuração com a segurança e a privacidade das informações do aplicativo.

Exemplo de configuração no `application.properties`:

```properties
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server.error.include-stacktrace=on-param
```

Exemplo de configuração no `application.yml`:

```yaml
# Incluir rastreamento de pilha somente quando o parâmetro de consulta "trace" estiver presente
server:
  error:
    include-stacktrace: on-param
```

Lembre-se de que essa configuração afeta a maneira como as respostas de erro são geradas e retornadas pela sua aplicação Spring Boot.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

A anotação @RequestBody é uma anotação fornecida pelo Spring Framework em aplicações Spring MVC e Spring WebFlux. Ela é usada para indicar que um 
parâmetro de método em um controlador deve ser vinculado ao corpo (body) da solicitação HTTP recebida. Essa anotação é frequentemente usada ao 
criar endpoints de API que recebem dados em formato JSON ou outros formatos no corpo da solicitação.

Quando você adiciona a anotação @RequestBody a um parâmetro de método, o Spring Framework assume que os dados no corpo da solicitação HTTP devem 
ser convertidos automaticamente para o tipo do parâmetro, geralmente um objeto Java.

A anotação @RequestBody é frequentemente usada em conjunto com outros métodos do Spring Framework, como @PostMapping, @PutMapping e outros, para 
criar endpoints de API que aceitam dados no corpo da solicitação. Isso é especialmente útil em cenários de criação, atualização ou envio de 
informações em APIs RESTful.

Lembre-se de que o Spring Framework usa a biblioteca Jackson para realizar a desserialização automática de JSON para objetos Java. Portanto, é 
importante ter as dependências do Jackson configuradas em seu projeto para que a anotação @RequestBody funcione corretamente.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeService: 

```
anime.setId(ThreadLocalRandom.current().nextLong(3, 100));
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Entendendo o código implementação no AnimeController: 

```
return new ResponseEntity<>(HttpStatus.NO_CONTENT);
```

Estou definindo um ID para o objeto Anime passado como parâmetro. O método nextLong(3, 100) da classe ThreadLocalRandom gera um número aleatório 
do tipo long entre 3 (inclusive) e 100 (exclusivo). Esse número aleatório é usado como ID do objeto Anime.

O HttpStatus.NO_CONTENT é um valor enumerado (enum) da classe HttpStatus fornecida pelo Spring Framework. Ele representa o status HTTP 204 
No _Content, que é uma resposta padrão usada em APIs RESTful para indicar que uma solicitação foi processada com sucesso, mas não há conteúdo 
para retornar na resposta.

Quando uma solicitação é tratada com sucesso e o servidor não precisa enviar nenhum conteúdo de volta ao cliente, o status HTTP 204 
No_ Content é usado. Isso é comum em casos onde uma solicitação de exclusão, atualização ou outra ação bem-sucedida é processada, mas 
não há necessidade de enviar um corpo de resposta.

Em termos simples, o HttpStatus.NO_CONTENT é usado para indicar que a solicitação foi bem-sucedida e não há conteúdo adicional a ser 
enviado no corpo da resposta. Isso economiza largura de banda e melhora a eficiência da comunicação entre o cliente e o servidor.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vou explicar cada parte do seu arquivo `docker-compose.yml`:

1. `version: '3.1'`: Isso define a versão da especificação do Docker Compose que você está usando. No seu caso, está usando a versão 3.1. Cada 
    versão traz diferentes recursos e sintaxe.

2. `services`: Essa seção define os serviços (ou contêineres) que você deseja executar.

   - `db`: Este é o nome do serviço. Você o nomeou como "db", que é um nome comum para um serviço de banco de dados.
   
      - `image: mysql`: Especifica a imagem do Docker que você deseja usar para esse serviço. Neste caso, está usando a imagem oficial do MySQL 
         disponível no Docker Hub.
      
      - `container_name: mysql`: Isso define o nome do contêiner que será criado. Neste caso, está definindo o nome como "mysql".
      
      - `environment`: Define variáveis ​​de ambiente para o contêiner MySQL. No caso, está definindo a senha do root do MySQL como "root".
      
      - `ports`: Especifica a mapeamento de portas entre o host e o contêiner. Aqui, você está mapeando a porta 3306 do host para a porta 3306 
         do contêiner MySQL. Isso permite que você acesse o MySQL no contêiner por meio da porta 3306 no seu computador local.
      
      - `volumes`: Define os volumes que serão montados no contêiner. Está criando um volume chamado "devdojo_data" e montando-o na pasta 
        `/var/lib/mysql` dentro do contêiner MySQL. Isso é útil para armazenar os dados do banco de dados de forma persistente, mesmo que o 
        contêiner seja destruído.
   
3. `volumes`: Esta seção define os volumes que serão usados ​​pelos serviços.

   - `devdojo_data`: Este é o nome do volume. Está definindo um volume chamado "devdojo_data", que será usado para armazenar os dados do MySQL.

Dessa forma, o Docker Compose irá criar um contêiner MySQL usando a imagem oficial do MySQL, definindo a senha do root como "root", mapeando a 
porta 3306 do host para a porta 3306 do contêiner e criando um volume chamado "devdojo_data" para armazenar os dados do MySQL de forma 
persistente. O nome do contêiner será "mysql". Isso é útil para o desenvolvimento de aplicativos que usam o MySQL, pois permite que você tenha 
um banco de dados isolado e persistente em um contêiner.

--------------- // ---------------
IMPORTANTE!!!

 -> CTRL + C: Para parar a execução do container do docker
 -> docker-compose up: Cria e inicia os containers definidos no arquivo docker-compose.yml.
 -> docker-compose down: Para e remove os containers definidos no arquivo docker-compose.yml.
 -> docker-compose ps: Lista os containers gerenciados pelo Docker Compose.
 -> docker-compose logs: Exibe os logs dos containers gerenciados pelo Docker Compose.
 -> docker-compose build: Constrói os serviços definidos no arquivo docker-compose.yml.
 -> docker-compose start: Inicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose stop: Para os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker-compose restart: Reinicia os containers dos serviços definidos no arquivo docker-compose.yml.
 -> docker ps: Lista os conatiners que estão sendo executados no momento no docker.
 -> docker ps: Lista os containers em execução no momento.
 -> docker ps -a: Lista todos os containers, incluindo os que estão parados.

 --------------- // ---------------

Explicando cada parte desse script de configuração:

```
server:
  error:
    include-stacktrace: on-param

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
```

Este é um arquivo de configuração YAML que define várias configurações para um aplicativo Spring Boot que se conecta a um banco de dados MySQL. 
Vou explicar cada seção:

1. `server:`: Esta seção permite configurar algumas propriedades do servidor embutido do Spring Boot.

   - `error:`: Aqui, está configurando o tratamento de erros. `include-stacktrace: on-param` significa que as mensagens de erro incluirão 
     informações de rastreamento de pilha (stack trace) quando você passar um parâmetro de consulta chamado `on-param`.

2. `spring:`: Esta é a seção principal de configuração relacionada ao Spring Boot.

   - `datasource:`: Aqui, está configurando o DataSource, que é usado para se conectar ao banco de dados.

     - `url`: Esta é a URL de conexão JDBC para o banco de dados MySQL. O `jdbc:mysql://localhost:3306/anime?useSSL=false&createDatabaseIfNotExist=true` 
        indica que o banco de dados está localizado em `localhost` na porta `3306`. O `anime` é o nome do banco de dados. Os parâmetros 
        `useSSL=false` e `createDatabaseIfNotExists=true` configuram a conexão para não usar SSL (útil em ambientes de desenvolvimento) e para 
        criar o banco de dados automaticamente se ele não existir.

     - `username`: Define o nome de usuário para autenticação no banco de dados. Aqui, é definido como "root".

     - `password`: Define a senha para autenticação no banco de dados. Aqui, é definido como "root".

   - `jpa:`: Esta é a seção de configuração relacionada à JPA (Java Persistence API), que é usada para trabalhar com persistência de dados em Java.

     - `hibernate:`: Configurações específicas do Hibernate, que é a implementação JPA padrão do Spring Boot.

       - `ddl-auto`: Essa propriedade controla como o Hibernate gerencia o esquema do banco de dados. No valor "update", o Hibernate tentará 
          atualizar automaticamente o esquema do banco de dados com base nas mudanças nas entidades (classes de modelo) do seu aplicativo. Isso 
          é útil durante o desenvolvimento, pois permite que você faça alterações nas suas entidades sem precisar recriar manualmente as tabelas 
          no banco de dados.

Em resumo, esse arquivo de configuração define como o Spring Boot se conectará a um banco de dados MySQL, configurações do Hibernate para 
atualização automática do esquema e algumas configurações de tratamento de erros. Certifique-se de substituir os valores de `username` e 
`password` por valores seguros e adequados para seu ambiente de desenvolvimento ou produção.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Vamos Criar uma Classe DTO AnimePostRequestBody, uma classe DTO (Data Transfer Object) é um padrão de projeto usado no desenvolvimento de 
software para transferir dados entre diferentes partes de um sistema. Ela é uma classe simples que contém campos para armazenar dados e pode
incluir métodos para acessar e manipular esses dados. O principal objetivo de uma classe DTO é encapsular os dados e permitir sua transferência 
eficiente entre diferentes componentes de um sistema, muitas vezes em cenários onde a estrutura dos dados entre esses componentes é diferente.

Os DTOs são frequentemente usados em aplicações que seguem uma arquitetura em camadas, como as aplicações baseadas em microservices, onde 
diferentes partes do sistema podem ter diferentes necessidades de dados e formatos de representação. Eles ajudam a evitar o vazamento de 
abstrações de dados e a reduzir o acoplamento entre as camadas.

Algumas razões pelas quais você pode querer usar DTOs incluem:

1. **Redução de tráfego de rede**: Quando você precisa transferir dados entre um cliente e um servidor, ou entre microservices, pode ser mais 
   eficiente transferir apenas os dados necessários para a operação em vez de todos os campos de uma entidade completa.

2. **Mapeamento entre objetos**: Em um sistema, você pode ter diferentes representações de um objeto para diferentes partes da aplicação 
   (por exemplo, uma representação completa para exibição na interface do usuário e uma representação resumida para APIs). DTOs ajudam a mapear 
   essas diferentes representações.

3. **Segurança**: Em certos casos, você pode querer ocultar certos campos sensíveis ou confidenciais de uma entidade ao transferir dados. DTOs 
   permitem que você selecione apenas os campos necessários para transferência.

4. **Evolução do sistema**: DTOs também permitem que você evolua diferentes partes do sistema independentemente umas das outras. Se a estrutura 
   interna de uma entidade mudar, você pode ajustar apenas o mapeamento entre a entidade e seus DTOs correspondentes, sem afetar a camada que 
   consome esses DTOs.

5. **Aumento de performance**: Em algumas situações, especialmente quando você lida com grandes volumes de dados, o uso de DTOs específicos para 
   as operações pode melhorar a performance, reduzindo a quantidade de dados transferidos e simplificando o processamento.

Lembre-se de que a criação de DTOs adiciona alguma complexidade ao código, pois você terá que gerenciar o mapeamento entre as entidades do 
domínio e os DTOs. Portanto, é importante considerar cuidadosamente se o uso de DTOs é apropriado para o seu caso de uso.

-------------------------------------------------------------------- // -----------------------------------------------------------------------

Anotação @Builder

A anotação `@Builder` é uma anotação do projeto Lombok, uma biblioteca popular para reduzir a verbosidade do código em Java. A anotação `@Builder` 
é usada para gerar automaticamente um padrão de criação de objetos imutáveis usando o padrão Builder. Ela é frequentemente usada em conjunto com 
outras anotações do Lombok, como `@Data` ou `@Value`.

Quando você anota uma classe com `@Builder`, o Lombok cria automaticamente um padrão de construção fluent para a classe, permitindo que você 
crie instâncias dessa classe com mais facilidade e clareza.

Aqui está um exemplo simples de como você usaria a anotação `@Builder`:

```
import lombok.Builder;

@Builder
public class Person {
    private String firstName;
    private String lastName;
    private int age;
}
```

Com essa anotação, o Lombok automaticamente cria um construtor privado na classe `Person` e uma classe interna chamada `PersonBuilder`. Isso 
permite que você crie instâncias de `Person` usando um padrão fluente, como este:

```
Person person = Person.builder()
    .firstName("John")
    .lastName("Doe")
    .age(30)
    .build();
```

Isso ajuda a melhorar a legibilidade do código ao criar objetos com muitos campos, eliminando a necessidade de criar diversos construtores ou 
utilizar construtores telescópicos (com muitos parâmetros) que podem se tornar difíceis de entender.